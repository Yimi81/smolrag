{
  "chunk-c346e41473fd9eb76c6cb193c2af837e": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n﻿// Copyright (C) 2015-2021 gamevanilla - All rights reserved.\n// This code can only be used under the standard Unity Asset Store End User License Agreement.\n// A Copy of the Asset Store EULA is available at http://unity3d.com/company/legal/as_terms.\n\nusing UnityEngine;\nusing UnityEngine.UI;\n\nnamespace UltimateClean\n{\n    /// <summary>\n    /// The gradient effect used throughout the kit. This code is heavily inspired\n\t/// by https://github.com/azixMcAze/Unity-UIGradient. All credit goes to them!\n    /// </summary>\n\t[AddComponentMenu(\"UI/Effects/Gradient\")]\n\tpublic class Gradient : BaseMeshEffect\n\t{\n\t\tpublic Color Color1 = Color.white;\n\t\tpublic Color Color2 = Color.white;\n\n\t\t[Range(-180f, 180f)] public float Angle = -90.0f;\n\n\t\tpublic override void ModifyMesh(VertexHelper vh)\n\t\t{\n\t\t\tif (enabled)\n\t\t\t{\n\t\t\t\tvar rect = graphic.rectTransform.rect;\n\t\t\t\tvar dir = RotationDir(Angle);\n\n\t\t\t\tvar localPositionMatrix = LocalPositionMatrix(rect, dir);\n\n\t\t\t\tvar vertex = default(UIVertex);\n\t\t\t\tfor (var i = 0; i < vh.currentVertCount; i++)\n\t\t\t\t{\n\t\t\t\t\tvh.PopulateUIVertex(ref vertex, i);\n\t\t\t\t\tvar localPosition = localPositionMatrix * vertex.position;\n\t\t\t\t\tvertex.color *= Color.Lerp(Color2, Color1, localPosition.y);\n\t\t\t\t\tvh.SetUIVertex(vertex, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic struct Matrix2x3\n\t\t{\n\t\t\tpublic float m00, m01, m02, m10, m11, m12;\n\n\t\t\tpublic Matrix2x3(float m00, float m01, float m02, float m10, float m11, float m12)\n\t\t\t{\n\t\t\t\tthis.m00 = m00;\n\t\t\t\tthis.m01 = m01;\n\t\t\t\tthis.m02 = m02;\n\t\t\t\tthis.m10 = m10;\n\t\t\t\tthis.m11 = m11;\n\t\t\t\tthis.m12 = m12;\n\t\t\t}\n\n\t\t\tpublic static Vector2 operator *(Matrix2x3 m, Vector2 v)\n\t\t\t{\n\t\t\t\tfloat x = (m.m00 * v.x) - (m.m01 * v.y) + m.m02;\n\t\t\t\tfloat y = (m.m10 * v.x) + (m.m11 * v.y) + m.m12;\n\t\t\t\treturn new Vector2(x, y);\n\t\t\t}\n\t\t}\n\n\t\tprivate Matrix2x3 LocalPositionMatrix(Rect rect, Vector2 dir)\n\t\t{\n\t\t\tfloat cos = dir.x;\n\t\t\tfloat sin = dir.y;\n\t\t\tVector2 rectMin = rect.min;\n\t\t\tVector2 rectSize = rect.size;\n\t\t\tfloat c = 0.5f;\n\t\t\tfloat ax = rectMin.x / rectSize.x + c;\n\t\t\tfloat ay = rectMin.y / rectSize.y + c;\n\t\t\tfloat m00 = cos / rectSize.x;\n\t\t\tfloat m01 = sin / rectSize.y;\n\t\t\tfloat m02 = -(ax * cos - ay * sin - c);\n\t\t\tfloat m10 = sin / rectSize.x;\n\t\t\tfloat m11 = cos / rectSize.y;\n\t\t\tfloat m12 = -(ax * sin + ay * cos - c);\n\t\t\treturn new Matrix2x3(m00, m01, m02, m10, m11, m12);\n\t\t}\n\n\t\tprivate Vector2 RotationDir(float angle)\n\t\t{\n\t\t\tfloat angleRad = angle * Mathf.Deg2Rad;\n\t\t\tfloat cos = Mathf.Cos(angleRad);\n\t\t\tfloat sin = Mathf.Sin(angleRad);\n\t\t\treturn new Vector2(cos, sin);\n\t\t}\n\t}\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 功能定位\n该代码文件实现了一个用于Unity UI组件的渐变效果。它允许用户在UI元素上创建从一个颜色到另一个颜色的线性渐变，并支持通过角度参数调整渐变的方向。该效果通过修改UI顶点的颜色值来实现。\n\n#### 系统角色\n该类继承自`BaseMeshEffect`，在Unity UI系统中用于对UI元素的顶点数据进行自定义修改。它是视觉效果系统中的一个重要组成部分，能够为UI元素提供丰富的视觉表现。\n\n#### 主要特性与技术实现\n- 支持线性渐变效果，可调整起始颜色和结束颜色\n- 支持通过角度参数调整渐变方向\n- 使用矩阵变换计算顶点位置\n- 使用颜色插值算法实现平滑过渡\n- 核心算法基于向量和矩阵运算\n\n### 2. 核心类解析\n\n#### `Gradient`类\n\n**职责说明**  \n该类主要用于实现UI元素的渐变效果，通过重写基类的方法来修改顶点颜色数据，实现从一个颜色到另一个颜色的平滑过渡。\n\n**关键方法清单**  \n- `public override void ModifyMesh(VertexHelper vh)`：重写基类方法，实现渐变效果的核心逻辑\n- `private Vector2 RotationDir(float angle)`：计算旋转方向的向量\n- `private Matrix2x3 LocalPositionMatrix(Rect rect, Vector2 dir)`：计算局部位置变换矩阵\n\n**继承关系**  \n```\nGradient -> BaseMeshEffect -> MonoBehaviour\n```\n\n**依赖模块**  \n- `UnityEngine.UI`命名空间中的`VertexHelper`和`UIVertex`类\n- `UnityEngine`命名空间中的`Mathf`类和`Vector2`类",
    "chunk_order_index": 0,
    "full_doc_id": "doc-0462bb83efcd31b64a73cd2ad4dfa15e"
  },
  "chunk-c2a05c72ee592fa0e117fffa9b7e5faf": {
    "tokens": 665,
    "content": "旋转方向的向量\n- `private Matrix2x3 LocalPositionMatrix(Rect rect, Vector2 dir)`：计算局部位置变换矩阵\n\n**继承关系**  \n```\nGradient -> BaseMeshEffect -> MonoBehaviour\n```\n\n**依赖模块**  \n- `UnityEngine.UI`命名空间中的`VertexHelper`和`UIVertex`类\n- `UnityEngine`命名空间中的`Mathf`类和`Vector2`类\n\n### 3. 关键方法详解\n\n#### `ModifyMesh`方法\n\n**方法签名**  \n```csharp\npublic override void ModifyMesh(VertexHelper vh)\n```\n\n**功能描述**  \n该方法是`BaseMeshEffect`的核心接口，用于修改UI元素的顶点数据。具体实现如下：\n1. 获取UI元素的矩形区域\n2. 计算渐变方向向量\n3. 生成局部位置变换矩阵\n4. 遍历所有顶点，计算每个顶点的位置，并根据该位置在渐变方向上的位置插值颜色值\n\n**算法说明**  \n1. 使用`RotationDir`方法计算渐变方向的单位向量\n2. 使用`LocalPositionMatrix`方法生成变换矩阵，用于将顶点位置转换到渐变空间中\n3. 对每个顶点，计算其在渐变空间中的位置，然后使用`Color.Lerp`方法根据该位置在渐变方向上的比例值插值颜色值\n\n**调用关系**  \n该方法由Unity UI系统调用，具体调用频率取决于UI系统的刷新频率和性能设置\n\n#### `RotationDir`方法\n\n**方法签名**  \n```csharp\nprivate Vector2 RotationDir(float angle)\n```\n\n**功能描述**  \n该方法将给定的角度转换为一个二维向量，用于表示渐变方向的方向向量\n\n**算法说明**  \n使用三角函数将角度转换为向量：\n- x分量为`cos(angle)`\n- y分量为`sin(angle)`\n\n#### `LocalPositionMatrix`方法\n\n**方法签名**  \n```csharp\nprivate Matrix2x3 LocalPositionMatrix(Rect rect, Vector2 dir)\n```\n\n**功能描述**  \n该方法生成一个2x3的变换矩阵，用于将顶点位置转换到渐变空间中\n\n**算法说明**  \n该矩阵用于将顶点的局部位置坐标转换为归一化后的坐标，以便后续进行颜色插值。具体计算如下：\n- 计算矩形的最小值和大小\n- 计算归一化因子\n- 构建变换矩阵，包含旋转、缩放和平移操作\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    BaseMeshEffect --> Gradient\n    Gradient --> MonoBehaviour\n    Matrix2x3 --> Gradient\n    Note left of BaseMeshEffect: 基类 - 提供Mesh效果基架\n    Note left of Matrix2x3: 嵌套结构 - 用于2D空间变换\n```",
    "chunk_order_index": 1,
    "full_doc_id": "doc-0462bb83efcd31b64a73cd2ad4dfa15e"
  },
  "chunk-a7a787de2222a915cabc56f5e40767ea": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n// Copyright (C) 2015-2021 gamevanilla - All rights reserved.\n// This code can only be used under the standard Unity Asset Store End User License Agreement.\n// A Copy of the Asset Store EULA is available at http://unity3d.com/company/legal/as_terms.\n\nusing System.Collections;\nusing UnityEngine;\nusing UnityEngine.UI;\n\nnamespace UltimateClean\n{\n    /// <summary>\n    // This class is responsible for popup management. Popups follow the traditional behavior of\n    // automatically blocking the input on elements behind it and adding a background texture.\n    /// </summary>\n    public class Popup : MonoBehaviour\n    {\n        public Color backgroundColor = new Color(10.0f / 255.0f, 10.0f / 255.0f, 10.0f / 255.0f, 0.6f);\n\n        public float destroyTime = 0.5f;\n\n        private GameObject m_background;\n\n        public void Open()\n        {\n            AddBackground();\n        }\n\n        public void Close()\n        {\n            var animator = GetComponent<Animator>();\n            if (animator.GetCurrentAnimatorStateInfo(0).IsName(\"Open\"))\n            {\n                animator.Play(\"Close\");\n            }\n\n            RemoveBackground();\n            StartCoroutine(RunPopupDestroy());\n        }\n\n        // We destroy the popup automatically 0.5 seconds after closing it.\n        // The destruction is performed asynchronously via a coroutine. If you\n        // want to destroy the popup at the exact time its closing animation is\n        // finished, you can use an animation event instead.\n        private IEnumerator RunPopupDestroy()\n        {\n            yield return new WaitForSeconds(destroyTime);\n            Destroy(m_background);\n            Destroy(gameObject);\n        }\n\n        private void AddBackground()\n        {\n            var bgTex = new Texture2D(1, 1);\n            bgTex.SetPixel(0, 0, backgroundColor);\n            bgTex.Apply();\n\n            m_background = new GameObject(\"PopupBackground\");\n            var image = m_background.AddComponent<Image>();\n            var rect = new Rect(0, 0, bgTex.width, bgTex.height);\n            var sprite = Sprite.Create(bgTex, rect, new Vector2(0.5f, 0.5f), 1);\n            image.material.mainTexture = bgTex;\n            image.sprite = sprite;\n            var newColor = image.color;\n            image.color = newColor;\n            image.canvasRenderer.SetAlpha(0.0f);\n            image.CrossFadeAlpha(1.0f, 0.4f, false);\n\n            var canvas = GameObject.Find(\"Canvas\");\n            m_background.transform.localScale = new Vector3(1, 1, 1);\n            m_background.GetComponent<RectTransform>().sizeDelta = canvas.GetComponent<RectTransform>().sizeDelta;\n            m_background.transform.SetParent(canvas.transform, false);\n            m_background.transform.SetSiblingIndex(transform.GetSiblingIndex());\n        }\n\n        private void RemoveBackground()\n        {\n            var image = m_background.GetComponent<Image>();\n            if (image != null)\n            {\n                image.CrossFadeAlpha(0.0f, 0.2f, false);\n            }\n        }\n    }\n}\n\n源代码内容解释如下：\n```markdown\n# 代码分析报告\n\n## 1. 功能概览\n\n### 1.1 功能定位\n`Popup` 类用于在 Unity 游戏引擎中管理弹出窗口。它负责处理弹出窗口的显示、隐藏、背景管理以及自动销毁等操作。该类遵循传统行为，即弹出窗口会自动阻断背景元素的输入，并添加一个半透明的背景纹理。\n\n### 1.2 系统角色与重要性\n在 Unity 项目中，`Popup` 类扮演了一个关键的 UI 管理角色。它确保弹出窗口能够以一致且可靠的方式显示和隐藏，同时提供一个统一的背景处理机制。这对于保持用户界面的一致性和用户体验的流畅性至关重要。\n\n### 1.3 主要特性与技术实现\n- **背景管理**：使用 `Texture2D` 和 `Sprite` 创建背景，并通过 `Canvas` 组件管理其显示。\n- **动画控制**：通过 `Animator` 组件控制弹出窗口的打开和关闭动画。\n- **自动销毁**：使用协程在指定时间后自动销毁弹出窗口及其背景。\n- **异步操作**：通过 `CrossFadeAlpha` 方法实现背景的渐入渐出效果。\n\n## 2. 核心类解析\n\n### `Popup` 类\n\n#### 2.1 职责说明\n`Popup` 类的主要职责是管理弹出窗口的生命周期，包括打开、关闭、背景创建和销毁。它还负责处理弹出窗口的动画效果和自动销毁机制。\n\n#### 2.2 关键方法清单\n- `public void Open()`：打开弹出窗口并显示背景。\n- `public void Close()`：关闭弹出窗口并隐藏背景。\n- `private IEnumerator RunPopupDestroy()`：异步销毁弹出窗口及其背景。\n- `private void AddBackground()`：创建并显示背景。\n- `private void RemoveBackground()`：隐藏并销毁背景。\n\n#### 2.3 继承关系\n```\nPopup -> MonoBehaviour\n```\n\n#### 2.4 依赖模块\n- `UnityEngine.UI`：用于访问 `Image`、`Sprite` 和 `Canvas` 组件。\n- `UnityEngine`：用于访问 `GameObject`、`Component` 和 `IEnumerator`。\n\n## 3. 关键方法详解\n\n### 3.1 `public void",
    "chunk_order_index": 0,
    "full_doc_id": "doc-82c4538f674ece125398b31955a1e911"
  },
  "chunk-92646135cc78f304df6219c25d23507b": {
    "tokens": 703,
    "content": "Background()`：隐藏并销毁背景。\n\n#### 2.3 继承关系\n```\nPopup -> MonoBehaviour\n```\n\n#### 2.4 依赖模块\n- `UnityEngine.UI`：用于访问 `Image`、`Sprite` 和 `Canvas` 组件。\n- `UnityEngine`：用于访问 `GameObject`、`Component` 和 `IEnumerator`。\n\n## 3. 关键方法详解\n\n### 3.1 `public void Open()`\n#### 方法签名\n```csharp\npublic void Open()\n```\n#### 功能描述\n打开弹出窗口并显示背景。调用 `AddBackground()` 方法创建和显示背景。\n\n#### 调用关系\n被外部类或脚本调用，用于显示弹出窗口。\n\n### 3.2 `public void Close()`\n#### 方法签名\n```csharp\npublic void Close()\n```\n#### 功能描述\n关闭弹出窗口并隐藏背景。检查当前动画状态，播放关闭动画。调用 `RemoveBackground()` 方法隐藏背景，并启动 `RunPopupDestroy()` 协程销毁弹出窗口。\n\n#### 调用关系\n被外部类或脚本调用，用于关闭弹出窗口。\n\n### 3.3 `private IEnumerator RunPopupDestroy()`\n#### 方法签名\n```csharp\nprivate IEnumerator RunPopupDestroy()\n```\n#### 功能描述\n异步销毁弹出窗口及其背景。等待 `destroyTime` 秒后，销毁背景 `GameObject` 和当前 `Popup` 实例。\n\n#### 算法说明\n使用 `IEnumerator` 和 ` WaitForSeconds` 实现异步等待。\n\n#### 调用关系\n被 `Close()` 方法调用，用于销毁弹出窗口。\n\n### 3.4 `private void AddBackground()`\n#### 方法签名\n```csharp\nprivate void AddBackground()\n```\n#### 功能描述\n创建并显示背景。创建一个 `Texture2D` 并设置背景颜色，生成 `Sprite`，创建背景 `GameObject` 并设置其属性。\n\n#### 调用关系\n被 `Open()` 方法调用，用于显示背景。\n\n### 3.5 `private void RemoveBackground()`\n#### 方法签名\n```csharp\nprivate void RemoveBackground()\n```\n#### 功能描述\n隐藏并销毁背景。通过 `CrossFadeAlpha` 方法渐隐背景。\n\n#### 调用关系\n被 `Close()` 方法调用，用于隐藏背景。\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class Popup {\n        +Monobehaviour\n        +void Open()\n        +void Close()\n        +IEnumerator RunPopupDestroy()\n        +void AddBackground()\n        +void RemoveBackground()\n    }\n    class MonoBehaviour\n    Popup --> MonoBehaviour\n```\n\n### 4.1 说明\n- **继承关系**：`Popup` 继承自 `MonoBehaviour`。\n- **依赖关系**：`Popup` 依赖于 `UnityEngine.UI` 和 `UnityEngine` 模块。\n\n## 总结\n`Popup` 类通过管理弹出窗口的生命周期、背景和动画，确保了在 Unity 项目中弹出窗口的一致性和用户体验。其设计遵循传统行为，提供了自动阻断输入和背景管理功能，适用于各种 UI 场景。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-82c4538f674ece125398b31955a1e911"
  },
  "chunk-053c4a154b9a5c836531693cb6702bc5": {
    "tokens": 1166,
    "content": "文件源代码内容如下：\n﻿// Copyright (C) 2015-2021 gamevanilla - All rights reserved.\n// This code can only be used under the standard Unity Asset Store End User License Agreement.\n// A Copy of the Asset Store EULA is available at http://unity3d.com/company/legal/as_terms.\n\nusing UnityEngine;\n\nnamespace UltimateClean\n{\n    /// <summary>\n    /// This component goes together with a button object and contains\n    /// the audio clips to play when the player rolls over and presses it.\n    /// </summary>\n    [RequireComponent(typeof(AudioSource))]\n    public class ButtonSounds : MonoBehaviour\n    {\n        public AudioClip pressedSound;\n        public AudioClip rolloverSound;\n\n        private AudioSource audioSource;\n\n        private void Awake()\n        {\n            audioSource = GetComponent<AudioSource>();\n        }\n\n        public void PlayPressedSound()\n        {\n            audioSource.clip = pressedSound;\n            audioSource.Play();\n        }\n\n        public void PlayRolloverSound()\n        {\n            audioSource.clip = rolloverSound;\n            audioSource.Play();\n        }\n    }\n}\n源代码内容解释如下：\n### 功能概览\n\n- **功能定位**：ButtonSounds 是一个 Unity 脚本组件，用于为按钮对象提供音效播放功能。它能够播放按钮被点击时的音效（pressedSound）和鼠标悬停时的音效（rolloverSound）。\n\n- **角色和重要性**：在 Interactive System 中，ButtonSounds 负责提升用户交互体验，通过音效反馈增强用户对按钮操作的感知。它是 UI 交互系统中的重要组成部分。\n\n- **主要特性与技术实现**：\n  - **支持的特性**：\n    - 播放按钮点击音效\n    - 播放鼠标悬停音效\n  - **技术实现**：\n    - 使用 Unity 的 AudioSource 组件播放音频\n    - 通过 MonoBehaviour 生命周期方法 Awake 初始化组件\n\n---\n\n### 核心类解析\n**类名称**：ButtonSounds\n\n- **职责说明**：ButtonSounds 的设计目的是为按钮对象提供音效播放功能。它通过 AudioSource 组件播放指定的音频剪辑，增强用户交互体验。\n\n- **关键方法清单**：\n  - `private void Awake()`：初始化 AudioSource 组件\n  - `public void PlayPressedSound()`：播放按钮点击音效\n  - `public void PlayRolloverSound()`：播放鼠标悬停音效\n\n- **继承关系**：\n  ```\n  ButtonSounds -> MonoBehaviour\n  ```\n\n- **依赖模块**：\n  - 内部依赖：\n    - `AudioSource`（Unity 组件）\n  - 可能的外部依赖：\n    - 其他脚本（如 ButtonController）可能调用 PlayPressedSound 和 PlayRolloverSound 方法\n\n---\n\n### 关键方法详解\n\n#### 方法：`private void Awake()`\n\n- **方法签名**：`private void Awake()`\n\n- **功能描述**：在 MonoBehaviour 初始化时调用，用于获取并初始化 AudioSource 组件。\n\n- **算法说明**：简单直接，通过 GetComponent<AudioSource>() 获取 AudioSource 组件并赋值给私有变量 audioSource。\n\n- **调用关系**：由 Unity 引擎自动调用，频率为一次（脚本初始化时）。\n\n---\n\n#### 方法：`public void PlayPressedSound()`\n\n- **方法签名**：`public void PlayPressedSound()`\n\n- **功能描述**：设置并播放按钮点击音效（pressedSound）。该方法通常在按钮点击事件（如 OnClick）中被调用。\n\n- **算法说明**：将 audioSource 的 clip 设置为 pressedSound，然后调用 Play() 方法播放音频。\n\n- **调用关系**：可能由其他脚本（如 ButtonController）在按钮点击事件中调用，调用频率取决于按钮被点击的次数。\n\n---\n\n#### 方法：`public void PlayRolloverSound()`\n\n- **方法签名**：`public void PlayRolloverSound()`\n\n- **功能描述**：设置并播放鼠标悬停音效（rolloverSound）。该方法通常在鼠标悬停事件（如 OnMouseOver）中被调用。\n\n- **算法说明**：将 audioSource 的 clip 设置为 rolloverSound，然后调用 Play() 方法播放音频。\n\n- **调用关系**：可能由其他脚本（如 ButtonController）在鼠标悬停事件中调用，调用频率取决于鼠标悬停的次数。\n\n---\n\n### 架构关系图\n\n```mermaid\nclassDiagram\n\n  class ButtonSounds {\n    +AudioClip pressedSound\n    +AudioClip rolloverSound\n    +AudioSource audioSource\n    +void Awake()\n    +void PlayPressedSound()\n    +void PlayRolloverSound()\n  }\n\n  class MonoBehaviour {\n    // MonoBehaviour 是 Unity 的基类，提供生命周期管理等功能\n  }\n\n  ButtonSounds --|> MonoBehaviour : 继承\n  ButtonSounds *-- AudioSource : 依赖\n```\n\n---\n\n### 总结\n\nButtonSounds 是一个简单但功能明确的脚本，用于为按钮对象提供音效反馈。它通过 MonoBehaviour 的生命周期方法 Awake 初始化 AudioSource 组件，并通过 PlayPressedSound 和 PlayRolloverSound 方法播放音效。在实际项目中，ButtonSounds 通常与按钮控制器脚本（如 ButtonController）配合使用，以实现完整的按钮交互功能。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-053c4a154b9a5c836531693cb6702bc5"
  },
  "chunk-9b5d7f23a8c65b26b3d9f962559e1df6": {
    "tokens": 66,
    "content": "对象提供音效反馈。它通过 MonoBehaviour 的生命周期方法 Awake 初始化 AudioSource 组件，并通过 PlayPressedSound 和 PlayRolloverSound 方法播放音效。在实际项目中，ButtonSounds 通常与按钮控制器脚本（如 ButtonController）配合使用，以实现完整的按钮交互功能。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-053c4a154b9a5c836531693cb6702bc5"
  },
  "chunk-d479ece3a7617d3512c9896f93145da8": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n﻿// Copyright (C) 2015-2021 gamevanilla - All rights reserved.\n// This code can only be used under the standard Unity Asset Store End User License Agreement.\n// A Copy of the Asset Store EULA is available at http://unity3d.com/company/legal/as_terms.\n\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\n\nnamespace UltimateClean\n{\n    /// <summary>\n    /// The base button component used in the kit that provides the ability to\n    /// (optionally) play sounds when the user rolls over/presses it.\n    /// </summary>\n    public class CleanButton : Button\n    {\n        private ButtonSounds buttonSounds;\n        private bool pointerWasUp;\n\n        protected override void Awake()\n        {\n            base.Awake();\n            buttonSounds = GetComponent<ButtonSounds>();\n        }\n\n        public override void OnPointerClick(PointerEventData eventData)\n        {\n            if (buttonSounds != null && interactable)\n            {\n                buttonSounds.PlayPressedSound();\n            }\n            base.OnPointerClick(eventData);\n        }\n\n        public override void OnPointerUp(PointerEventData eventData)\n        {\n            pointerWasUp = true;\n            base.OnPointerUp(eventData);\n        }\n\n        public override void OnPointerEnter(PointerEventData eventData)\n        {\n            if (pointerWasUp)\n            {\n                pointerWasUp = false;\n                base.OnPointerEnter(eventData);\n            }\n            else\n            {\n                if (buttonSounds != null && interactable)\n                {\n                    buttonSounds.PlayRolloverSound();\n                }\n                base.OnPointerEnter(eventData);\n            }\n        }\n\n        public override void OnPointerExit(PointerEventData eventData)\n        {\n            pointerWasUp = false;\n            base.OnPointerExit(eventData);\n        }\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\nCleanButton是一个扩展自Unity标准Button组件的自定义按钮类，主要功能是为按钮交互提供可选的音效反馈。它在系统中扮演UI交互增强的角色，通过在用户点击或悬停按钮时播放预设音效来提升用户体验。该类的主要特性包括：\n\n- **音效反馈**：支持在按钮点击（Pressed）和悬停（Rollover）时播放自定义音效\n- **状态管理**：通过`pointerWasUp`标志优化音效触发逻辑，避免重复播放\n- **继承与扩展**：继承自Unity的Button组件，保留原有功能的同时增加音效功能\n\n### 2. 核心类解析\n\n#### `CleanButton`类\n\n- **职责说明**：该类负责扩展Unity标准Button组件，增加音效播放功能。主要处理用户交互事件（点击、悬停等）并触发相应的音效播放。\n- **关键方法清单**：\n  - `public override void OnPointerClick(PointerEventData eventData)`\n  - `public override void OnPointerUp(PointerEventData eventData)`\n  - `public override void OnPointerEnter(PointerEventData eventData)`\n  - `public override void OnPointerExit(PointerEventData eventData)`\n  - `protected override void Awake()`\n- **继承关系**：\n  ```\n  CleanButton -> Button -> UIBehaviour\n  ```\n- **依赖模块**：\n  - `ButtonSounds`类：用于播放音效\n  - `UnityEngine.EventSystems`命名空间：提供PointerEventData等事件数据类型\n  - `UnityEngine.UI`命名空间：提供Button基类\n\n### 3. 关键方法详解\n\n#### `protected override void Awake()`\n- **方法签名**：`protected override void Awake()`\n- **功能描述**：初始化音效组件，通过`GetComponent<ButtonSounds>()`获取按钮音效实例。\n- **调用关系**：在MonoBehaviour生命周期中自动调用，频率为一次（组件初始化时）\n\n#### `public override void OnPointerClick(PointerEventData eventData)`\n- **方法签名**：`public override void OnPointerClick(PointerEventData eventData)`\n- **功能描述**：当用户点击按钮时触发，检查是否可交互且音效组件存在，若满足条件则播放点击音效。\n- **调用关系**：在用户点击按钮时由Unity事件系统调用，频率取决于用户交互频率\n\n#### `public override void OnPointerUp(PointerEventData eventData)`\n- **方法签名**：`public override void OnPointerUp(PointerEventData eventData)`\n- **功能描述**：当用户释放按钮时触发，设置`pointerWasUp`标志为`true`，表示指针已抬起。\n- **调用关系**：在用户释放按钮时由Unity事件系统调用，频率取决于用户交互频率\n\n#### `public override void OnPointerEnter(PointerEventData eventData)`\n- **方法签名**：`public override void OnPointerEnter(PointerEventData eventData)`\n- **功能描述**：当用户悬停在按钮上时触发。如果`pointerWasUp`为`true`，表示是新悬停事件，则播放悬停音效并重置标志。\n- **调用关系**：在用户悬停在按钮上时由Unity事件系统调用，频率取决于用户交互频率\n\n#### `public override void OnPointerExit(PointerEventData eventData)`\n- **方法签名**：`public override void OnPointerExit(PointerEventData eventData)`\n- **功能描述**：",
    "chunk_order_index": 0,
    "full_doc_id": "doc-6e83e86e91fe9115765651d2176838a2"
  },
  "chunk-1884ae74dbc8ff7055a99e0dcbdbc068": {
    "tokens": 485,
    "content": "`为`true`，表示是新悬停事件，则播放悬停音效并重置标志。\n- **调用关系**：在用户悬停在按钮上时由Unity事件系统调用，频率取决于用户交互频率\n\n#### `public override void OnPointerExit(PointerEventData eventData)`\n- **方法签名**：`public override void OnPointerExit(PointerEventData eventData)`\n- **功能描述**：当用户移出按钮范围时触发，重置`pointerWasUp`标志为`false`。\n- **调用关系**：在用户移出按钮范围时由Unity事件系统调用，频率取决于用户交互频率\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class UIBehaviour {\n        #+System.Void Awake()\n        #+System.Void OnPointerClick(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerUp(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerEnter(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerExit(UnityEngine.EventSystems.PointerEventData)\n    }\n\n    class Button {\n        <UIBehaviour\n        #+System.Void Awake()\n        #+System.Void OnPointerClick(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerUp(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerEnter(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerExit(UnityEngine.EventSystems.PointerEventData)\n    }\n\n    class CleanButton {\n        <Button\n        #+System.Void Awake()\n        #+System.Void OnPointerClick(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerUp(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerEnter(UnityEngine.EventSystems.PointerEventData)\n        #+System.Void OnPointerExit(UnityEngine.EventSystems.PointerEventData)\n        #+UnityEngine.ButtonSounds buttonSounds\n        #+System.Boolean pointerWasUp\n    }\n\n    class ButtonSounds {\n        #+System.Void PlayPressedSound()\n        #+System.Void PlayRolloverSound()\n    }\n\n    CleanButton --> ButtonSounds : dependency\n    CleanButton --> Button : inheritance\n    Button --> UIBehaviour : inheritance\n```",
    "chunk_order_index": 1,
    "full_doc_id": "doc-6e83e86e91fe9115765651d2176838a2"
  },
  "chunk-bf428faf68e52347e87e7ded3d22726a": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing UnityEngine.Networking;\nusing System.Collections;\nusing System.Collections.Generic;\nusing Newtonsoft.Json.Linq;\nusing System;\n\npublic class AiSearch : MonoBehaviour\n{\n    public Button sendButton;\n    public TMP_InputField inputField;\n    public TMP_Text resultText;\n\n    // 引用 ResourceFilterResult，用于访问搜索记录\n    public ResourceFilterResult resourceFilterResult;\n\n    // 定义事件\n    public event Action<List<string>> OnQueryResultReceived;\n\n    void Start()\n    {\n        sendButton.onClick.AddListener(OnSendButtonClick);\n    }\n\n    void OnSendButtonClick()\n    {\n        string query = inputField.text;\n\n        // 添加搜索记录\n        if (resourceFilterResult != null)\n        {\n            resourceFilterResult.AddSearchHistory(query);\n        }\n\n        StartCoroutine(SendQuery(query));\n    }\n\n    IEnumerator SendQuery(string query)\n    {\n        string url = \"http://10.1.14.151:8005/vectory_query\";\n        string jsonData = $\"{{\\\"query\\\": \\\"{query}\\\", \\\"numbers\\\": 500, \\\"return_fields\\\": [\\\"id\\\"]}}\";\n\n        UnityWebRequest request = new UnityWebRequest(url, \"POST\");\n        byte[] bodyRaw = System.Text.Encoding.UTF8.GetBytes(jsonData);\n        request.uploadHandler = new UploadHandlerRaw(bodyRaw);\n        request.downloadHandler = new DownloadHandlerBuffer();\n        request.SetRequestHeader(\"Content-Type\", \"application/json\");\n\n        yield return request.SendWebRequest();\n\n        if (request.result == UnityWebRequest.Result.Success)\n        {\n            string result = request.downloadHandler.text;\n\n            // 解析返回的JSON数据\n            JToken ids = JToken.Parse(result)[\"ids\"];\n            if (ids != null)\n            {\n                List<string> idList = ids.ToObject<List<string>>();\n                resultText.text = string.Join(\",\", idList);\n\n                // 触发事件\n                OnQueryResultReceived?.Invoke(idList);\n            }\n            else\n            {\n                resultText.text = \"No IDs found.\";\n            }\n        }\n        else\n        {\n            resultText.text = \"Error: \" + request.error;\n        }\n    }\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 用简洁的段落总结代码文件的整体功能定位\n该代码文件 `AiSearch.cs` 是一个用于实现AI搜索功能的Unity脚本。它通过用户输入的搜索词向指定的API发送HTTP POST请求，并处理返回的搜索结果。\n\n#### 说明其在系统/项目中的角色和重要性\n该脚本在系统中扮演搜索逻辑的核心角色，是用户与后端API交互的关键组件。它负责：\n- 用户输入的获取\n- HTTP请求的发送\n- 搜索结果的处理与展示\n- 搜索历史记录的维护\n\n#### 列举支持的主要特性与技术实现方案\n- **用户输入处理**：通过Unity UI组件（TMP_InputField）获取搜索词\n- **HTTP请求**：使用UnityWebRequest进行POST请求\n- **JSON处理**：通过 Newtonsoft.Json.Linq 解析返回的JSON数据\n- **事件驱动**：通过自定义事件 OnQueryResultReceived 通知其他组件\n- **搜索历史**：通过 ResourceFilterResult 组件记录搜索历史\n\n### 2. 核心类解析\n\n#### AiSearch\n- **职责说明**：该类负责处理AI搜索的逻辑，包括用户输入获取、HTTP请求发送、结果处理以及与其它组件的交互。\n- **关键方法清单**：\n  - `void Start()`：初始化UI事件监听\n  - `void OnSendButtonClick()`：处理发送按钮点击事件\n  - `IEnumerator SendQuery(string query)`：执行搜索请求并处理响应\n- **继承关系**：\n  ```\n  AiSearch -> MonoBehaviour\n  ```\n- **依赖模块**：\n  - `UnityEngine.UI.Button`\n  - `UnityEngine.UI.InputField`\n  - `UnityEngine.UI.Text`\n  - `ResourceFilterResult`（项目内组件）\n\n### 3. 关键方法详解\n\n#### `void Start()`\n- **方法签名**：`void Start()`\n- **功能描述**：在脚本初始化时注册发送按钮的点击事件监听器。\n- **调用关系**：由Unity引擎在脚本初始化时调用，后续会触发 `OnSendButtonClick` 方法。\n\n#### `void OnSendButtonClick()`\n- **方法签名**：`void OnSendButtonClick()`\n- **功能描述**：处理发送按钮的点击事件，获取输入框的文本内容并执行搜索操作。\n- **调用关系**：由 `Start()` 方法注册的点击事件触发，后续会调用 `SendQuery()` 方法。\n\n#### `IEnumerator SendQuery(string query)`\n- **方法签名**：`IEnumerator SendQuery(string query)`\n- **功能描述**：执行搜索请求，包括：\n  1. 构建请求URL和JSON数据\n  2. 发送POST请求\n  3. 处理服务器返回的结果\n  4. 更新UI显示\n  5. 触发自定义事件 `OnQueryResultReceived`\n- **算法说明**：\n  - 使用协程（Coroutine）处理异步HTTP请求\n  - 使用 `UnityWebRequest` 发送POST请求\n  - 使用 `Newtonsoft.Json.Linq` 解析JSON响应\n- **调用关系**：由 `OnSendButtonClick()` 方法调用，通常在用户点击发送按钮时触发。\n\n### 4. 架构关系图\n\n```mermaid",
    "chunk_order_index": 0,
    "full_doc_id": "doc-795f408b9307b999c412662208853dfc"
  },
  "chunk-68f15b22054646df34866b93c95c481b": {
    "tokens": 208,
    "content": "5. 触发自定义事件 `OnQueryResultReceived`\n- **算法说明**：\n  - 使用协程（Coroutine）处理异步HTTP请求\n  - 使用 `UnityWebRequest` 发送POST请求\n  - 使用 `Newtonsoft.Json.Linq` 解析JSON响应\n- **调用关系**：由 `OnSendButtonClick()` 方法调用，通常在用户点击发送按钮时触发。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n  class AiSearch\n  {\n    +Button sendButton\n    +TMP_InputField inputField\n    +TMP_Text resultText\n    +ResourceFilterResult resourceFilterResult\n    +event OnQueryResultReceived\n    +void Start()\n    +void OnSendButtonClick()\n    +IEnumerator SendQuery(string query)\n  }\n\n  class MonoBehaviour\n  {\n    // 省略 MonoBehaviour 的其他成员\n  }\n\n  AiSearch --> MonoBehaviour\n  AiSearch --> ResourceFilterResult\n```",
    "chunk_order_index": 1,
    "full_doc_id": "doc-795f408b9307b999c412662208853dfc"
  },
  "chunk-51bf07d611bd88ac8a50d08a329a67dd": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n//作用：定义了一个资源卡片的数据结构，用于在UI中展示资源信息，如名称、描述、高度和标签等。\npublic class ResourceCardData\n{\n    public string ID; // 新增ID字段\n    public string Name;\n    public string Description;\n    public string Height;\n    public List<string> TypeTags;\n    public List<string> ThemeTags;\n    public List<string> FunctionTags;\n    public List<string> DefinitionTags;\n    public List<string> BatchTags;\n    public List<string> PropertyTags; // 新增属性标签字段\n    public string PrefabPath;\n    public string ThumbnailPath;\n    public string ModelFaces;\n    public string CreationDate;\n    public string UpdatedDate;\n    public string Version; // 新增版本号字段\n\n    public ResourceCardData(string id, string name, string description, string height, List<string> typeTags, List<string> themeTags, List<string> functionTags, List<string> definitionTags, List<string> batchTags, List<string> propertyTags, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version)\n    {\n        ID = id;\n        Name = name;\n        Description = description;\n        Height = height;\n        TypeTags = typeTags;\n        ThemeTags = themeTags;\n        FunctionTags = functionTags;\n        DefinitionTags = definitionTags;\n        BatchTags = batchTags;\n        PropertyTags = propertyTags;\n        PrefabPath = prefabPath;\n        ThumbnailPath = thumbnailPath;\n        ModelFaces = modelFaces;\n        CreationDate = creationDate;\n        UpdatedDate = updatedDate;\n        Version = version;\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 代码功能定位\nResourceCardData类是一个数据容器，用于封装资源卡片的相关信息，如名称、描述、高度、各种标签以及资源路径等。它在系统中充当数据载体的角色，便于在UI或其他模块中展示和处理资源信息。\n\n#### 系统中的角色与重要性\n该类在资源管理系统中扮演关键角色，作为资源信息的统一数据结构，确保不同模块能够一致地访问和操作资源数据。其重要性体现在提供标准化的数据格式，促进模块间的数据共享和处理。\n\n#### 支持的主要特性与技术实现\n- **数据封装**：将资源信息集中存储，便于管理。\n- **多标签分类**：支持多种类型、主题、功能等标签，便于分类和筛选。\n- **版本控制**：记录资源的创建日期、更新日期和版本号，便于追踪和管理。\n\n### 2. 核心类解析\n\n#### ResourceCardData类\n\n- **职责说明**：该类用于封装资源卡片的详细信息，包括基础属性、各种标签和资源路径等，便于在系统中进行数据传递和处理。\n  \n- **关键方法清单**：\n  - `public ResourceCardData(string id, string name, string description, string height, List<string> typeTags, List<string> themeTags, List<string> functionTags, List<string> definitionTags, List<string> batchTags, List<string> propertyTags, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version)`：构造函数，用于初始化资源卡片的数据字段。\n\n- **继承关系**：\n  ```mermaid\n  classDiagram\n    class ResourceCardData\n    ResourceCardData --> Object\n  ```\n\n- **依赖模块**：\n  - `System.Collections.Generic`：用于处理列表数据。\n  - `UnityEngine`：用于Unity引擎中的功能。\n\n### 3. 关键方法详解\n\n#### 方法签名\n```csharp\npublic ResourceCardData(string id, string name, string description, string height, List<string> typeTags, List<string> themeTags, List<string> functionTags, List<string> definitionTags, List<string> batchTags, List<string> propertyTags, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version)\n```\n\n#### 功能描述\n构造函数用于初始化ResourceCardData类的实例，接收多个参数并将它们赋值给对应的字段。这些字段包括资源的唯一标识符、名称、描述、高度、各种标签列表，以及资源的Prefab路径、缩略图路径、模型面数、创建日期、更新日期和版本号。\n\n#### 算法说明\n构造函数采用简单的赋值操作，将传入的参数直接赋给类的字段，没有复杂的算法逻辑。\n\n#### 调用关系\n该构造函数通常在创建新的ResourceCardData实例时被调用，常见于数据解析、资源加载或初始化阶段。调用频率取决于系统中资源卡片的创建频率。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class ResourceCardData {\n        +string ID\n        +string Name\n        +string Description\n        +string Height\n        +List<string> TypeTags\n        +List<string> ThemeTags\n        +List<string> FunctionTags\n        +List<string> DefinitionTags\n        +List<string> BatchTags\n        +List<string> PropertyTags\n        +string PrefabPath\n        +string ThumbnailPath\n        +string ModelFaces\n        +string CreationDate\n        +string UpdatedDate\n        +string Version\n        +ResourceCardData(string id, string name, string description, string",
    "chunk_order_index": 0,
    "full_doc_id": "doc-bbc282b6c732baaf2659f0f4afa4d169"
  },
  "chunk-c694b8784844a82e87d145e5be77b901": {
    "tokens": 263,
    "content": "+List<string> TypeTags\n        +List<string> ThemeTags\n        +List<string> FunctionTags\n        +List<string> DefinitionTags\n        +List<string> BatchTags\n        +List<string> PropertyTags\n        +string PrefabPath\n        +string ThumbnailPath\n        +string ModelFaces\n        +string CreationDate\n        +string UpdatedDate\n        +string Version\n        +ResourceCardData(string id, string name, string description, string height, List<string> typeTags, List<string> themeTags, List<string> functionTags, List<string> definitionTags, List<string> batchTags, List<string> propertyTags, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version)\n    }\n    ResourceCardData --> Object\n```\n\n#### 说明\n- **继承层次结构**：ResourceCardData直接继承自System.Object。\n- **组合/聚合关系**：该类包含多个字符串和列表字段，用于存储各种资源信息。\n- **重要依赖关系**：依赖于System.Collections.Generic和UnityEngine命名空间，用于处理列表和Unity相关功能。\n- **接口实现情况**：该类未实现任何接口。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-bbc282b6c732baaf2659f0f4afa4d169"
  },
  "chunk-9aaa2c066fcf02128694e89683088ebf": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.IO;\nusing System.Globalization;\nusing System.Linq;\n\n// 负责从CSV文件加载资源数据，并在游戏开始时初始化资源信息。\npublic class ResourceManager : MonoBehaviour\n{\n    private List<ResourceCardData> allResources = new List<ResourceCardData>();\n\n    void Awake()\n    {\n        LoadResourceData();\n    }\n\n    void Start()\n    {\n        PrintAllResources();\n    }\n\n    private void LoadResourceData()\n    {\n        // 使用 Resources.Load 加载 CSV 文件\n        TextAsset csvFile = Resources.Load<TextAsset>(\"ZT_TagLibrary/ResourceIndexLibrary\");\n        if (csvFile == null)\n        {\n            Debug.LogError(\"无法加载CSV文件，请检查文件路径和名称是否正确。\");\n            return;\n        }\n\n        // 读取文件内容并分割为行\n        string[] lines = csvFile.text.Split(new[] { '\\r', '\\n' }, System.StringSplitOptions.RemoveEmptyEntries);\n        bool isFirstLine = true;\n\n        foreach (string line in lines)\n        {\n            if (isFirstLine)\n            {\n                isFirstLine = false;\n                continue;\n            }\n            if (string.IsNullOrWhiteSpace(line)) continue;\n            if (line.StartsWith(\"ID\")) continue;\n\n            string[] fields = line.Split(',');\n            var id = fields[0].Trim('\"');\n            var name = fields[1].Trim('\"');\n            var description = fields[2].Trim('\"');\n            var height = fields[3].Trim('\"');\n            var prefabPath = fields[4].Trim('\"');\n            var thumbnailPath = fields[5].Trim('\"');\n            var modelFaces = fields[6].Trim('\"');\n            var creationDate = fields[7].Trim('\"');\n            var updatedDate = fields[8].Trim('\"');\n            var version = fields[9].Trim('\"');\n            var typeTags = new List<string>(fields[10].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var themeTags = new List<string>(fields[11].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var functionTags = new List<string>(fields[12].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var definitionTags = new List<string>(fields[13].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var batchTags = new List<string>(fields[14].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var propertyTags = new List<string>(fields[15].Trim('\"').Split(';').Select(tag => tag.Trim()));\n\n            ResourceCardData data = new ResourceCardData(id, name, description, height, typeTags, themeTags, functionTags, definitionTags, batchTags, propertyTags, prefabPath, thumbnailPath, modelFaces, creationDate, updatedDate, version);\n            allResources.Add(data);\n        }\n    }\n\n\n    public ResourceCardData GetResourceById(string id)\n    {\n        return allResources.FirstOrDefault(resource => resource.ID == id);\n    }\n\n    public List<ResourceCardData> GetAllResources()\n    {\n        // 确保在 Start 或者其他地方初始化了 allResources\n        return allResources;\n    }\n\n    private void PrintAllResources()\n    {\n        foreach (var resource in allResources)\n        {\n            //Debug.Log($\"Name: {resource.Name}, Description: {resource.Description}, Height: {resource.Height}, \" +\n            //          $\"Type Tags: {string.Join(\", \", resource.TypeTags)}, Theme Tags: {string.Join(\", \", resource.ThemeTags)}, \" +\n            //          $\"Function Tags: {string.Join(\", \", resource.FunctionTags)}, Definition Tags: {string.Join(\", \", resource.DefinitionTags)}, \" +\n            //          $\"Batch Tags: {string.Join(\", \", resource.BatchTags)}, Property Tags: {string.Join(\", \", resource.PropertyTags)}, \" +\n            //          $\"Prefab Path: {resource.PrefabPath}, Thumbnail Path: {resource.ThumbnailPath}, Model Faces: {resource.ModelFaces}, \" +\n            //          $\"Creation Date: {resource.CreationDate}, Updated Date: {resource.UpdatedDate}, Version: {resource.Version}, ID: {resource.ID}\");\n        }\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 功能定位\n`ResourceManager` 类主要用于从 CSV 文件中加载资源数据，并在游戏启动时初始化这些资源信息。它负责解析 CSV 文件内容，将其转化为可管理的资源对象，并提供获取资源数据的方法。\n\n#### 系统角色与重要性\n该类在资源管理系统中扮演核心角色，是资源数据加载和管理的主要入口。它的主要职责是确保资源数据在游戏启动时正确加载，并为其他模块提供资源查询接口。这对于游戏中的资源管理、展示和检索功能至关重要。\n\n#### 主要特性与技术实现\n- **CSV 文件解析**：使用 `Resources.Load<TextAsset>` 加载 CSV 文件，并将其内容解析为结构化的资源对象。\n- **资源对象管理**：将解析后的资源数据存储在 `List<ResourceCardData>` 中，便于后续查询和访问。\n- **资源查询功能**：提供 `GetResourceById` 和 `GetAllResources` 方法，分别用于通过资源 ID 和获取所有资源数据。\n- **调试功能**：通过 `PrintAllResources` 方法输出资源信息，便于开发和调试。\n\n### 2. 核心类解析\n\n#### `ResourceManager` 类\n\n- **职责说明**：负责加载、解析和管理资源数据，提供资源查询接口。\n- **关键方法清单**：\n  - `void Awake()`：初始化方法，用于",
    "chunk_order_index": 0,
    "full_doc_id": "doc-96d4af709a75516264ed01fd1877c80a"
  },
  "chunk-317e2dd47990fef54b18facd8535531f": {
    "tokens": 1092,
    "content": "和 `GetAllResources` 方法，分别用于通过资源 ID 和获取所有资源数据。\n- **调试功能**：通过 `PrintAllResources` 方法输出资源信息，便于开发和调试。\n\n### 2. 核心类解析\n\n#### `ResourceManager` 类\n\n- **职责说明**：负责加载、解析和管理资源数据，提供资源查询接口。\n- **关键方法清单**：\n  - `void Awake()`：初始化方法，用于触发资源数据的加载。\n  - `void Start()`：在 `Awake` 之后调用，用于输出所有资源信息（调试用途）。\n  - `private void LoadResourceData()`：加载并解析 CSV 文件中的资源数据。\n  - `public ResourceCardData GetResourceById(string id)`：通过资源 ID 获取资源对象。\n  - `public List<ResourceCardData> GetAllResources()`：获取所有资源对象列表。\n  - `private void PrintAllResources()`：输出所有资源信息（调试用途）。\n- **继承关系**：\n  ```\n  ResourceManager -> MonoBehaviour\n  ```\n- **依赖模块**：\n  - `UnityEngine`：用于 `MonoBehaviour` 和 `Resources.Load`。\n  - `System.Collections.Generic`：用于 `List<T>`。\n  - `System.IO`：用于文件操作。\n  - `System.Globalization`：用于字符串操作。\n  - `System.Linq`：用于 LINQ 查询。\n  - `ResourceCardData`：资源数据对象类。\n\n### 3. 关键方法详解\n\n#### 方法 1：`void Awake()`\n\n- **方法签名**：`void Awake()`\n- **功能描述**：在 Unity 游戏对象初始化时触发，用于调用 `LoadResourceData` 方法加载资源数据。\n- **算法说明**：直接调用 `LoadResourceData`，无复杂逻辑。\n- **调用关系**：由 Unity 引擎自动调用，频率为游戏启动时一次。\n\n#### 方法 2：`void Start()`\n\n- **方法签名**：`void Start()`\n- **功能描述**：在 `Awake` 之后调用，用于调用 `PrintAllResources` 方法输出所有资源信息。\n- **算法说明**：直接调用 `PrintAllResources`，无复杂逻辑。\n- **调用关系**：由 Unity 引擎自动调用，频率为游戏启动时一次。\n\n#### 方法 3：`private void LoadResourceData()`\n\n- **方法签名**：`private void LoadResourceData()`\n- **功能描述**：加载并解析 CSV 文件中的资源数据，将其转化为 `ResourceCardData` 对象并存储在 `allResources` 列表中。\n- **算法说明**：\n  1. 使用 `Resources.Load<TextAsset>` 加载 CSV 文件。\n  2. 将 CSV 文件内容按行分割。\n  3. 跳过第一行（标题行）。\n  4. 对每一行进行字段分割和解析，生成 `ResourceCardData` 对象。\n  5. 将解析后的对象添加到 `allResources` 列表中。\n- **调用关系**：由 `Awake` 方法调用，频率为游戏启动时一次。\n\n#### 方法 4：`public ResourceCardData GetResourceById(string id)`\n\n- **方法签名**：`public ResourceCardData GetResourceById(string id)`\n- **功能描述**：通过资源 ID 在 `allResources` 列表中查找并返回对应的资源对象。\n- **算法说明**：使用 LINQ 的 `FirstOrDefault` 方法进行查找。\n- **调用关系**：由其他需要查询资源的类或方法调用，频率取决于资源查询需求。\n\n#### 方法 5：`public List<ResourceCardData> GetAllResources()`\n\n- **方法签名**：`public List<ResourceCardData> GetAllResources()`\n- **功能描述**：返回所有资源对象的列表。\n- **算法说明**：直接返回 `allResources` 列表。\n- **调用关系**：由需要获取所有资源数据的类或方法调用，频率取决于资源数据查询需求。\n\n#### 方法 6：`private void PrintAllResources()`\n\n- **方法签名**：`private void PrintAllResources()`\n- **功能描述**：遍历 `allResources` 列表并输出每条资源的详细信息。\n- **算法说明**：使用 `foreach` 循环遍历列表，使用 `Debug.Log` 输出资源信息。\n- **调用关系**：由 `Start` 方法调用，频率为游戏启动时一次。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class ResourceManager {\n        +void Awake()\n        +void Start()\n        +void LoadResourceData()\n        +ResourceCardData GetResourceById(string id)\n        +List<ResourceCardData> GetAllResources()\n        +void PrintAllResources()\n    }\n    class MonoBehaviour {\n        /* MonoBehaviour 的核心方法 */\n    }\n    ResourceManager --> MonoBehaviour\n    ResourceManager --> ResourceCardData\n```",
    "chunk_order_index": 1,
    "full_doc_id": "doc-96d4af709a75516264ed01fd1877c80a"
  },
  "chunk-fb8e6718f8650c02f886fc62cb3cd375": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n﻿using System;\npublic class CardInfo\n{\n    public string ID; // 新增ID字段\n    public string Name;\n    public string Description;\n    public string Height;\n    public string PrefabPath;\n    public string ThumbnailPath;\n    public string ModelFaces; // 新增模型面数字段\n    public string CreationDate; // 新增创建日期字段\n    public string UpdatedDate; // 新增更新日期字段\n    public string Version; // 新增版本号字段\n    public string TypeTags;\n    public string ThemeTags;\n    public string FunctionTags;\n    public string DefinitionTags;\n    public string BatchTags;\n    public string PropertyTags; // 新增属性标签字段\n\n    // 在这里添加构造函数以方便创建实例\n    public CardInfo(\n        string id,\n        string name,\n        string description,\n        string height,\n        string prefabPath,\n        string thumbnailPath,\n        string modelFaces,\n        string creationDate,\n        string updatedDate,\n        string version,\n        string typeTags,\n        string themeTags,\n        string functionTags,\n        string definitionTags,\n        string batchTags,\n        string propertyTags\n    )\n    {\n        ID = id;\n        Name = name;\n        Description = description;\n        Height = height;\n        PrefabPath = prefabPath;\n        ThumbnailPath = thumbnailPath;\n        ModelFaces = modelFaces;\n        CreationDate = creationDate;\n        UpdatedDate = updatedDate;\n        Version = version;\n        TypeTags = typeTags;\n        ThemeTags = themeTags;\n        FunctionTags = functionTags;\n        DefinitionTags = definitionTags;\n        BatchTags = batchTags;\n        PropertyTags = propertyTags;\n    }\n\n    // 重写Equals方法和GetHashCode方法\n    public override bool Equals(object obj)\n    {\n        if (obj == null || GetType() != obj.GetType())\n            return false;\n\n        var other = (CardInfo)obj;\n        return ID == other.ID\n            && Name == other.Name\n            && Description == other.Description\n            && Height == other.Height\n            && Version == other.Version\n            && PrefabPath == other.PrefabPath\n            && ThumbnailPath == other.ThumbnailPath\n            && TypeTags == other.TypeTags\n            && ThemeTags == other.ThemeTags\n            && FunctionTags == other.FunctionTags\n            && DefinitionTags == other.DefinitionTags\n            && BatchTags == other.BatchTags\n            && PropertyTags == other.PropertyTags\n            && ModelFaces == other.ModelFaces\n            && CreationDate == other.CreationDate\n            && UpdatedDate == other.UpdatedDate;\n    }\n\n    public override int GetHashCode()\n    {\n        // 使用所有字段计算哈希码以确保唯一性\n        return HashCode.Combine(ID, Name, Description, Height, Version, PrefabPath, ThumbnailPath, TypeTags);\n    }\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n**功能定位**  \n`CardInfo` 类是一个数据载体类，主要用于存储和管理卡片的详细信息。它包含了卡片的唯一标识符、名称、描述、高度、预制路径、缩略图路径、模型面数、创建和更新日期、版本号以及各种标签信息。\n\n**在系统中的角色和重要性**  \n该类在系统中扮演数据模型的角色，用于表示和管理卡片的元数据。它在数据存储、检索和传输过程中起到核心作用，确保系统能够正确地处理和显示卡片信息。\n\n**主要特性与技术实现方案**  \n- 提供了丰富的字段来存储卡片的详细信息。\n- 使用了构造函数来方便实例化。\n- 重写了 `Equals` 和 `GetHashCode` 方法，以支持对象的相等性比较和哈希码生成。\n\n### 2. 核心类解析\n\n#### `CardInfo` 类\n\n- **职责说明**  \n  `CardInfo` 类的主要职责是存储和管理卡片的元数据。它通过一系列字段提供了卡片的详细信息，并通过构造函数和对象比较方法确保数据的一致性和完整性。\n\n- **关键方法清单**  \n  - `public CardInfo(string id, string name, string description, string height, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version, string typeTags, string themeTags, string functionTags, string definitionTags, string batchTags, string propertyTags)`  \n  - `public override bool Equals(object obj)`  \n  - `public override int GetHashCode()`  \n\n- **继承关系**  \n  ```mermaid\n  classDiagram\n      CardInfo --> Object\n  ```\n\n- **依赖模块**  \n  该项目内没有直接依赖的其他类。\n\n### 3. 关键方法详解\n\n#### `public CardInfo(string id, string name, string description, string height, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version, string typeTags, string themeTags, string functionTags, string definitionTags, string batchTags, string propertyTags)`\n\n- **方法签名**  \n  ```csharp\n  public CardInfo(\n      string id,\n      string name,\n      string description,\n      string height,\n      string prefabPath,\n      string thumbnailPath,\n      string modelFaces,\n      string creationDate,\n      string updatedDate,\n      string version,\n      string typeTags,\n      string themeTags,\n      string functionTags,\n      string definitionTags,\n      string batchTags,\n      string propertyTags\n  )\n  ```\n\n- **功能描述",
    "chunk_order_index": 0,
    "full_doc_id": "doc-bda61297b2012a3db30c513fb7675585"
  },
  "chunk-18e9746c964ce44667c59dbaf0d5b2fb": {
    "tokens": 679,
    "content": "**方法签名**  \n  ```csharp\n  public CardInfo(\n      string id,\n      string name,\n      string description,\n      string height,\n      string prefabPath,\n      string thumbnailPath,\n      string modelFaces,\n      string creationDate,\n      string updatedDate,\n      string version,\n      string typeTags,\n      string themeTags,\n      string functionTags,\n      string definitionTags,\n      string batchTags,\n      string propertyTags\n  )\n  ```\n\n- **功能描述**  \n  该构造函数用于初始化 `CardInfo` 类的实例。它接受所有卡片相关的字段作为参数，并将它们赋值给对应的属性。\n\n- **调用关系**  \n  该方法通常在需要创建 `CardInfo` 实例时被调用，例如在数据加载、创建新卡片或从其他数据源导入卡片信息时。\n\n#### `public override bool Equals(object obj)`\n\n- **方法签名**  \n  ```csharp\n  public override bool Equals(object obj)\n  ```\n\n- **功能描述**  \n  该方法用于比较两个 `CardInfo` 对象是否相等。它通过检查所有字段是否相同来确定两者的相等性。\n\n- **算法说明**  \n  该方法首先检查传入的对象是否为 `null` 或类型不匹配，如果满足则返回 `false`。然后，它将传入对象转换为 `CardInfo` 类型，并逐一比较所有字段是否相同。\n\n- **调用关系**  \n  该方法通常在集合操作（如 `Dictionary` 或 `HashSet`）中被调用，用于检查对象的相等性。\n\n#### `public override int GetHashCode()`\n\n- **方法签名**  \n  ```csharp\n  public override int GetHashCode()\n  ```\n\n- **功能描述**  \n  该方法用于生成 `CardInfo` 对象的哈希码。哈希码用于支持基于哈希的集合操作。\n\n- **算法说明**  \n  该方法使用 `HashCode.Combine` 方法将所有字段的哈希码组合起来，生成一个唯一的整数值。\n\n- **调用关系**  \n  该方法通常在集合操作中被调用，用于生成对象的哈希码。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class CardInfo {\n        +string ID\n        +string Name\n        +string Description\n        +string Height\n        +string PrefabPath\n        +string ThumbnailPath\n        +string ModelFaces\n        +string CreationDate\n        +string UpdatedDate\n        +string Version\n        +string TypeTags\n        +string ThemeTags\n        +string FunctionTags\n        +string DefinitionTags\n        +string BatchTags\n        +string PropertyTags\n        +CardInfo(string id, string name, string description, string height, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version, string typeTags, string themeTags, string functionTags, string definitionTags, string batchTags, string propertyTags)\n        +bool Equals(object obj)\n        +int GetHashCode()\n    }\n    CardInfo --> Object\n```",
    "chunk_order_index": 1,
    "full_doc_id": "doc-bda61297b2012a3db30c513fb7675585"
  },
  "chunk-491ad0a82f30785fffdaaf837b77f4cb": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing TMPro;\n\npublic class ItemDetailsDisplay : MonoBehaviour\n{\n    public TextMeshProUGUI idText; // 新增ID显示\n    public TextMeshProUGUI nameText;\n    public TextMeshProUGUI descriptionText;\n    public TextMeshProUGUI heightText;\n    public TextMeshProUGUI creationDateText;\n    public TextMeshProUGUI modelFacesText;\n    public TextMeshProUGUI updatedDateText;\n    public TextMeshProUGUI versionText; // 新增版本号显示\n    public TextMeshProUGUI propertyTagsText; // 新增属性标签显示\n\n    // 用于显示详情的方法\n    public void DisplayItemDetails(\n        string id, // 新增ID参数\n        string name,\n        string description,\n        string height,\n        string modelFaces,\n        string creationDate,\n        string updatedDate,\n        string version, // 新增版本号参数\n        string propertyTags // 新增属性标签参数\n    )\n    {\n        idText.text = id; // 更新ID文本\n        nameText.text = name;\n        descriptionText.text = description;\n        heightText.text = height; // 假设高度以米为单位\n        modelFacesText.text = modelFaces; // 更新模型面数文本\n        creationDateText.text = creationDate; // 更新创建日期文本\n        updatedDateText.text = updatedDate; // 更新时间文本\n        versionText.text = version; // 更新版本号文本\n        propertyTagsText.text = propertyTags; // 更新属性标签文本\n    }\n\n    // 你可能需要一个方法来清理或隐藏UI，当没有选中任何道具时\n    public void ClearDetails()\n    {\n        idText.text = \"\"; // 清空ID文本\n        nameText.text = \"\";\n        descriptionText.text = \"\";\n        heightText.text = \"\";\n        creationDateText.text = \"\";\n        modelFacesText.text = \"\";\n        updatedDateText.text = \"\";\n        versionText.text = \"\"; // 清空版本号文本\n        propertyTagsText.text = \"\"; // 清空属性标签文本\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n- **功能定位**：`ItemDetailsDisplay` 是一个用于在 Unity 游戏引擎中显示物品详细信息的组件。它通过 UI 元素呈现物品的各种属性，如 ID、名称、描述、高度、创建日期等。\n  \n- **角色与重要性**：在系统中，该组件充当数据展示层，负责将后端或数据源提供的物品信息以用户友好的形式呈现。这对于用户理解物品属性和进行操作至关重要。\n\n- **主要特性与实现方案**：\n  - **数据绑定**：通过公共字段将 UI 文本元素绑定到脚本中。\n  - **方法驱动更新**：使用 `DisplayItemDetails` 方法动态更新显示内容。\n  - **清理功能**：提供 `ClearDetails` 方法以重置 UI 状态。\n  - **技术实现**：基于 Unity 的 `MonoBehaviour`，使用 TextMeshPro 进行文本渲染。\n\n### 2. 核心类解析\n\n#### `ItemDetailsDisplay`\n\n- **职责说明**：该类负责管理物品详细信息的 UI 显示，包括更新和重置文本内容。\n\n- **关键方法清单**：\n  - `public void DisplayItemDetails(string id, string name, string description, string height, string modelFaces, string creationDate, string updatedDate, string version, string propertyTags)`\n  - `public void ClearDetails()`\n\n- **继承关系**：\n  ```\n  ItemDetailsDisplay -> MonoBehaviour\n  ```\n\n- **依赖模块**：\n  - `UnityEngine`：用于 Unity 引擎功能。\n  - `TextMeshPro`：用于文本渲染。\n\n### 3. 关键方法详解\n\n#### `DisplayItemDetails`\n\n- **方法签名**：\n  ```csharp\n  public void DisplayItemDetails(string id, string name, string description, string height, string modelFaces, string creationDate, string updatedDate, string version, string propertyTags)\n  ```\n\n- **功能描述**：该方法接收物品的详细信息参数，并更新对应的 UI 文本元素以显示这些信息。\n\n- **算法说明**：方法直接将参数赋值给公共字段，没有复杂的算法。\n\n- **调用关系**：通常由其他类（如 `ItemManager` 或事件处理类）调用，当物品被选中或更新时。\n\n#### `ClearDetails`\n\n- **方法签名**：\n  ```csharp\n  public void ClearDetails()\n  ```\n\n- **功能描述**：该方法将所有 UI 文本元素的内容清空，通常用于重置显示状态。\n\n- **算法说明**：直接将所有公共字段的 `text` 属性设置为空字符串。\n\n- **调用关系**：在没有选中物品或需要重置显示时被调用。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class ItemDetailsDisplay {\n        +MonoBehaviour\n        +void DisplayItemDetails(string, string, string, string, string, string, string, string, string)\n        +void ClearDetails()\n    }\n    ItemDetailsDisplay --> MonoBehaviour : inherits\n    ItemDetailsDisplay *-- TextMeshProUGUI : uses\n    ItemDetailsDisplay --> MonoBehaviour\n```\n\n### 总结\n\n`ItemDetailsDisplay` 是一个简单但功能全面的 UI 组件，负责在 Unity 中显示和管理物品详细信息。通过其清晰的设计和模块化的功能，它",
    "chunk_order_index": 0,
    "full_doc_id": "doc-0941cdf39333e4b7a145a99a3ff13b49"
  },
  "chunk-c81db1a8977a45d16419fbafb5760465": {
    "tokens": 123,
    "content": "string, string, string, string, string, string, string)\n        +void ClearDetails()\n    }\n    ItemDetailsDisplay --> MonoBehaviour : inherits\n    ItemDetailsDisplay *-- TextMeshProUGUI : uses\n    ItemDetailsDisplay --> MonoBehaviour\n```\n\n### 总结\n\n`ItemDetailsDisplay` 是一个简单但功能全面的 UI 组件，负责在 Unity 中显示和管理物品详细信息。通过其清晰的设计和模块化的功能，它在数据展示层中扮演重要角色，确保用户能够轻松访问和理解物品属性。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-0941cdf39333e4b7a145a99a3ff13b49"
  },
  "chunk-4c753e93f6e48ceb5da52176e2d2ddcb": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\n\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\npublic class ResourceCardUI : MonoBehaviour\n{\n    public TextMeshProUGUI idText;\n    public TextMeshProUGUI nameText;\n    public TextMeshProUGUI descriptionText;\n    public TextMeshProUGUI heightText;\n    public TextMeshProUGUI prefabPathText;\n    public Image thumbnailImage;\n    public TextMeshProUGUI typeTagsText;\n    public TextMeshProUGUI themeTagsText;\n    public TextMeshProUGUI functionTagsText;\n    public TextMeshProUGUI definitionTagsText;\n    public TextMeshProUGUI batchTagsText;\n    public TextMeshProUGUI propertyTagsText;\n    public TextMeshProUGUI modelFacesText;\n    public TextMeshProUGUI creationDateText;\n    public TextMeshProUGUI updatedDateText;\n    public TextMeshProUGUI versionText;\n\n    public SelectedCardSpawner selectedCardSpawner;\n    public ItemDetailsDisplay itemDetailsDisplay;\n\n    public GameObject targetParent;\n    public Button addButton;\n\n    private bool isCardSelected = false;\n    private static ResourceCardUI currentlySelectedCard;\n\n    public void SetupCard(\n        string id,\n        string name,\n        string description,\n        string height,\n        string prefabPath,\n        string thumbnailPath,\n        string modelFaces,\n        string creationDate,\n        string updatedDate,\n        string version,\n        string typeTags,\n        string themeTags,\n        string functionTags,\n        string definitionTags,\n        string batchTags,\n        string propertyTags\n    )\n    {\n        idText.text = id;\n        nameText.text = name;\n        descriptionText.text = description;\n        heightText.text = height;\n        prefabPathText.text = prefabPath;\n\n        string resourcePath = \"ZT_IconTextures/\" + thumbnailPath;\n        Texture2D thumbnail = Resources.Load<Texture2D>(resourcePath);\n\n        if (thumbnail != null)\n        {\n            thumbnailImage.sprite = Sprite.Create(thumbnail, new Rect(0.0f, 0.0f, thumbnail.width, thumbnail.height), new Vector2(0.5f, 0.5f), 100.0f);\n        }\n        else\n        {\n            Debug.LogWarning($\"无法加载缩略图资源：{resourcePath}\");\n        }\n\n        modelFacesText.text = modelFaces;\n        creationDateText.text = creationDate;\n        updatedDateText.text = updatedDate;\n        versionText.text = version;\n        typeTagsText.text = typeTags;\n        themeTagsText.text = themeTags;\n        functionTagsText.text = functionTags;\n        definitionTagsText.text = definitionTags;\n        batchTagsText.text = batchTags;\n        propertyTagsText.text = propertyTags;\n\n        if (addButton != null)\n        {\n            addButton.gameObject.SetActive(false);\n        }\n\n        // 获取当前卡片上的 PropertyInstanceManager 组件\n        var propertyInstanceManager = GetComponentInChildren<PropertyInstanceManager>();\n        if (propertyInstanceManager != null)\n        {\n            // 直接调用 PropertyInstanceManager 的更新方法\n            propertyInstanceManager.AddPropertyText(propertyTagsText);\n            propertyInstanceManager.UpdateInstanceVisibility(); // 手动触发更新\n        }\n    }\n\n    public void OnCardClicked()\n    {\n        itemDetailsDisplay.DisplayItemDetails(\n            idText.text,\n            nameText.text,\n            descriptionText.text,\n            heightText.text,\n            modelFacesText.text,\n            creationDateText.text,\n            updatedDateText.text,\n            versionText.text,\n            propertyTagsText.text\n        );\n\n#if UNITY_EDITOR\n        if (!string.IsNullOrEmpty(prefabPathText.text))\n        {\n            string assetPath = prefabPathText.text;\n            var asset = AssetDatabase.LoadAssetAtPath<GameObject>(assetPath);\n            if (asset != null)\n            {\n                Selection.activeObject = asset;\n                EditorGUIUtility.PingObject(asset);\n            }\n            else\n            {\n                Debug.LogError(\"Cannot find asset at path: \" + assetPath);\n            }\n        }\n#endif\n\n        if (currentlySelectedCard != null && currentlySelectedCard != this)\n        {\n            currentlySelectedCard.DeselectCard();\n        }\n\n        isCardSelected = true;\n        if (addButton != null)\n        {\n            addButton.gameObject.SetActive(true);\n            addButton.onClick.AddListener(OnAddButtonClicked);\n        }\n\n        currentlySelectedCard = this;\n\n        if (targetParent != null)\n        {\n            AddOrReplacePrefab();\n        }\n    }\n\n    private void DeselectCard()\n    {\n        isCardSelected = false;\n        if (addButton != null)\n        {\n            addButton.gameObject.SetActive(false);\n            addButton.onClick.RemoveListener(OnAddButtonClicked);\n        }\n    }\n\n    private void OnAddButtonClicked()\n    {\n        if (isCardSelected)\n        {\n            string thumbnailPath = GetThumbnailPath();\n            selectedCardSpawner.SpawnSelectedCard(\n                idText.text,\n                nameText.text,\n                descriptionText.text,\n                heightText.text,\n                versionText.text,\n                prefabPathText.text,\n                thumbnailPath,\n                typeTagsText.text,\n                themeTagsText.text,\n                functionTagsText.text,\n                definitionTagsText.text,\n                batchTagsText.text,\n                propertyTagsText.text,\n                modelFacesText.text,\n                creationDateText.text,\n                updatedDateText.text\n            );\n\n            isCardSelected = false;\n            if (addButton != null)\n            {\n                addButton.gameObject.SetActive(false);\n                addButton.onClick.RemoveListener(OnAddButtonClicked);\n            }\n        }\n        else\n        {\n            Debug.LogWarning(\"Card is not selected, aborting SpawnSelectedCard.\");\n        }\n    }\n\n    private string GetThumbnailPath()\n    {\n        return thumbnail",
    "chunk_order_index": 0,
    "full_doc_id": "doc-8d6748fff94fae220b8d506ed2e1ad5d"
  },
  "chunk-6258f58337231836a80f5e2801c6eafd": {
    "tokens": 1200,
    "content": ",\n                modelFacesText.text,\n                creationDateText.text,\n                updatedDateText.text\n            );\n\n            isCardSelected = false;\n            if (addButton != null)\n            {\n                addButton.gameObject.SetActive(false);\n                addButton.onClick.RemoveListener(OnAddButtonClicked);\n            }\n        }\n        else\n        {\n            Debug.LogWarning(\"Card is not selected, aborting SpawnSelectedCard.\");\n        }\n    }\n\n    private string GetThumbnailPath()\n    {\n        return thumbnailImage.sprite.texture.name;\n    }\n\n    private void AddOrReplacePrefab()\n    {\n        if (targetParent != null)\n        {\n            foreach (Transform child in targetParent.transform)\n            {\n                Destroy(child.gameObject);\n            }\n\n#if UNITY_EDITOR\n            string resourcePath = prefabPathText.text;\n            GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(resourcePath);\n            if (prefab != null)\n            {\n                GameObject instantiatedPrefab = Instantiate(prefab, targetParent.transform.position, Quaternion.identity, targetParent.transform);\n                instantiatedPrefab.name = nameText.text;\n            }\n            else\n            {\n                Debug.LogError(\"Prefab未找到，请检查路径：\" + resourcePath);\n            }\n#endif\n        }\n    }\n}\n\n源代码内容解释如下：\n```markdown\n# ResourceCardUI 类分析\n\n## 1. 功能概览\n\n### 功能定位\n\nResourceCardUI 类是一个用于展示资源卡片信息的 UI 组件，主要负责显示资源的详细信息，并支持用户与卡片的交互操作。\n\n### 在系统中的角色\n\nResourceCardUI 是资源管理系统中的一个重要 UI 组件，负责将资源信息以卡片的形式呈现给用户，并提供点击选择、添加资源等交互功能。\n\n### 主要特性与技术实现\n\n- **数据展示**：通过多个 TextMeshPro 组件展示资源的各类信息，包括 ID、名称、描述、高度、预制体路径等。\n- **缩略图加载**：从 Resources 文件夹加载资源的缩略图，并将其显示在卡片上。\n- **事件处理**：处理卡片点击事件，展示详细信息，并在 Unity Editor 环境中跳转到对应的预制体资产。\n- **选中状态管理**：维护卡片的选中状态，支持多卡片之间的选中切换。\n- **预制体实例化**：在目标父物体下实例化预制体，并支持替换已有预制体。\n\n## 2. 核心类解析\n\n### ResourceCardUI\n\n#### 职责说明\n\nResourceCardUI 类的主要职责是：\n\n- 初始化并展示资源卡片的详细信息。\n- 处理用户对卡片的点击事件，展示详细信息并执行相关操作。\n- 管理卡片的选中状态。\n- 与其他 UI 组件（如 SelectedCardSpawner 和 ItemDetailsDisplay）交互，完成资源的添加和详细信息的展示。\n\n#### 关键方法清单\n\n- **SetupCard**：初始化卡片的显示内容。\n- **OnCardClicked**：处理卡片点击事件。\n- **DeselectCard**：取消卡片的选中状态。\n- **OnAddButtonClicked**：处理添加按钮点击事件。\n- **GetThumbnailPath**：获取缩略图的路径。\n- **AddOrReplacePrefab**：在目标父物体下实例化或替换预制体。\n\n#### 继承关系\n\n```plaintext\nResourceCardUI -> MonoBehaviour\n```\n\n#### 依赖模块\n\n- **SelectedCardSpawner**：用于生成选中的卡片实例。\n- **ItemDetailsDisplay**：用于展示资源的详细信息。\n- **PropertyInstanceManager**：用于管理属性实例的可见性。\n\n## 3. 关键方法详解\n\n### SetupCard\n\n#### 方法签名\n\n```csharp\npublic void SetupCard(\n    string id,\n    string name,\n    string description,\n    string height,\n    string prefabPath,\n    string thumbnailPath,\n    string modelFaces,\n    string creationDate,\n    string updatedDate,\n    string version,\n    string typeTags,\n    string themeTags,\n    string functionTags,\n    string definitionTags,\n    string batchTags,\n    string propertyTags\n)\n```\n\n#### 功能描述\n\n该方法用于初始化卡片的显示内容，包括资源的 ID、名称、描述、高度、预制体路径、缩略图、模型面数、创建日期、更新日期、版本、类型标签、主题标签、功能标签、定义标签、批次标签和属性标签。\n\n#### 调用关系\n\n该方法通常由资源管理系统的其他部分（如资源加载器或数据提供者）调用，用于展示资源卡片的详细信息。\n\n### OnCardClicked\n\n#### 方法签名\n\n```csharp\npublic void OnCardClicked()\n```\n\n#### 功能描述\n\n该方法处理卡片的点击事件，执行以下操作：\n\n1. 调用 ItemDetailsDisplay 的 DisplayItemDetails 方法，展示资源的详细信息。\n2. 在 Unity Editor 环境中，跳转到对应的预制体资产。\n3. 管理卡片的选中状态，取消其他卡片的选中状态，设置当前卡片为选中状态。\n4. 显示添加按钮，并绑定添加按钮点击事件。\n\n#### 调用关系\n\n该方法在卡片被点击时自动调用。\n\n### DeselectCard\n\n#### 方法签名\n\n```csharp\nprivate void DeselectCard()\n```\n\n#### 功能描述\n\n该方法用于取消卡片的选中状态，执行以下操作：\n\n1. 将 isCardSelected 标记设置为 false。\n2. 隐藏添加按钮，并移除添加按钮的点击事件监听",
    "chunk_order_index": 1,
    "full_doc_id": "doc-8d6748fff94fae220b8d506ed2e1ad5d"
  },
  "chunk-6ff3c9fc83f7f3c2bd174d2b8f9f0340": {
    "tokens": 608,
    "content": "4. 显示添加按钮，并绑定添加按钮点击事件。\n\n#### 调用关系\n\n该方法在卡片被点击时自动调用。\n\n### DeselectCard\n\n#### 方法签名\n\n```csharp\nprivate void DeselectCard()\n```\n\n#### 功能描述\n\n该方法用于取消卡片的选中状态，执行以下操作：\n\n1. 将 isCardSelected 标记设置为 false。\n2. 隐藏添加按钮，并移除添加按钮的点击事件监听器。\n\n#### 调用关系\n\n该方法在 OnCardClicked 方法中调用，用于取消其他卡片的选中状态。\n\n### OnAddButtonClicked\n\n#### 方法签名\n\n```csharp\nprivate void OnAddButtonClicked()\n```\n\n#### 功能描述\n\n该方法处理添加按钮的点击事件，执行以下操作：\n\n1. 检查卡片是否处于选中状态。\n2. 获取缩略图的路径。\n3. 调用 SelectedCardSpawner 的 SpawnSelectedCard 方法，生成选中的卡片实例。\n4. 取消卡片的选中状态，隐藏添加按钮，并移除添加按钮的点击事件监听器。\n\n#### 调用关系\n\n该方法在 OnCardClicked 方法中绑定到添加按钮的点击事件，当添加按钮被点击时调用。\n\n### GetThumbnailPath\n\n#### 方法签名\n\n```csharp\nprivate string GetThumbnailPath()\n```\n\n#### 功能描述\n\n该方法返回当前卡片的缩略图的路径。\n\n#### 调用关系\n\n该方法在 OnAddButtonClicked 方法中调用，用于获取缩略图的路径。\n\n### AddOrReplacePrefab\n\n#### 方法签名\n\n```csharp\nprivate void AddOrReplacePrefab()\n```\n\n#### 功能描述\n\n该方法在目标父物体下实例化或替换预制体，执行以下操作：\n\n1. 遍历目标父物体下的所有子物体，并销毁它们。\n2. 在 Unity Editor 环境中，从指定路径加载预制体，并将其实例化为目标父物体的子物体。\n\n#### 调用关系\n\n该方法在 OnCardClicked 方法中调用，用于在目标父物体下显示或替换预制体。\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class MonoBehaviour\n    class ResourceCardUI <<Extend>> {\n        +SetupCard(string, string, string, string, string, string, string, string, string, string, string, string, string, string, string)\n        +OnCardClicked()\n        +DeselectCard()\n        +OnAddButtonClicked()\n        +GetThumbnailPath() : string\n        +AddOrReplacePrefab()\n    }\n\n    ResourceCardUI --> MonoBehaviour : Inherits from\n    ResourceCardUI --> SelectedCardSpawner : Uses\n    ResourceCardUI --> ItemDetailsDisplay : Uses\n    ResourceCardUI --> PropertyInstanceManager : Uses\n```",
    "chunk_order_index": 2,
    "full_doc_id": "doc-8d6748fff94fae220b8d506ed2e1ad5d"
  },
  "chunk-9ff578f7d2aac044de6ad385e77aec22": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\n\nusing UnityEngine;\nusing System.Collections.Generic;\n\n[System.Serializable]\n\n//作用：定义了资源信息的数据结构，通常附加于游戏内的资源（如预制体）上。它包含了资源名称、描述、缩略图以及各种标签（如类型、主题、功能等）。\npublic class ResourceInfo : MonoBehaviour\n{\n    public string id;//资源ID\n    public string resourceName;//资源名称\n    public string resourceDescription;//资源介绍\n    public string thumbnailPath;//缩略图路径\n    public string modelFaces;//资源面数\n    public string itemHeight; // 物品长宽高                   \n    public Texture2D resourceThumbnail;//缩略图本身\n    public string prefabPath;//prefab路径\n    public string creationDate;//资源创建时间  \n    public string updatedDate;//资源更新时间\n    public string version;//资源版本\n    public List<string> typeTags;//类型标签\n    public List<string> themeTags;//主题标签\n    public List<string> functionTags;//功能标签\n    public List<string> definitionTags;//定义标签\n    public List<string> batchTags;//批次标签\n    public List<string> propertyTags;//属性标签\n    // 可以根据需要添加更多字段\n}\n#endif\n源代码内容解释如下：\n### 功能概览\n\n- **功能定位**：该代码文件定义了一个名为 `ResourceInfo` 的类，用于存储和管理游戏资源（如预制体）的元数据。这些元数据包括资源ID、名称、描述、缩略图路径、标签等信息，便于在游戏中对资源进行分类、搜索和管理。\n\n- **系统角色**：该类在游戏资源管理系统中扮演核心数据结构的角色，是资源元数据的载体。它帮助开发人员快速定位、组织和管理游戏内的各种资源，提升开发效率。\n\n- **主要特性与技术实现**：\n  - **数据结构**：通过字段和列表存储资源的详细信息。\n  - **序列化支持**：使用 `[System.Serializable]` 属性，便于在 Unity 编辑器中进行数据持久化和可视化。\n  - **标签系统**：支持多种类型的标签（如类型、主题、功能等），增强资源的可分类性。\n  - **依赖性**：依赖于 Unity 引擎的 `UnityEngine` 和 `System.Collections.Generic` 命名空间。\n\n---\n\n### 核心类解析\n\n#### `ResourceInfo` 类\n\n- **职责说明**：该类的主要职责是存储和管理游戏资源的元数据。它是一个 MonoBehaviour 组件，通常附加到预制体或其他资源对象上，以提供详细的资源信息。\n\n- **关键方法清单**：\n  - `Awake()`：MonoBehaviour 生命周期方法，用于初始化。\n  - `Start()`：MonoBehaviour 生命周期方法，用于执行启动逻辑。\n  - `OnEnable()`：MonoBehaviour 生命周期方法，用于在脚本启用时执行逻辑。\n  - `OnDisable()`：MonoBehaviour 生命周期方法，用于在脚本禁用时执行逻辑。\n  - `Update()`：MonoBehaviour 生命周期方法，用于每帧更新逻辑。\n\n- **继承关系**：\n  ```\n  ResourceInfo -> MonoBehaviour -> Behaviour -> UnityEngine.Object\n  ```\n\n- **依赖模块**：\n  - `UnityEngine`：用于MonoBehaviour类及其相关功能。\n  - `System.Collections.Generic`：用于List等集合类型。\n\n---\n\n### 关键方法详解\n\n#### `Awake()`\n\n- **方法签名**：`protected virtual void Awake()`\n- **功能描述**：MonoBehaviour 的生命周期方法，在脚本实例被创建时调用。通常用于初始化变量或引用。\n- **算法说明**：无复杂算法，主要作为初始化钩子。\n- **调用关系**：由 Unity 引擎在脚本实例化时自动调用。\n\n#### `Start()`\n\n- **方法签名**：`protected virtual void Start()`\n- **功能描述**：MonoBehaviour 的生命周期方法，在脚本首次执行时调用。通常用于初始化脚本逻辑。\n- **算法说明**：无复杂算法，主要作为启动逻辑钩子。\n- **调用关系**：由 Unity 引擎在脚本启动时自动调用。\n\n#### `OnEnable()`\n\n- **方法签名**：`protected virtual void OnEnable()`\n- **功能描述**：MonoBehaviour 的生命周期方法，在脚本被启用时调用。通常用于重新初始化逻辑。\n- **算法说明**：无复杂算法，主要作为启用逻辑钩子。\n- **调用关系**：由 Unity 引擎在脚本启用时自动调用。\n\n#### `OnDisable()`\n\n- **方法签名**：`protected virtual void OnDisable()`\n- **功能描述**：MonoBehaviour 的生命周期方法，在脚本被禁用时调用。通常用于清理资源。\n- **算法说明**：无复杂算法，主要作为禁用逻辑钩子。\n- **调用关系**：由 Unity 引擎在脚本禁用时自动调用。\n\n#### `Update()`\n\n- **方法签名**：`protected virtual void Update()`\n- **功能描述**：MonoBehaviour 的生命周期方法，在每一帧更新时调用。通常用于处理动态逻辑。\n- **算法说明**：无复杂算法，主要作为每帧逻辑钩子。\n- **调用关系**：由 Unity 引擎在每一帧自动调用。\n\n---\n\n### 架构关系",
    "chunk_order_index": 0,
    "full_doc_id": "doc-8fd9487e992d44ec92da926387e4dcd9"
  },
  "chunk-c9798c883fc72755182ff74d87a199ff": {
    "tokens": 382,
    "content": "脚本禁用时自动调用。\n\n#### `Update()`\n\n- **方法签名**：`protected virtual void Update()`\n- **功能描述**：MonoBehaviour 的生命周期方法，在每一帧更新时调用。通常用于处理动态逻辑。\n- **算法说明**：无复杂算法，主要作为每帧逻辑钩子。\n- **调用关系**：由 Unity 引擎在每一帧自动调用。\n\n---\n\n### 架构关系图\n\n```mermaid\nclassDiagram\n\n  class MonoBehaviour {\n    +void Awake()\n    +void Start()\n    +void OnEnable()\n    +void OnDisable()\n    +void Update()\n  }\n\n  class ResourceInfo {\n    +string id\n    +string resourceName\n    +string resourceDescription\n    +string thumbnailPath\n    +string modelFaces\n    +string itemHeight\n    +Texture2D resourceThumbnail\n    +string prefabPath\n    +string creationDate\n    +string updatedDate\n    +string version\n    +List<string> typeTags\n    +List<string> themeTags\n    +List<string> functionTags\n    +List<string> definitionTags\n    +List<string> batchTags\n    +List<string> propertyTags\n  }\n\n  ResourceInfo --|> MonoBehaviour : Inherits from\n  ResourceInfo *-- List<string> : Contains tags\n  ResourceInfo *-- Texture2D : Contains resource thumbnail\n```\n\n---\n\n### 总结\n\n`ResourceInfo` 类通过存储和管理资源的元数据，在游戏资源管理系统中起到了关键作用。它依赖 Unity 引擎的核心功能，并通过 MonoBehaviour 生命周期方法实现脚本逻辑的初始化和执行。该类的结构设计使其能够灵活地扩展，以适应不同的资源管理需求。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-8fd9487e992d44ec92da926387e4dcd9"
  },
  "chunk-2dc72bb3633aa1c6845853eb4e1060ee": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\n\nusing UnityEditor;\nusing UnityEngine;\nusing System.IO;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class ResourceLibraryUpdater : EditorWindow\n{\n    private List<string> resourcesFolderPaths = new List<string>(); // 资源路径列表\n    private string rilFilePath = \"Assets/ZTResource/Resources/ZT_TagLibrary/ResourceIndexLibrary.csv\"; // RIL的文件路径\n    private Vector2 scrollPosition; // 用于滚动视图\n    private bool isCancelled = false;\n    private static string defaultResourcesFolderPath = \"Assets/ArtResource/Scenes\"; // 默认资源路径\n\n    [MenuItem(\"ZTResource/更新-资源库\", false, 1)]\n    public static void ShowWindow()\n    {\n        GetWindow<ResourceLibraryUpdater>(\"更新资源库\");\n    }\n\n    void OnGUI()\n    {\n        GUILayout.Label(\"RIL文件路径\", EditorStyles.boldLabel);\n        EditorGUILayout.BeginHorizontal();\n        rilFilePath = EditorGUILayout.TextField(rilFilePath);\n        if (GUILayout.Button(\"浏览\", GUILayout.Width(60)))\n        {\n            string path = EditorUtility.SaveFilePanel(\"选择RIL文件\", \"\", \"ResourceIndexLibrary.csv\", \"csv\");\n            if (!string.IsNullOrEmpty(path))\n            {\n                rilFilePath = \"Assets\" + path.Substring(Application.dataPath.Length); // 转换为相对路径\n            }\n        }\n        EditorGUILayout.EndHorizontal();\n        if (GUILayout.Button(\"更新全部\"))\n        {\n            UpdateResourceIndexLibrary(new List<string> { defaultResourcesFolderPath });\n        }\n    }\n\n    public void UpdateResourceIndexLibrary(List<string> folderPaths)\n    {\n        \n        File.WriteAllText(rilFilePath, string.Empty);// 清空 CSV 文件\n\n        Dictionary<string, string> existingEntries = new Dictionary<string, string>();\n        bool isFileExists = File.Exists(rilFilePath);\n\n        if (isFileExists)\n        {\n            string[] existingLines = File.ReadAllLines(rilFilePath);\n            foreach (string line in existingLines)\n            {\n                string[] columns = line.Split(',');\n                if (columns.Length > 0 && columns[0] != \"资源ID\")\n                {\n                    string id = columns[0].Trim('\"');\n                    existingEntries[id] = line;\n                }\n            }\n        }\n\n        StringBuilder csvContentBuilder = new StringBuilder();\n        csvContentBuilder.AppendLine(\"资源ID,资源名称,资源描述,长宽高,预制体路径,缩略图路径,面数,创建时间,更新时间,版本,类型标签,主题标签,功能标签,区域标签,批次标签,属性标签\");\n\n        int totalCount = 0;\n        foreach (var path in folderPaths)\n        {\n            totalCount += Directory.GetFiles(path, \"*.prefab\", SearchOption.AllDirectories).Length;\n        }\n\n        int currentIndex = 0;\n        isCancelled = false;\n\n        foreach (var folderPath in folderPaths)\n        {\n            var prefabPaths = Directory.GetFiles(folderPath, \"*.prefab\", SearchOption.AllDirectories);\n\n            foreach (string prefabPath in prefabPaths)\n            {\n                if (isCancelled)\n                {\n                    EditorUtility.ClearProgressBar();\n                    Debug.LogWarning(\"更新已被用户取消。\");\n                    return;\n                }\n\n                GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(prefabPath);\n                if (prefab != null)\n                {\n                    ResourceInfo info = prefab.GetComponent<ResourceInfo>();\n                    if (info != null)\n                    {\n                        string csvRow = ConvertResourceInfoToCsvRow(info, prefabPath);\n\n                        if (existingEntries.ContainsKey(info.id))\n                        {\n                            existingEntries[info.id] = csvRow;\n                        }\n                        else\n                        {\n                            existingEntries.Add(info.id, csvRow);\n                        }\n                    }\n                }\n\n                if (EditorUtility.DisplayCancelableProgressBar(\"资源库更新\", $\"正在更新：{prefab?.name}\", (float)currentIndex / totalCount))\n                {\n                    isCancelled = true;\n                }\n\n                currentIndex++;\n            }\n        }\n\n        EditorUtility.ClearProgressBar();\n\n        if (!isCancelled)\n        {\n            try\n            {\n                foreach (var entry in existingEntries)\n                {\n                    csvContentBuilder.AppendLine(entry.Value);\n                }\n\n                File.WriteAllText(rilFilePath, csvContentBuilder.ToString(), Encoding.UTF8);\n                AssetDatabase.Refresh();\n                EditorUtility.DisplayDialog(\"资源库更新\", \"RIL更新已完成。\", \"确定\");\n            }\n            catch (IOException ex)\n            {\n                if (IsFileLocked(ex))\n                {\n                    EditorUtility.DisplayDialog(\"错误\", \"无法更新资源库，文件可能为只读或已被打开，请关闭文件后重试。\", \"确定\");\n                }\n                else\n                {\n                    throw;\n                }\n            }\n        }\n    }\n\n\n    private static string ConvertResourceInfoToCsvRow(ResourceInfo info, string assetPath)\n    {\n        string thumbnailPath = info.thumbnailPath != null ? info.thumbnailPath : \"\";\n        string modelFaces = info.modelFaces;\n        string creationDate = info.creationDate;\n        string updatedDate = info.updatedDate;\n        string version = info.version;\n\n        return string.Format(\n            \"\\\"{0}\\\",\\\"{1}\\\",\\\"{2}\\\",\\\"{3:F1}\\\",\\\"{4}\\\",\\\"{5}\\\",\\\"{6}\\\",\\\"{7}\\\",\\\"{8}\\\",\\\"{9}\\\",\\\"{10}\\\",\\\"{11}\\\",\\\"{12}\\\",\\\"{13}\\\",\\\"{14}\\\",\\\"{15}\\\"\",\n            info.id,\n            info.resourceName,\n            info.resourceDescription,\n            info.itemHeight,\n            assetPath,\n            thumbnailPath,  // 使用保存的缩略图路径",
    "chunk_order_index": 0,
    "full_doc_id": "doc-2961c1906a9bfd5ff5fe009977905205"
  },
  "chunk-92b6514e01ad38aa161166bef4298a53": {
    "tokens": 1200,
    "content": "1}\\\",\\\"{4}\\\",\\\"{5}\\\",\\\"{6}\\\",\\\"{7}\\\",\\\"{8}\\\",\\\"{9}\\\",\\\"{10}\\\",\\\"{11}\\\",\\\"{12}\\\",\\\"{13}\\\",\\\"{14}\\\",\\\"{15}\\\"\",\n            info.id,\n            info.resourceName,\n            info.resourceDescription,\n            info.itemHeight,\n            assetPath,\n            thumbnailPath,  // 使用保存的缩略图路径\n            modelFaces,\n            creationDate,\n            updatedDate,\n            version,\n            string.Join(\";\", info.typeTags),\n            string.Join(\";\", info.themeTags),\n            string.Join(\";\", info.functionTags),\n            string.Join(\";\", info.definitionTags),\n            string.Join(\";\", info.batchTags),\n            string.Join(\";\", info.propertyTags)\n        );\n    }\n\n\n    private static bool IsFileLocked(IOException exception)\n    {\n        int errorCode = System.Runtime.InteropServices.Marshal.GetHRForException(exception) & ((1 << 16) - 1);\n        return errorCode == 32 || errorCode == 33;\n    }\n}\n\n#endif\n源代码内容解释如下：\n### 1. 功能概览\n\n**功能定位：**  \n该代码文件是一个Unity编辑器扩展脚本，用于更新和管理资源库（Resource Index Library，简称RIL）。其主要功能是扫描指定文件夹中的Prefab资源，提取资源信息，并将其写入CSV文件中。\n\n**系统角色与重要性：**  \n该脚本在Unity项目中扮演资源管理工具的角色，帮助开发人员自动化资源索引库的更新过程。这对于维护资源元数据、提高资源管理效率具有重要意义。\n\n**主要特性与技术实现：**  \n- **资源扫描与处理：** 使用Unity的AssetDatabase和Directory类扫描Prefab文件，并提取资源信息。  \n- **CSV文件生成：** 将资源信息格式化为CSV文件，便于其他系统或工具进行数据处理。  \n- **用户界面：** 提供了一个简单的编辑器窗口，允许用户指定RIL文件路径并启动更新过程。  \n- **进度显示与取消：** 在更新过程中显示进度条，并允许用户取消操作。  \n- **错误处理：** 包括文件锁定检测和异常处理。\n\n---\n\n### 2. 核心类解析\n\n**类名称：ResourceLibraryUpdater**\n\n**职责说明：**  \n该类的主要职责是维护和更新资源索引库（RIL）。它通过扫描指定文件夹中的Prefab资源，提取资源元数据，并将其写入CSV文件中。该类还提供了用户界面，允许用户指定RIL文件路径和启动更新过程。\n\n**关键方法清单：**  \n- `public static void ShowWindow()`：显示编辑器窗口。  \n- `void OnGUI()`：绘制编辑器窗口的用户界面。  \n- `public void UpdateResourceIndexLibrary(List<string> folderPaths)`：扫描指定文件夹并生成RIL文件。  \n- `private static string ConvertResourceInfoToCsvRow(ResourceInfo info, string assetPath)`：将资源信息转换为CSV格式的行。  \n- `private static bool IsFileLocked(IOException exception)`：检查文件是否被锁定。\n\n**继承关系：**  \n```mermaid\nclassDiagram\n    ResourceLibraryUpdater --> EditorWindow\n    EditorWindow --> Object\n```\n\n**依赖模块：**  \n- UnityEngine  \n- UnityEditor  \n- System.IO  \n- System.Text  \n- System.Collections.Generic  \n\n---\n\n### 3. 关键方法详解\n\n#### 方法：`public static void ShowWindow()`\n\n**方法签名：**  \n```csharp\n[MenuItem(\"ZTResource/更新-资源库\", false, 1)]\npublic static void ShowWindow()\n```\n\n**功能描述：**  \n该方法通过Unity的MenuItem属性注册为一个编辑器菜单项，允许用户通过菜单栏启动资源库更新工具。调用`GetWindow<ResourceLibraryUpdater>`方法显示编辑器窗口。\n\n**调用关系：**  \n- 由Unity编辑器菜单调用，频率为用户点击时。\n\n---\n\n#### 方法：`void OnGUI()`\n\n**方法签名：**  \n```csharp\nvoid OnGUI()\n```\n\n**功能描述：**  \n该方法负责绘制编辑器窗口的用户界面。它包括以下功能：  \n1. 显示RIL文件路径输入框和浏览按钮。  \n2. 提供“更新全部”按钮，点击后调用`UpdateResourceIndexLibrary`方法。  \n\n**调用关系：**  \n- 由Unity编辑器框架自动调用，频率为每帧一次。\n\n---\n\n#### 方法：`public void UpdateResourceIndexLibrary(List<string> folderPaths)`\n\n**方法签名：**  \n```csharp\npublic void UpdateResourceIndexLibrary(List<string> folderPaths)\n```\n\n**功能描述：**  \n该方法的主要作用是扫描指定文件夹中的Prefab资源，并将其信息写入RIL文件（CSV格式）。具体步骤如下：  \n1. 清空CSV文件内容。  \n2. 读取现有CSV文件内容并存储到字典中。  \n3. 扫描指定文件夹中的所有Prefab文件。  \n4. 对每个Prefab文件提取资源信息（通过`ResourceInfo`组件获取）。  \n5. 将资源信息转换为CSV格式并更新字典。  \n6. 将字典中的内容写入CSV文件。  \n\n**算法说明：**  \n- 使用字典存储资源ID与CSV行的映射，以确保资源ID的唯一性。  \n- 使用`Directory.GetFiles`递",
    "chunk_order_index": 1,
    "full_doc_id": "doc-2961c1906a9bfd5ff5fe009977905205"
  },
  "chunk-2a062c217c990a7224297d09722e268d": {
    "tokens": 664,
    "content": "3. 扫描指定文件夹中的所有Prefab文件。  \n4. 对每个Prefab文件提取资源信息（通过`ResourceInfo`组件获取）。  \n5. 将资源信息转换为CSV格式并更新字典。  \n6. 将字典中的内容写入CSV文件。  \n\n**算法说明：**  \n- 使用字典存储资源ID与CSV行的映射，以确保资源ID的唯一性。  \n- 使用`Directory.GetFiles`递归扫描文件夹中的Prefab文件。  \n- 使用`EditorUtility.DisplayCancelableProgressBar`显示进度条，并允许用户取消操作。\n\n**调用关系：**  \n- 由`OnGUI`方法中的“更新全部”按钮点击事件调用，频率为用户点击时。\n\n---\n\n#### 方法：`private static string ConvertResourceInfoToCsvRow(ResourceInfo info, string assetPath)`\n\n**方法签名：**  \n```csharp\nprivate static string ConvertResourceInfoToCsvRow(ResourceInfo info, string assetPath)\n```\n\n**功能描述：**  \n该方法将`ResourceInfo`组件中的资源信息转换为CSV格式的行。CSV行包含以下字段：  \n- 资源ID  \n- 资源名称  \n- 资源描述  \n- 长宽高  \n- 预制体路径  \n- 缩略图路径  \n- 面数  \n- 创建时间  \n- 更新时间  \n- 版本  \n- 类型标签、主题标签、功能标签、区域标签、批次标签、属性标签  \n\n**算法说明：**  \n- 使用`string.Format`将资源信息格式化为CSV行。  \n- 标签字段使用分号`;`分隔。\n\n**调用关系：**  \n- 由`UpdateResourceIndexLibrary`方法调用，频率为每个Prefab文件处理一次。\n\n---\n\n#### 方法：`private static bool IsFileLocked(IOException exception)`\n\n**方法签名：**  \n```csharp\nprivate static bool IsFileLocked(IOException exception)\n```\n\n**功能描述：**  \n该方法用于检测文件是否被锁定（例如被其他程序占用）。通过检查异常的错误码来判断文件是否被锁定。\n\n**算法说明：**  \n- 使用`Marshal.GetHRForException`获取异常的HRESULT错误码。  \n- 错误码32表示文件被其他进程占用，错误码33表示文件正在被另一个进程写入。\n\n**调用关系：**  \n- 由`UpdateResourceIndexLibrary`方法在文件写入失败时调用，频率为文件写入失败时。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class ResourceLibraryUpdater {\n        +void OnGUI()\n        +void UpdateResourceIndexLibrary(List<string> folderPaths)\n        +string ConvertResourceInfoToCsvRow(ResourceInfo info, string assetPath)\n        +bool IsFileLocked(IOException exception)\n        +static void ShowWindow()\n        +List<string> resourcesFolderPaths\n        +string rilFilePath\n        +Vector2 scrollPosition\n        +bool isCancelled\n        +static string defaultResourcesFolderPath\n    }\n    ResourceLibraryUpdater --> EditorWindow\n    EditorWindow --> Object\n```",
    "chunk_order_index": 2,
    "full_doc_id": "doc-2961c1906a9bfd5ff5fe009977905205"
  },
  "chunk-fbeee8a62c3f9c182e7f2f8e02a00d48": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEngine;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System;\n\npublic class ResourceEntryWindow : EditorWindow\n{\n    private GameObject prefabToUpload;\n    private string resourceName;\n    private string resourceDescription;\n    private Texture2D resourceThumbnail;\n    private List<string> selectedTypeTags = new List<string>();\n    private List<string> selectedThemeTags = new List<string>();\n    private List<string> selectedFunctionTags = new List<string>();\n    private List<string> selectedDefinitionTags = new List<string>();\n    private List<string> selectedBatchTags = new List<string>();\n    private List<string> selectedPropertyTags = new List<string>();\n\n    private string searchFilter = \"\";\n    private int itemsPerPage = 40;\n    private Dictionary<string, List<string>> tagSearchResults = new Dictionary<string, List<string>>();\n\n    private readonly string csvFilePath = \"Assets/ZTResource/Resources/ZT_TagLibrary/ResourceIndexLibrary.csv\";\n\n    private TagLibrary typeTagLibrary, themeTagLibrary, functionTagLibrary, definitionTagLibrary, batchTagLibrary, propertyTagLibrary;\n\n    private Dictionary<string, int> currentPages = new Dictionary<string, int>();\n\n    [MenuItem(\"ZTResource/录入-资源\",false, 0)]\n    public static void ShowWindow()\n    {\n        GetWindow<ResourceEntryWindow>(\"资源录入\");\n    }\n\n    private void Awake()\n    {\n        typeTagLibrary = LoadTagLibrary(\"TypeTagLibrary\");\n        themeTagLibrary = LoadTagLibrary(\"ThemeTagLibrary\");\n        functionTagLibrary = LoadTagLibrary(\"FunctionTagLibrary\");\n        definitionTagLibrary = LoadTagLibrary(\"DefinitionTagLibrary\");\n        batchTagLibrary = LoadTagLibrary(\"BatchTagLibrary\");\n        propertyTagLibrary = LoadTagLibrary(\"PropertyTagLibrary\");\n\n        string[] tagTypes = new string[] { \"Type\", \"Theme\", \"Function\", \"Definition\", \"Batch\", \"Property\" };\n        foreach (string tagType in tagTypes)\n        {\n            currentPages[tagType] = 0;\n            FilterTagsForLibrary(LoadTagLibrary(tagType + \"TagLibrary\"), \"\", tagType);\n        }\n    }\n\n    private void FilterTags(string filter)\n    {\n        FilterTagsForLibrary(typeTagLibrary, filter, \"Type\");\n        FilterTagsForLibrary(themeTagLibrary, filter, \"Theme\");\n        FilterTagsForLibrary(functionTagLibrary, filter, \"Function\");\n        FilterTagsForLibrary(definitionTagLibrary, filter, \"Definition\");\n        FilterTagsForLibrary(batchTagLibrary, filter, \"Batch\");\n        FilterTagsForLibrary(propertyTagLibrary, filter, \"Property\");\n    }\n\n    private void FilterTagsForLibrary(TagLibrary library, string filter, string tagType)\n    {\n        if (library == null) return;\n        if (string.IsNullOrEmpty(filter))\n        {\n            tagSearchResults[tagType] = new List<string>(library.tags);\n        }\n        else\n        {\n            tagSearchResults[tagType] = library.tags.Where(tag => tag.ToLowerInvariant().Contains(filter.ToLowerInvariant())).ToList();\n        }\n    }\n\n    private void DisplayTagSelectionWithPaging(string label, TagLibrary library, ref List<string> selectedTags, string tagType)\n    {\n        EditorGUILayout.LabelField(label);\n\n        if (!currentPages.ContainsKey(tagType))\n        {\n            currentPages[tagType] = 0;\n        }\n\n        if (!tagSearchResults.ContainsKey(tagType) || tagSearchResults[tagType] == null)\n        {\n            FilterTagsForLibrary(library, \"\", tagType);\n        }\n\n        var tagsToShow = tagSearchResults[tagType];\n        int totalTags = tagsToShow.Count;\n        int totalPages = Mathf.Max(1, Mathf.CeilToInt((float)totalTags / itemsPerPage));\n\n        int currentPage = currentPages[tagType];\n\n        int columns = 4;\n        int startIdx = currentPage * itemsPerPage;\n        int endIdx = Mathf.Min(startIdx + itemsPerPage, totalTags);\n\n        for (int i = startIdx; i < endIdx; i++)\n        {\n            if ((i - startIdx) % columns == 0)\n            {\n                EditorGUILayout.BeginHorizontal();\n            }\n\n            string tag = tagsToShow[i];\n            bool isSelected = selectedTags.Contains(tag);\n            bool selection = GUILayout.Toggle(isSelected, tag, \"Button\", GUILayout.Width(EditorGUIUtility.currentViewWidth / columns - 6));\n\n            if (selection != isSelected)\n            {\n                if (selection)\n                {\n                    selectedTags.Add(tag);\n                }\n                else\n                {\n                    selectedTags.Remove(tag);\n                }\n            }\n\n            if ((i - startIdx + 1) % columns == 0 || i == endIdx - 1)\n            {\n                EditorGUILayout.EndHorizontal();\n            }\n        }\n\n        if (totalPages > 1)\n        {\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"上一页\") && currentPage > 0)\n            {\n                currentPages[tagType] = currentPage - 1;\n            }\n            if (GUILayout.Button(\"下一页\") && currentPage < totalPages - 1)\n            {\n                currentPages[tagType] = currentPage + 1;\n            }\n            EditorGUILayout.EndHorizontal();\n\n            EditorGUILayout.LabelField($\"页码: {currentPage + 1} / {totalPages}\", EditorStyles.centeredGreyMiniLabel);\n        }\n    }\n\n    private Vector2 scrollPosition;\n\n    private void OnGUI()\n    {\n        float windowHeight = this.position.height;\n        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Width(this.position.width - 5), GUILayout.Height(windowHeight - 25));\n\n        prefabToUpload = (GameObject)EditorGUILayout.ObjectField(\"预制体\", prefabToUpload",
    "chunk_order_index": 0,
    "full_doc_id": "doc-6cef0af551f7ce7372c3e80b9859f4c0"
  },
  "chunk-5aae27f351203427330bfe706dbaa30e": {
    "tokens": 1200,
    "content": "码: {currentPage + 1} / {totalPages}\", EditorStyles.centeredGreyMiniLabel);\n        }\n    }\n\n    private Vector2 scrollPosition;\n\n    private void OnGUI()\n    {\n        float windowHeight = this.position.height;\n        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Width(this.position.width - 5), GUILayout.Height(windowHeight - 25));\n\n        prefabToUpload = (GameObject)EditorGUILayout.ObjectField(\"预制体\", prefabToUpload, typeof(GameObject), false);\n        if (prefabToUpload != null)\n        {\n            string assetPath = AssetDatabase.GetAssetPath(prefabToUpload);\n            if (assetPath.StartsWith(\"Assets\") && assetPath.EndsWith(\".prefab\"))\n            {\n                // 去除公共部分路径\n                string basePath = \"Assets/ArtResource/Scenes/Standard/\";\n                if (assetPath.StartsWith(basePath))\n                {\n                    assetPath = assetPath.Substring(basePath.Length);\n                }\n\n                // 删除路径中的“/”符号\n                string modifiedPrefabPath = assetPath.Replace(\"/\", \"\");\n\n                // 去除 .prefab 后缀\n                string prefabName = Path.GetFileNameWithoutExtension(modifiedPrefabPath);\n\n                // 获取缩略图名称\n                string thumbnailName = prefabName + \".png\";\n\n                // 加载缩略图\n                resourceThumbnail = AssetDatabase.LoadAssetAtPath<Texture2D>(\"Assets/ZTResource/Resources/ZT_IconTextures/\" + thumbnailName);\n                if (resourceThumbnail == null)\n                {\n                    EditorGUILayout.HelpBox(\"未找到对应的缩略图文件！\", MessageType.Warning);\n                }\n                else\n                {\n                    EditorGUILayout.LabelField(\"已加载缩略图: \" + thumbnailName);\n                    EditorGUILayout.ObjectField(\"资源缩略图\", resourceThumbnail, typeof(Texture2D), false);\n                }\n            }\n            else\n            {\n                EditorGUILayout.HelpBox(\"这不是一个有效的预制体文件！\", MessageType.Warning);\n                prefabToUpload = null;\n            }\n        }\n\n        resourceName = EditorGUILayout.TextField(\"资源名称\", resourceName);\n        resourceDescription = EditorGUILayout.TextField(\"资源描述\", resourceDescription);\n\n        searchFilter = EditorGUILayout.TextField(\"搜索标签\", searchFilter);\n        if (EditorGUI.EndChangeCheck())\n        {\n            FilterTags(searchFilter);\n        }\n\n        DisplayTagSelectionWithPaging(\"类型标签\", typeTagLibrary, ref selectedTypeTags, \"Type\");\n        DisplayTagSelectionWithPaging(\"主题标签\", themeTagLibrary, ref selectedThemeTags, \"Theme\");\n        DisplayTagSelectionWithPaging(\"区域标签\", definitionTagLibrary, ref selectedDefinitionTags, \"Definition\");\n        DisplayTagSelectionWithPaging(\"功能标签\", functionTagLibrary, ref selectedFunctionTags, \"Function\");\n        DisplayTagSelectionWithPaging(\"批次标签\", batchTagLibrary, ref selectedBatchTags, \"Batch\");\n        DisplayTagSelectionWithPaging(\"属性标签\", propertyTagLibrary, ref selectedPropertyTags, \"Property\");\n\n        EditorGUILayout.EndScrollView();\n\n        if (GUILayout.Button(\"保存资源\"))\n        {\n            SaveResource();\n        }\n    }\n\n\n    private TagLibrary LoadTagLibrary(string name)\n    {\n        return AssetDatabase.LoadAssetAtPath<TagLibrary>($\"Assets/ZTResource/Resources/ZT_TagLibrary/{name}.asset\");\n    }\n\n    public class ResourceData\n    {\n        public string ID;\n        public string Name;\n        public string Description;\n        public string Height;\n        public string PrefabPath;\n        public string ThumbnailPath;\n        public string ModelFaces;\n        public string CreationDate;\n        public string UpdatedDate;\n        public string Version;\n        public string TypeTags;\n        public string ThemeTags;\n        public string FunctionTags;\n        public string DefinitionTags;\n        public string BatchTags;\n        public string PropertyTags;\n\n        public override string ToString()\n        {\n            List<string> entries = new List<string>\n            {\n                $\"\\\"{ID}\\\"\",\n                $\"\\\"{Name}\\\"\",\n                $\"\\\"{Description}\\\"\",\n                $\"\\\"{Height}\\\"\",                \n                $\"\\\"{PrefabPath}\\\"\",\n                $\"\\\"{ThumbnailPath}\\\"\",\n                $\"\\\"{ModelFaces}\\\"\",\n                $\"\\\"{CreationDate}\\\"\",\n                $\"\\\"{UpdatedDate}\\\"\",\n                $\"\\\"{Version}\\\"\",\n                $\"\\\"{TypeTags}\\\"\",\n                $\"\\\"{ThemeTags}\\\"\",\n                $\"\\\"{FunctionTags}\\\"\",\n                $\"\\\"{DefinitionTags}\\\"\",\n                $\"\\\"{BatchTags}\\\"\",\n                $\"\\\"{PropertyTags}\\\"\"\n            };\n            return string.Join(\",\", entries);\n        }\n    }\n\n    private string CalculatePrefabDimensions(GameObject prefab)\n    {\n        if (prefab == null) return \"0|0|0\";\n\n        var renderers = prefab.GetComponentsInChildren<Renderer>();\n        if (renderers.Length == 0) return \"0|0|0\";\n\n        var bounds = renderers[0].bounds;\n        foreach (var renderer in renderers)\n        {\n            bounds.Encapsulate(renderer.bounds);\n        }\n\n        float length = (float)Math.Round(bounds.size.x, 1);\n        float width = (float)Math.Round(bounds.size.z, 1);\n        float height = (float)Math.Round(bounds.size.y, 1);\n\n        return $\"{length}|{width}|{height}\";\n    }\n\n\n\n    private string CalculateModelFaces(GameObject prefab)\n    {\n        int totalFaces = 0;\n        MeshFilter[] meshFilters = prefab.GetComponentsInChildren<MeshFilter>();\n        foreach (MeshFilter meshFilter in meshFilters)\n        {\n            if (meshFilter.sharedMesh != null)\n            {\n                totalFaces += meshFilter.sharedMesh.triangles.Length / 3;\n            }\n        }\n        return totalFaces.ToString();\n    }\n\n    private void SaveResource()\n    {\n        if (prefab",
    "chunk_order_index": 1,
    "full_doc_id": "doc-6cef0af551f7ce7372c3e80b9859f4c0"
  },
  "chunk-69f3020d68b6043dbb88c060c16701c5": {
    "tokens": 1200,
    "content": "string CalculateModelFaces(GameObject prefab)\n    {\n        int totalFaces = 0;\n        MeshFilter[] meshFilters = prefab.GetComponentsInChildren<MeshFilter>();\n        foreach (MeshFilter meshFilter in meshFilters)\n        {\n            if (meshFilter.sharedMesh != null)\n            {\n                totalFaces += meshFilter.sharedMesh.triangles.Length / 3;\n            }\n        }\n        return totalFaces.ToString();\n    }\n\n    private void SaveResource()\n    {\n        if (prefabToUpload == null)\n        {\n            EditorUtility.DisplayDialog(\"错误\", \"请添加一个预制体。\", \"确定\");\n            return;\n        }\n\n        string dimensions = CalculatePrefabDimensions(prefabToUpload);\n\n        // 更新 UI\n        Repaint();\n\n        string thumbnailName = resourceThumbnail != null ? resourceThumbnail.name : \"\";\n\n        if (string.IsNullOrEmpty(resourceName) || string.IsNullOrEmpty(resourceDescription))\n        {\n            EditorUtility.DisplayDialog(\"错误\", \"资源名称和描述不能为空。\", \"确定\");\n            return;\n        }\n\n        // 检查预制体上是否已有 ResourceInfo 组件\n        ResourceInfo info = prefabToUpload.GetComponent<ResourceInfo>();\n        if (info == null)\n        {\n            info = prefabToUpload.AddComponent<ResourceInfo>();\n        }\n\n        // 使用路径生成ID，替换原有的GUID生成方式\n        string prefabPath = AssetDatabase.GetAssetPath(prefabToUpload);\n        string basePath = \"Assets/ArtResource/Scenes/Standard/\";\n\n        if (prefabPath.StartsWith(basePath))\n        {\n            prefabPath = prefabPath.Substring(basePath.Length);\n        }\n        string resourceId = System.IO.Path.ChangeExtension(prefabPath, null); // 去掉文件后缀作为ID\n\n        ResourceData data = new ResourceData\n        {\n            ID = resourceId,\n            Name = resourceName,\n            Description = resourceDescription,\n            Height = dimensions,\n            PrefabPath = AssetDatabase.GetAssetPath(prefabToUpload),\n            ThumbnailPath = thumbnailName,\n            ModelFaces = CalculateModelFaces(prefabToUpload),\n            CreationDate = DateTime.Now.ToString(\"yyyy/MM/dd\"),\n            UpdatedDate = DateTime.Now.ToString(\"yyyy/MM/dd\"),\n            Version = \"0\",\n            TypeTags = string.Join(\";\", selectedTypeTags),\n            ThemeTags = string.Join(\";\", selectedThemeTags),\n            FunctionTags = string.Join(\";\", selectedFunctionTags),\n            DefinitionTags = string.Join(\";\", selectedDefinitionTags),\n            BatchTags = string.Join(\";\", selectedBatchTags),\n            PropertyTags = string.Join(\";\", selectedPropertyTags)\n        };\n\n        info.id = data.ID;\n        info.resourceName = resourceName;\n        info.resourceDescription = resourceDescription;\n        info.resourceThumbnail = resourceThumbnail;\n        info.prefabPath = data.PrefabPath;\n        info.thumbnailPath = thumbnailName;\n        info.modelFaces = data.ModelFaces;\n        info.creationDate = data.CreationDate;\n        info.updatedDate = data.UpdatedDate;\n        info.version = data.Version;\n        info.itemHeight = dimensions;\n        info.typeTags = selectedTypeTags;\n        info.themeTags = selectedThemeTags;\n        info.functionTags = selectedFunctionTags;\n        info.definitionTags = selectedDefinitionTags;\n        info.batchTags = selectedBatchTags;\n        info.propertyTags = selectedPropertyTags;\n\n        EditorUtility.SetDirty(prefabToUpload);\n        AssetDatabase.SaveAssets();\n        AssetDatabase.Refresh();\n\n        WriteToCsv(data);\n    }\n\n\n    private void WriteToCsv(ResourceData data)\n    {\n        string csvContent = data.ToString() + \"\\n\";\n        bool isSuccess = false;\n\n        if (!File.Exists(csvFilePath))\n        {\n            string header = \"资源ID,资源名称,资源描述,长宽高,属性标签,预制体路径,缩略图路径,面数,创建时间,更新时间,版本,类型标签,主题标签,功能标签,区域标签,批次标签\\n\";\n            try\n            {\n                File.WriteAllText(csvFilePath, header + csvContent, new System.Text.UTF8Encoding(true));\n                isSuccess = true;\n            }\n            catch (IOException ex)\n            {\n                if (IsFileLocked(ex))\n                {\n                    EditorUtility.DisplayDialog(\"错误\", \"无法保存资源信息，文件可能为只读或已被打开，请关闭文件后重试。\", \"确定\");\n                }\n                else\n                {\n                    throw;\n                }\n            }\n        }\n        else\n        {\n            try\n            {\n                File.AppendAllText(csvFilePath, csvContent, new System.Text.UTF8Encoding(true));\n                isSuccess = true;\n            }\n            catch (IOException ex)\n            {\n                if (IsFileLocked(ex))\n                {\n                    EditorUtility.DisplayDialog(\"错误\", \"无法保存资源信息，文件可能为只读或已被打开，请关闭文件后重试。\", \"确定\");\n                }\n                else\n                {\n                    throw;\n                }\n            }\n        }\n\n        if (isSuccess)\n        {\n            EditorUtility.DisplayDialog(\"资源保存\", \"资源信息已保存！\", \"确定\");\n        }\n    }\n\n    private bool IsFileLocked(IOException exception)\n    {\n        int errorCode = System.Runtime.InteropServices.Marshal.GetHRForException(exception) & ((1 << 16) - 1);\n        return errorCode == 32 || errorCode == 33;\n    }\n}\n#endif\n源代码内容解释如下：\n## 功能概览\n\n### 功能定位\n\n该代码实现了一个用于资源录入的Unity编辑器窗口，主要用于管理预制体资源的元数据和标签信息。它支持标签分类选择、资源信息录入、缩略图加载和资源数据的持久化存储。\n\n### 系统角色\n\n- 资源录入的核心入口",
    "chunk_order_index": 2,
    "full_doc_id": "doc-6cef0af551f7ce7372c3e80b9859f4c0"
  },
  "chunk-580a309d0dae12a39360520a28d673b9": {
    "tokens": 689,
    "content": "== 32 || errorCode == 33;\n    }\n}\n#endif\n源代码内容解释如下：\n## 功能概览\n\n### 功能定位\n\n该代码实现了一个用于资源录入的Unity编辑器窗口，主要用于管理预制体资源的元数据和标签信息。它支持标签分类选择、资源信息录入、缩略图加载和资源数据的持久化存储。\n\n### 系统角色\n\n- 资源录入的核心入口\n- 提供直观的标签管理界面\n- 实现资源数据的结构化存储\n- 集成Unity编辑器工作流\n\n### 主要特性\n\n- **多维度标签支持**：包括类型、主题、功能、定义、批次和属性标签\n- **标签分页浏览**：支持标签的分页显示和搜索过滤\n- **资源信息自动提取**：包括预制体尺寸、面数和缩略图\n- **数据持久化**：支持CSV格式的数据存储\n- **UI反馈机制**：提供用户操作的即时反馈\n\n## 核心类解析\n\n### ResourceEntryWindow\n\n- **职责说明**：这是一个Unity编辑器窗口，用于资源的录入和管理。它负责用户界面的绘制、资源信息的收集与验证、标签的管理和资源数据的持久化存储。\n\n- **关键方法清单**：\n\n  - `public static void ShowWindow()`：显示编辑器窗口\n  - `private void Awake()`：初始化标签库\n  - `private void OnGUI()`：绘制用户界面\n  - `private void SaveResource()`：保存资源信息\n  - `private void WriteToCsv(ResourceData data)`：将资源信息写入CSV文件\n\n- **继承关系**：\n\n```mermaid\ngraph TD\nResourceEntryWindow --> EditorWindow\n```\n\n- **依赖模块**：\n\n  - `TagLibrary`：标签库类\n  - `ResourceInfo`：资源信息组件\n  - `EditorGUILayout`：Unity编辑器布局工具\n\n## 关键方法详解\n\n### Awake\n\n- **方法签名**：`private void Awake()`\n- **功能描述**：初始化各个标签库并加载资源标签\n- **调用关系**：在编辑器窗口加载时调用\n\n### OnGUI\n\n- **方法签名**：`private void OnGUI()`\n- **功能描述**：绘制用户界面，包括资源选择、信息录入、标签选择和保存按钮\n- **调用关系**：每次窗口更新时调用\n\n### SaveResource\n\n- **方法签名**：`private void SaveResource()`\n- **功能描述**：保存资源信息到预制体组件和CSV文件\n- **调用关系**：在用户点击“保存资源”按钮时调用\n\n### WriteToCsv\n\n- **方法签名**：`private void WriteToCsv(ResourceData data)`\n- **功能描述**：将资源数据写入CSV文件\n- **调用关系**：在保存资源信息时调用\n\n## 架构关系图\n\n```mermaid\ngraph TD\n    ResourceEntryWindow --> TagLibrary\n    ResourceEntryWindow --> ResourceInfo\n    ResourceEntryWindow --> EditorWindow\n```",
    "chunk_order_index": 3,
    "full_doc_id": "doc-6cef0af551f7ce7372c3e80b9859f4c0"
  },
  "chunk-243d993b745a27da6762173e066098a1": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEditor;\nusing UnityEngine;\n\n[CustomEditor(typeof(ResourceInfo))]\npublic class ResourceInfoEditor : Editor\n{\n    private SerializedProperty idProp, resourceNameProp, resourceDescriptionProp, thumbnailPathProp, modelFacesProp, creationDateProp, updatedDateProp, versionProp, itemHeightProp;\n    private SerializedProperty typeTagsProp, themeTagsProp, functionTagsProp, definitionTagsProp, batchTagsProp, propertyTagsProp;\n\n    private TagLibrary typeTagLibrary, themeTagLibrary, functionTagLibrary, definitionTagLibrary, batchTagLibrary, propertyTagLibrary;\n    private int typeTagPageIndex = 0, themeTagPageIndex = 0, functionTagPageIndex = 0, definitionTagPageIndex = 0, batchTagPageIndex = 0, propertyTagPageIndex = 0;\n    private string searchFilter = \"\";\n    private Dictionary<string, string> searchFilters = new Dictionary<string, string>();\n\n    public void OnEnable()\n    {\n        typeTagLibrary = LoadTagLibrary(\"TypeTagLibrary\");\n        themeTagLibrary = LoadTagLibrary(\"ThemeTagLibrary\");\n        functionTagLibrary = LoadTagLibrary(\"FunctionTagLibrary\");\n        definitionTagLibrary = LoadTagLibrary(\"DefinitionTagLibrary\");\n        batchTagLibrary = LoadTagLibrary(\"BatchTagLibrary\");\n        propertyTagLibrary = LoadTagLibrary(\"PropertyTagLibrary\");\n\n        idProp = serializedObject.FindProperty(\"id\");\n        resourceNameProp = serializedObject.FindProperty(\"resourceName\");\n        resourceDescriptionProp = serializedObject.FindProperty(\"resourceDescription\");\n        thumbnailPathProp = serializedObject.FindProperty(\"thumbnailPath\");\n        modelFacesProp = serializedObject.FindProperty(\"modelFaces\");\n        itemHeightProp = serializedObject.FindProperty(\"itemHeight\");\n        creationDateProp = serializedObject.FindProperty(\"creationDate\");\n        updatedDateProp = serializedObject.FindProperty(\"updatedDate\");\n        versionProp = serializedObject.FindProperty(\"version\");\n        typeTagsProp = serializedObject.FindProperty(\"typeTags\");\n        themeTagsProp = serializedObject.FindProperty(\"themeTags\");\n        functionTagsProp = serializedObject.FindProperty(\"functionTags\");\n        definitionTagsProp = serializedObject.FindProperty(\"definitionTags\");\n        batchTagsProp = serializedObject.FindProperty(\"batchTags\");\n        propertyTagsProp = serializedObject.FindProperty(\"propertyTags\");\n\n\n        searchFilters[\"Type\"] = \"\";\n        searchFilters[\"Theme\"] = \"\";\n        searchFilters[\"Function\"] = \"\";\n        searchFilters[\"Definition\"] = \"\";\n        searchFilters[\"Batch\"] = \"\";\n        searchFilters[\"Property\"] = \"\";\n    }\n\n    public override void OnInspectorGUI()\n    {\n        ResourceInfo resourceInfo = (ResourceInfo)target;\n\n        if (resourceInfo == null)\n        {\n            EditorGUILayout.HelpBox(\"ResourceInfo is null\", MessageType.Error);\n            return;\n        }\n\n        serializedObject.Update();\n        GUI.color = Color.cyan;\n\n        if (GUILayout.Button(\"<b><color=yellow>资源版本更新</color></b>\", new GUIStyle(GUI.skin.button) { richText = true }))\n        {\n            resourceInfo.updatedDate = DateTime.Now.ToString(\"yyyy/MM/dd\");\n            int version = int.Parse(resourceInfo.version);\n            resourceInfo.version = (version + 1).ToString();\n            EditorUtility.SetDirty(resourceInfo);\n        }\n\n        // 恢复GUI颜色为默认值\n        GUI.color = Color.white;\n        EditorGUILayout.PropertyField(idProp, new GUIContent(\"ID\"));\n        EditorGUILayout.PropertyField(resourceNameProp, new GUIContent(\"名称\"));\n        EditorGUILayout.PropertyField(resourceDescriptionProp, new GUIContent(\"资源\"));\n        EditorGUILayout.PropertyField(modelFacesProp, new GUIContent(\"面数\"));\n        EditorGUILayout.PropertyField(itemHeightProp, new GUIContent(\"长、宽、高\"));\n        EditorGUILayout.PropertyField(creationDateProp, new GUIContent(\"创建日期\"));\n        EditorGUILayout.PropertyField(updatedDateProp, new GUIContent(\"更新时间\"));\n        EditorGUILayout.PropertyField(versionProp, new GUIContent(\"版本\"));\n\n        EditorGUILayout.LabelField(\"缩略图\");\n\n        // 调用新的展示缩略图方法，避免标记为脏\n        RefreshThumbnailAndDisplay();\n\n        if (GUILayout.Button(\"更新信息\"))\n        {\n            RefreshData();\n        }\n\n        EditorGUI.BeginChangeCheck();\n        searchFilter = EditorGUILayout.TextField(\"搜索所有标签\", searchFilter).ToLower();\n        if (EditorGUI.EndChangeCheck())\n        {\n            ResetAllPageIndexes();\n            UpdateSearchFilters(searchFilter);\n        }\n\n        DisplayTagSelectionWithPaging(\"类型标签\", typeTagLibrary, ref typeTagPageIndex, typeTagsProp);\n        DisplayTagSelectionWithPaging(\"主题标签\", themeTagLibrary, ref themeTagPageIndex, themeTagsProp);\n        DisplayTagSelectionWithPaging(\"区域分类\", definitionTagLibrary, ref definitionTagPageIndex, definitionTagsProp);\n        DisplayTagSelectionWithPaging(\"功能标签\", functionTagLibrary, ref functionTagPageIndex, functionTagsProp);\n        DisplayTagSelectionWithPaging(\"批次标签\", batchTagLibrary, ref batchTagPageIndex, batchTagsProp);\n        DisplayTagSelectionWithPaging(\"属性标签\", propertyTagLibrary, ref propertyTagPageIndex, propertyTagsProp);\n\n        serializedObject.ApplyModifiedProperties();\n    }\n\n\n    private void RefreshThumbnailAndDisplay()\n    {\n        ResourceInfo resourceInfo = (ResourceInfo)target;\n\n        if (resourceInfo == null)\n        {\n            Debug.LogWarning(\"ResourceInfo 脚本未找到！\");\n            return;\n        }\n\n        // 获取预制体的路径\n        string prefabPath = AssetDatabase.GetAssetPath(resourceInfo.gameObject);\n        if (string.IsNullOrEmpty(prefabPath) || !prefabPath.EndsWith(\".prefab\"))\n        {\n            return;\n        }\n\n        // 删除",
    "chunk_order_index": 0,
    "full_doc_id": "doc-c32f420e95f8c197203ecd82546c17c1"
  },
  "chunk-eb829d7f48b9f96965a9b47ea2c7440c": {
    "tokens": 1200,
    "content": "{\n        ResourceInfo resourceInfo = (ResourceInfo)target;\n\n        if (resourceInfo == null)\n        {\n            Debug.LogWarning(\"ResourceInfo 脚本未找到！\");\n            return;\n        }\n\n        // 获取预制体的路径\n        string prefabPath = AssetDatabase.GetAssetPath(resourceInfo.gameObject);\n        if (string.IsNullOrEmpty(prefabPath) || !prefabPath.EndsWith(\".prefab\"))\n        {\n            return;\n        }\n\n        // 删除路径中的“/”符号并去除公共部分路径\n        string basePath = \"Assets/ArtResource/Scenes/Standard/\";\n        if (prefabPath.StartsWith(basePath))\n        {\n            prefabPath = prefabPath.Substring(basePath.Length);\n        }\n\n        string modifiedPrefabPath = prefabPath.Replace(\"/\", \"\");\n        string ThumbnailName = System.IO.Path.GetFileNameWithoutExtension(modifiedPrefabPath);\n\n        // 构建缩略图路径\n        string thumbnailPath = $\"Assets/ZTResource/Resources/ZT_IconTextures/{ThumbnailName}.png\";\n        Texture2D newThumbnail = AssetDatabase.LoadAssetAtPath<Texture2D>(thumbnailPath);\n\n        if (newThumbnail)\n        {\n            // 直接显示图片，不修改 SerializedProperty\n            GUILayout.Label(\"缩略图预览：\");\n            GUILayout.Label(newThumbnail, GUILayout.Width(100), GUILayout.Height(100));\n        }\n        else\n        {\n            // 自定义样式：红色加粗字体\n            GUIStyle redBoldStyle = new GUIStyle(EditorStyles.boldLabel);\n            redBoldStyle.normal.textColor = Color.yellow;\n            redBoldStyle.fontSize = 14;\n\n            // 显示提示信息，未找到对应缩略图\n            GUILayout.Label(\"未找到对应缩略图,在资源录入前一定要先截图\", redBoldStyle);\n        }\n    }\n\n\n    private void RefreshData()\n    {\n        ResourceInfo resourceInfo = (ResourceInfo)target;\n        if (resourceInfo != null && resourceInfo.gameObject != null)\n        {\n            string prefabPath = AssetDatabase.GetAssetPath(resourceInfo.gameObject);\n            string basePath = \"Assets/ArtResource/Scenes/Standard/\";\n\n            if (prefabPath.StartsWith(basePath))\n            {\n                prefabPath = prefabPath.Substring(basePath.Length);\n            }\n\n            string prefabPathWithoutExtension = System.IO.Path.ChangeExtension(prefabPath, null);\n            idProp.stringValue = prefabPathWithoutExtension;\n\n            string facesCount = CalculateModelFaces(resourceInfo.gameObject);\n            modelFacesProp.stringValue = facesCount;\n\n            string dimensions = CalculatePrefabDimensions(resourceInfo.gameObject);\n            itemHeightProp.stringValue = dimensions;\n\n            // 删除过时的缩略图路径更新逻辑，仅记录 ThumbnailName\n            string modifiedPrefabPath = prefabPath.Replace(\"/\", \"\");\n            string ThumbnailName = System.IO.Path.GetFileNameWithoutExtension(modifiedPrefabPath);\n\n            // 记录 ThumbnailName（假设你有一个对应的字段）\n            resourceInfo.thumbnailPath = ThumbnailName;  // 假设有一个名为 thumbnailName 的字段\n\n            thumbnailPathProp.stringValue = ThumbnailName;\n\n            serializedObject.ApplyModifiedProperties();\n            Debug.Log($\"更新后的 ThumbnailName: {ThumbnailName}\");\n            Debug.Log($\"更新后的 thumbnailPath: {resourceInfo.thumbnailPath}\");\n        }\n    }\n\n\n    private TagLibrary LoadTagLibrary(string libraryName)\n    {\n        return AssetDatabase.LoadAssetAtPath<TagLibrary>($\"Assets/ZTResource/Resources/ZT_TagLibrary/{libraryName}.asset\");\n    }\n\n    private void DisplayTagSelectionWithPaging(string label, TagLibrary tagLibrary, ref int pageIndex, SerializedProperty tagsProp)\n    {\n        if (tagLibrary == null)\n        {\n            EditorGUILayout.HelpBox(\"标签库未找到。请确保TagLibrary对象已经创建并且路径正确。\", MessageType.Error);\n            return;\n        }\n\n        EditorGUILayout.LabelField(label);\n        int itemsPerPage = 35;\n        int columns = 4;\n\n        string searchFilterKey = label.Replace(\" \", \"\");\n        if (!searchFilters.ContainsKey(searchFilterKey))\n        {\n            searchFilters[searchFilterKey] = \"\";\n        }\n\n        IEnumerable<string> filteredTags = tagLibrary.tags.Where(tag => tag.ToLower().Contains(searchFilters[searchFilterKey]));\n        int totalTags = filteredTags.Count();\n        int totalPages = (totalTags + itemsPerPage - 1) / itemsPerPage;\n\n        int startIdx = pageIndex * itemsPerPage;\n        int endIdx = Mathf.Min(startIdx + itemsPerPage, totalTags);\n\n        for (int i = startIdx; i < endIdx; i++)\n        {\n            if ((i - startIdx) % columns == 0)\n            {\n                EditorGUILayout.BeginHorizontal();\n            }\n\n            bool present = IsTagPresent(tagsProp, filteredTags.ElementAt(i - startIdx));\n            bool toggled = GUILayout.Toggle(present, filteredTags.ElementAt(i - startIdx), \"Button\", GUILayout.Width(EditorGUIUtility.currentViewWidth / columns - 10));\n\n            if (toggled != present)\n            {\n                if (toggled)\n                    AddTag(tagsProp, filteredTags.ElementAt(i - startIdx));\n                else\n                    RemoveTag(tagsProp, filteredTags.ElementAt(i - startIdx));\n            }\n\n            if ((i - startIdx + 1) % columns == 0 || i == endIdx - 1)\n            {\n                EditorGUILayout.EndHorizontal();\n            }\n        }\n\n        if (totalPages > 1)\n        {\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"上一页\") && pageIndex > 0)\n            {\n                pageIndex--;\n            }\n            if (GUILayout.Button(\"下一页\") && pageIndex < totalPages - 1)\n            {\n                pageIndex++;\n            }\n            EditorGUILayout.EndHorizontal();",
    "chunk_order_index": 1,
    "full_doc_id": "doc-c32f420e95f8c197203ecd82546c17c1"
  },
  "chunk-3cc035d6d7e2696cdbe56f9d4d927661": {
    "tokens": 1200,
    "content": "% columns == 0 || i == endIdx - 1)\n            {\n                EditorGUILayout.EndHorizontal();\n            }\n        }\n\n        if (totalPages > 1)\n        {\n            EditorGUILayout.BeginHorizontal();\n            if (GUILayout.Button(\"上一页\") && pageIndex > 0)\n            {\n                pageIndex--;\n            }\n            if (GUILayout.Button(\"下一页\") && pageIndex < totalPages - 1)\n            {\n                pageIndex++;\n            }\n            EditorGUILayout.EndHorizontal();\n\n            EditorGUILayout.LabelField($\"页码: {pageIndex + 1} / {totalPages}\", EditorStyles.centeredGreyMiniLabel);\n        }\n    }\n\n    private bool IsTagPresent(SerializedProperty tagsProp, string tag)\n    {\n        for (int i = 0; i < tagsProp.arraySize; i++)\n        {\n            if (tagsProp.GetArrayElementAtIndex(i).stringValue == tag)\n                return true;\n        }\n        return false;\n    }\n\n    private void AddTag(SerializedProperty tagsProp, string tag)\n    {\n        tagsProp.arraySize++;\n        tagsProp.GetArrayElementAtIndex(tagsProp.arraySize - 1).stringValue = tag;\n    }\n\n    private void RemoveTag(SerializedProperty tagsProp, string tag)\n    {\n        for (int i = 0; i < tagsProp.arraySize; i++)\n        {\n            if (tagsProp.GetArrayElementAtIndex(i).stringValue == tag)\n            {\n                tagsProp.DeleteArrayElementAtIndex(i);\n                return;\n            }\n        }\n    }\n\n    private void ResetAllPageIndexes()\n    {\n        typeTagPageIndex = themeTagPageIndex = functionTagPageIndex = definitionTagPageIndex = batchTagPageIndex = propertyTagPageIndex = 0;\n    }\n\n    private void UpdateSearchFilters(string newFilter)\n    {\n        searchFilters[\"Type\"] = searchFilters[\"Theme\"] = searchFilters[\"Function\"] = searchFilters[\"Definition\"] = searchFilters[\"Batch\"] = searchFilters[\"Property\"] = newFilter;\n    }\n\n    private string CalculateModelFaces(GameObject prefab)\n    {\n        int totalFaces = 0;\n        MeshFilter[] meshFilters = prefab.GetComponentsInChildren<MeshFilter>();\n        foreach (MeshFilter meshFilter in meshFilters)\n        {\n            if (meshFilter.sharedMesh != null)\n            {\n                totalFaces += meshFilter.sharedMesh.triangles.Length / 3;\n            }\n        }\n        return totalFaces.ToString();\n    }\n\n    private string CalculatePrefabDimensions(GameObject prefab)\n    {\n        Renderer[] renderers = prefab.GetComponentsInChildren<Renderer>();\n\n        if (renderers.Length == 0)\n        {\n            Debug.Log(\"预制体中没有找到任何模型\");\n            return string.Empty;\n        }\n\n        Bounds overallBounds = renderers[0].bounds;\n\n        foreach (Renderer renderer in renderers)\n        {\n            overallBounds.Encapsulate(renderer.bounds);\n        }\n\n        float length = Mathf.Round(overallBounds.size.x * 10) / 10f;\n        float width = Mathf.Round(overallBounds.size.z * 10) / 10f;\n        float height = Mathf.Round(overallBounds.size.y * 10) / 10f;\n\n        return $\"{length}|{width}|{height}\";\n    }\n}\n\n#endif\n\n源代码内容解释如下：\n```markdown\n# 代码分析报告\n\n## 1. 功能概览\n\n### 功能定位\n该代码文件是一个Unity编辑器扩展脚本，用于自定义`ResourceInfo`类的Inspector面板。它提供了对资源信息的编辑、标签管理、缩略图预览以及版本控制等功能。\n\n### 在系统中的角色\n该脚本在Unity项目中担任资源管理工具的角色，帮助开发者更高效地管理和更新资源信息。它通过自定义Inspector面板，提供了一个用户友好的界面，便于资源的维护和更新。\n\n### 主要特性与技术实现\n- **自定义Inspector面板**：通过`CustomEditor`属性实现对`ResourceInfo`类的自定义编辑界面。\n- **标签管理**：支持多种类型的标签管理，包括类型标签、主题标签、功能标签等，并通过分页显示和搜索功能提升用户体验。\n- **资源信息自动更新**：能够自动计算和更新资源的面数、尺寸等信息。\n- **版本控制**：提供资源版本更新功能，自动记录更新时间和版本号。\n- **缩略图预览**：支持缩略图的加载和显示，并提供缺失提示。\n\n## 2. 核心类解析\n\n### `ResourceInfoEditor`类\n\n#### 职责说明\n该类的主要职责是为`ResourceInfo`类提供一个自定义的Inspector编辑界面。它实现了对资源信息的编辑、标签管理、缩略图预览以及版本控制等功能。\n\n#### 关键方法清单\n- `public override void OnInspectorGUI()`\n- `private void RefreshThumbnailAndDisplay()`\n- `private void RefreshData()`\n- `private TagLibrary LoadTagLibrary(string libraryName)`\n- `private void DisplayTagSelectionWithPaging(string label, TagLibrary tagLibrary, ref int pageIndex, SerializedProperty tagsProp)`\n- `private bool IsTagPresent(SerializedProperty tagsProp, string tag)`\n- `private void AddTag(SerializedProperty tagsProp, string tag)`\n- `private void RemoveTag(SerializedProperty tagsProp, string tag)`\n- `private void ResetAllPageIndexes()`\n- `private void UpdateSearchFilters(string newFilter)`\n- `private string CalculateModelFaces(GameObject prefab)`\n- `private string CalculatePrefabDimensions(GameObject prefab)`\n\n#### 继承关系\n```\nResourceInfoEditor -> Editor\n```\n\n####",
    "chunk_order_index": 2,
    "full_doc_id": "doc-c32f420e95f8c197203ecd82546c17c1"
  },
  "chunk-941762759cece90fdab0c14a30a4eb67": {
    "tokens": 852,
    "content": "SerializedProperty tagsProp, string tag)`\n- `private void AddTag(SerializedProperty tagsProp, string tag)`\n- `private void RemoveTag(SerializedProperty tagsProp, string tag)`\n- `private void ResetAllPageIndexes()`\n- `private void UpdateSearchFilters(string newFilter)`\n- `private string CalculateModelFaces(GameObject prefab)`\n- `private string CalculatePrefabDimensions(GameObject prefab)`\n\n#### 继承关系\n```\nResourceInfoEditor -> Editor\n```\n\n#### 依赖模块\n- `UnityEngine`\n- ` UnityEditor`\n- `System.Collections.Generic`\n- `System.Linq`\n- 内部依赖：\n  - `ResourceInfo`类\n  - `TagLibrary`类\n\n## 3. 关键方法详解\n\n### `OnInspectorGUI()`\n#### 方法签名\n```csharp\npublic override void OnInspectorGUI()\n```\n\n#### 功能描述\n该方法负责绘制自定义的Inspector界面。它显示了资源的基本信息、标签选择界面、缩略图预览以及版本更新按钮等功能。\n\n#### 调用关系\n- 被Unity编辑器自动调用以绘制Inspector面板。\n- 调用`RefreshThumbnailAndDisplay()`、`RefreshData()`等方法以更新界面内容。\n\n### `RefreshThumbnailAndDisplay()`\n#### 方法签名\n```csharp\nprivate void RefreshThumbnailAndDisplay()\n```\n\n#### 功能描述\n该方法负责加载并显示资源的缩略图。如果缩略图不存在，则显示提示信息。\n\n#### 调用关系\n- 在`OnInspectorGUI()`中被调用以更新缩略图显示。\n\n### `RefreshData()`\n#### 方法签名\n```csharp\nprivate void RefreshData()\n```\n\n#### 功能描述\n该方法更新资源的信息，包括ID、面数、尺寸等，并应用修改。\n\n#### 调用关系\n- 在`OnInspectorGUI()`中被调用，当用户点击“更新信息”按钮时触发。\n\n### `DisplayTagSelectionWithPaging()`\n#### 方法签名\n```csharp\nprivate void DisplayTagSelectionWithPaging(string label, TagLibrary tagLibrary, ref int pageIndex, SerializedProperty tagsProp)\n```\n\n#### 功能描述\n该方法显示标签选择界面，并支持分页浏览。用户可以通过该界面添加或移除标签。\n\n#### 调用关系\n- 在`OnInspectorGUI()`中被调用以显示不同类型的标签选择界面。\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class ResourceInfoEditor {\n        +void OnInspectorGUI()\n        +void RefreshThumbnailAndDisplay()\n        +void RefreshData()\n        +TagLibrary LoadTagLibrary(string)\n        +void DisplayTagSelectionWithPaging(string, TagLibrary, ref int, SerializedProperty)\n        +bool IsTagPresent(SerializedProperty, string)\n        +void AddTag(SerializedProperty, string)\n        +void RemoveTag(SerializedProperty, string)\n        +void ResetAllPageIndexes()\n        +void UpdateSearchFilters(string)\n        +string CalculateModelFaces(GameObject)\n        +string CalculatePrefabDimensions(GameObject)\n    }\n    ResourceInfoEditor --> Editor\n    ResourceInfoEditor *-- TagLibrary\n    ResourceInfoEditor *-- ResourceInfo\n```\n\n### 说明\n- `ResourceInfoEditor`类继承自`Editor`类，负责自定义Inspector面板的绘制。\n- 该类依赖`TagLibrary`类来管理标签数据，依赖`ResourceInfo`类来获取和更新资源信息。\n- 通过`SerializedProperty`类实现对资源字段的绑定和操作。\n\n## 5. 总结\n\n该代码文件通过自定义的Inspector面板，为`ResourceInfo`类提供了丰富的编辑和管理功能。它不仅支持基本的字段编辑，还提供了标签管理、缩略图预览、版本控制等功能，极大地方便了资源的维护和更新。通过合理的继承和依赖关系，该类实现了高度的模块化和可扩展性，能够适应不同的项目需求。",
    "chunk_order_index": 3,
    "full_doc_id": "doc-c32f420e95f8c197203ecd82546c17c1"
  },
  "chunk-20134ec4fe108f8e343d7f5d4bf943cd": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing TMPro;\n\npublic class PropertyInstanceManager : MonoBehaviour\n{\n    public GameObject LODInstance; // LDO\n    public GameObject ColorChangeInstance; // 变色\n    public GameObject WallMountInstance; // 壁挂    \n    public GameObject DynamicInstance; // 动态\n    public GameObject HookPointInstance; // 挂点\n    public GameObject OldEffectInstance; // 做旧\n    public TMP_Text Property_Text;\n\n    // 添加实例的方法\n    public void AddLODInstance(GameObject instance)\n    {\n        LODInstance = instance;\n    }\n\n    public void AddColorChangeInstance(GameObject instance)\n    {\n        ColorChangeInstance = instance;\n    }\n\n    public void AddWallMountInstance(GameObject instance)\n    {\n        WallMountInstance = instance;\n    }\n\n    public void AddHookPointInstance(GameObject instance)\n    {\n        HookPointInstance = instance;\n    }\n\n    public void AddDynamicInstance(GameObject instance)\n    {\n        DynamicInstance = instance;\n    }\n\n    public void AddOldEffectInstance(GameObject instance)\n    {\n        OldEffectInstance = instance;\n    }\n\n    // 添加Property_Text实例的方法\n    public void AddPropertyText(TMP_Text text)\n    {\n        Property_Text = text;\n    }\n\n    // 更新实例显示状态的方法\n    public void UpdateInstanceVisibility()\n    {\n        if (Property_Text == null) return;\n\n        string text = Property_Text.text;\n\n        LODInstance?.SetActive(text.Contains(\"LOD\"));\n        ColorChangeInstance?.SetActive(text.Contains(\"变色\"));\n        WallMountInstance?.SetActive(text.Contains(\"壁挂\"));\n        HookPointInstance?.SetActive(text.Contains(\"挂点\"));\n        DynamicInstance?.SetActive(text.Contains(\"动态\"));\n        OldEffectInstance?.SetActive(text.Contains(\"做旧\"));\n    }\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 功能定位\n\n`PropertyInstanceManager` 类是一个用于管理游戏对象实例和文本属性显示的工具类。它主要负责维护不同类型的实例对象，并根据文本内容动态控制这些实例的可见性。\n\n#### 系统角色\n\n在Unity项目中，该类充当实例管理器，确保各个功能模块（如LOD、变色、壁挂等）的实例能够根据文本描述正确显示或隐藏。它是系统中实例管理的核心组件，对于动态展示功能至关重要。\n\n#### 主要特性与技术实现\n\n- **实例管理**：维护多个GameObject实例，包括LOD、颜色变化、壁挂、动态、挂点和做旧效果。\n- **文本属性控制**：通过解析TMP_Text组件的内容，动态调整实例的可见性。\n- **模块化设计**：每个实例管理功能独立，便于扩展和维护。\n- **依赖管理**：使用Unity的MonoBehaviour和TextMeshPro组件。\n\n### 2. 核心类解析\n\n#### `PropertyInstanceManager` 类\n\n- **职责说明**：管理多个实例对象，并根据文本内容动态控制其显示状态。\n  \n- **关键方法清单**：\n  - `public void AddLODInstance(GameObject instance)`\n  - `public void AddColorChangeInstance(GameObject instance)`\n  - `public void AddWallMountInstance(GameObject instance)`\n  - `public void AddHookPointInstance(GameObject instance)`\n  - `public void AddDynamicInstance(GameObject instance)`\n  - `public void AddOldEffectInstance(GameObject instance)`\n  - `public void AddPropertyText(TMP_Text text)`\n  - `public void UpdateInstanceVisibility()`\n\n- **继承关系**：\n  ```mermaid\n  classDiagram\n    class PropertyInstanceManager {\n      +MonoBehaviour\n    }\n    PropertyInstanceManager --> MonoBehaviour\n  ```\n\n- **依赖模块**：\n  - `UnityEngine`：用于访问Unity引擎功能。\n  - `TextMeshPro`：用于处理文本显示。\n\n### 3. 关键方法详解\n\n#### 方法签名与功能描述\n\n1. **`public void AddLODInstance(GameObject instance)`**\n   - **功能描述**：设置LOD（细节层次）实例对象。\n   - **调用关系**：通常在初始化或动态加载时被调用。\n\n2. **`public void AddColorChangeInstance(GameObject instance)`**\n   - **功能描述**：设置颜色变化实例对象。\n   - **调用关系**：在初始化或颜色变化功能加载时调用。\n\n3. **`public void AddWallMountInstance(GameObject instance)`**\n   - **功能描述**：设置壁挂实例对象。\n   - **调用关系**：初始化或壁挂功能加载时调用。\n\n4. **`public void AddHookPointInstance(GameObject instance)`**\n   - **功能描述**：设置挂点实例对象。\n   - **调用关系**：初始化或挂点功能加载时调用。\n\n5. **`public void AddDynamicInstance(GameObject instance)`**\n   - **功能描述**：设置动态效果实例对象。\n   - **调用关系**：初始化或动态效果加载时调用。\n\n6. **`public void AddOldEffectInstance(GameObject instance)`**\n   - **功能描述**：设置做旧效果实例对象。\n   - **调用关系**：初始化或做旧效果加载时调用。\n\n7. **`public void AddPropertyText(TMP_Text text)`**\n   - **功能描述**：设置属性文本组件，用于解析文本内容。\n   - **调用关系**：通常在初始化时调用。\n\n8. **`public void UpdateInstanceVisibility()`**\n   - **功能描述**：根据属性文本内容，更新实例对象的可见性。\n   - **调用关系**：可能在文本变化",
    "chunk_order_index": 0,
    "full_doc_id": "doc-a977772737376b94a7514fe65f1e9308"
  },
  "chunk-833783c10ae577c583fb5eedd48f62d0": {
    "tokens": 429,
    "content": "调用关系**：初始化或做旧效果加载时调用。\n\n7. **`public void AddPropertyText(TMP_Text text)`**\n   - **功能描述**：设置属性文本组件，用于解析文本内容。\n   - **调用关系**：通常在初始化时调用。\n\n8. **`public void UpdateInstanceVisibility()`**\n   - **功能描述**：根据属性文本内容，更新实例对象的可见性。\n   - **调用关系**：可能在文本变化时被调用，频率取决于文本更新频率。\n\n#### 算法说明\n\n- **UpdateInstanceVisibility方法**：\n  - 检查`Property_Text`是否存在，若不存在则返回。\n  - 读取文本内容，检查是否包含特定关键词（如“LOD”、“变色”等）。\n  - 根据关键词的存在与否，设置对应实例对象的活动状态。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class PropertyInstanceManager {\n        +MonoBehaviour\n        +GameObject LODInstance\n        +GameObject ColorChangeInstance\n        +GameObject WallMountInstance\n        +GameObject DynamicInstance\n        +GameObject HookPointInstance\n        +GameObject OldEffectInstance\n        +TMP_Text Property_Text\n        +void AddLODInstance(GameObject instance)\n        +void AddColorChangeInstance(GameObject instance)\n        +void AddWallMountInstance(GameObject instance)\n        +void AddHookPointInstance(GameObject instance)\n        +void AddDynamicInstance(GameObject instance)\n        +void AddOldEffectInstance(GameObject instance)\n        +void AddPropertyText(TMP_Text text)\n        +void UpdateInstanceVisibility()\n    }\n    PropertyInstanceManager --> MonoBehaviour\n    PropertyInstanceManager *--> GameObject\n    PropertyInstanceManager *--> TMP_Text\n```\n\n### 总结\n\n`PropertyInstanceManager` 类通过维护多个实例对象和解析文本内容，实现了动态控制实例可见性的功能。其设计简洁明了，便于扩展和维护，是项目中重要的实例管理组件。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-a977772737376b94a7514fe65f1e9308"
  },
  "chunk-e82afb996b439fcefe3d4224b3588890": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\n\npublic class ResourceFilterResult : MonoBehaviour\n{\n    public string[] typeTag = new string[0];\n    public string[] themeTag = new string[0];\n    public string[] functionTag = new string[0];\n    public string[] batchTag = new string[0];\n    public string[] definitionTag = new string[0];\n    public string[] propertyTag = new string[0];\n\n    public string SearchTerm = \"\";\n    private ResourceFilter resourceFilter;\n    public ResourceCardSpawner resourceCardSpawner;\n    public MultipleTagButtonCreator multipleTagButtonCreator;\n\n    public TMP_InputField searchInputField;\n    public Button searchButton;\n    public Button clearButton;\n\n    public RectTransform panel;\n    public Button toggleWidthButton;\n    public float defaultWidth = 1621f;\n    public float fullScreenWidth = 2806f;\n    private bool isFullScreen = false;\n\n    public AiSearch aiSearch;\n\n    private List<string> idList = new List<string>();\n    private List<string> searchHistory = new List<string>();\n\n    private void Start()\n    {\n        resourceFilter = FindObjectOfType<ResourceFilter>();\n        FilterAndPrintResources();\n        searchButton.onClick.AddListener(PerformSearch);\n\n        clearButton.onClick.AddListener(ClearAllFilters);\n        clearButton.gameObject.SetActive(false);\n\n        if (panel != null)\n        {\n            panel.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, defaultWidth);\n        }\n\n        if (aiSearch != null)\n        {\n            aiSearch.OnQueryResultReceived += UpdateIdList;\n        }\n    }\n\n    private void UpdateIdList(List<string> ids)\n    {\n        idList = ids;\n        SearchTerm = \"\"; // ÔÚ¸üÐÂ idList Ê±Çå¿Õ SearchTerm\n        FilterAndPrintResources();\n    }\n\n\n    private void PerformSearch()\n    {\n        if (searchInputField != null)\n        {\n            SearchTerm = searchInputField.text;\n\n            AddSearchHistory(SearchTerm);\n\n            idList.Clear(); // ÔÚÐÂËÑË÷Ç°Çå¿Õ idList\n\n            FilterAndPrintResources();\n        }\n    }\n\n    public List<string> GetSearchHistory()\n    {\n        return searchHistory;\n    }\n\n    public void AddSearchHistory(string searchTerm)\n    {\n        if (!string.IsNullOrEmpty(searchTerm) && !searchHistory.Contains(searchTerm))\n        {\n            searchHistory.Add(searchTerm);\n\n            SearchHistoryDropdownHandler dropdownHandler = FindObjectOfType<SearchHistoryDropdownHandler>();\n            if (dropdownHandler != null)\n            {\n                dropdownHandler.UpdateDropdownOptions();\n            }\n        }\n    }\n\n    public void FilterAndPrintResources()\n    {\n        if (resourceFilter != null)\n        {\n            var filteredResources = resourceFilter.FilterResources(typeTag, themeTag, functionTag, batchTag, definitionTag, propertyTag, SearchTerm, idList);\n\n            List<ResourceCardData> sortedResources;\n            if (idList.Count > 0)\n            {\n                sortedResources = new List<ResourceCardData>();\n                foreach (var id in idList)\n                {\n                    var resource = filteredResources.Find(r => r.ID == id);\n                    if (resource != null)\n                    {\n                        sortedResources.Add(resource);\n                    }\n                }\n            }\n            else\n            {\n                sortedResources = filteredResources;\n            }\n\n            resourceFilter.PrintFilteredResources(sortedResources);\n\n            if (resourceCardSpawner != null)\n            {\n                resourceCardSpawner.SetFilteredResources(sortedResources);\n            }\n\n            UpdateTagButtonVisibility(sortedResources);\n        }\n\n        UpdateClearButtonVisibility();\n    }\n\n    private void UpdateTagButtonVisibility(List<ResourceCardData> filteredResources)\n    {\n        if (multipleTagButtonCreator != null)\n        {\n            HashSet<string> visibleTags = ExtractTagsFromResources(filteredResources);\n\n            multipleTagButtonCreator.UpdateTagButtonVisibility(visibleTags);\n        }\n    }\n\n    private HashSet<string> ExtractTagsFromResources(List<ResourceCardData> resources)\n    {\n        HashSet<string> tags = new HashSet<string>();\n        foreach (var resource in resources)\n        {\n            foreach (var tag in resource.TypeTags) tags.Add(tag);\n            foreach (var tag in resource.ThemeTags) tags.Add(tag);\n            foreach (var tag in resource.FunctionTags) tags.Add(tag);\n            foreach (var tag in resource.DefinitionTags) tags.Add(tag);\n            foreach (var tag in resource.BatchTags) tags.Add(tag);\n            foreach (var tag in resource.PropertyTags) tags.Add(tag);\n        }\n        return tags;\n    }\n\n    void ToggleWidth()\n    {\n        if (isFullScreen)\n        {\n            panel.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, defaultWidth);\n        }\n        else\n        {\n            panel.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, fullScreenWidth);\n        }\n        isFullScreen = !isFullScreen;\n    }\n\n    public void ClearAllFilters()\n    {\n        typeTag = new string[0];\n        themeTag = new string[0];\n        functionTag = new string[0];\n        batchTag = new string[0];\n        definitionTag = new string[0];\n        propertyTag = new string[0];\n        SearchTerm = \"\";\n        idList.Clear();\n\n        if (searchInputField != null)\n        {\n            searchInputField.text = \"\";\n        }\n\n        SearchHistoryDropdownHandler dropdownHandler = FindObjectOfType<SearchHistoryDropdownHandler>();\n        if (dropdownHandler != null && dropdownHandler.searchHistoryDropdown != null)\n        {\n            dropdownHandler.searchHistoryDropdown.onValueChanged.RemoveListener(dropdownHandler.OnSearchHistorySelected);\n            dropdownHandler.searchHistoryDropdown.value = 0;\n            dropdownHandler.searchHistoryDropdown.onValueChanged.AddListener(dropdownHandler.OnSearchHistorySelected);\n        }",
    "chunk_order_index": 0,
    "full_doc_id": "doc-3710512ac1b3ad3f11d3ed72667385e4"
  },
  "chunk-e5ecbf8c32e84d4759c645a16c4299ae": {
    "tokens": 1200,
    "content": "null)\n        {\n            searchInputField.text = \"\";\n        }\n\n        SearchHistoryDropdownHandler dropdownHandler = FindObjectOfType<SearchHistoryDropdownHandler>();\n        if (dropdownHandler != null && dropdownHandler.searchHistoryDropdown != null)\n        {\n            dropdownHandler.searchHistoryDropdown.onValueChanged.RemoveListener(dropdownHandler.OnSearchHistorySelected);\n            dropdownHandler.searchHistoryDropdown.value = 0;\n            dropdownHandler.searchHistoryDropdown.onValueChanged.AddListener(dropdownHandler.OnSearchHistorySelected);\n        }\n\n        ResetTagButtonStates();\n\n        FilterAndPrintResources();\n    }\n\n    private void ResetTagButtonStates()\n    {\n        if (multipleTagButtonCreator != null)\n        {\n            multipleTagButtonCreator.ResetAllTagButtonStates();\n        }\n    }\n\n    private void UpdateClearButtonVisibility()\n    {\n        bool hasFilters = typeTag.Length > 0 || themeTag.Length > 0 || functionTag.Length > 0 || batchTag.Length > 0 || definitionTag.Length > 0 || propertyTag.Length > 0 || !string.IsNullOrEmpty(SearchTerm) || idList.Count > 0;\n        clearButton.gameObject.SetActive(hasFilters);\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n- **功能总结**：ResourceFilterResult 类主要用于管理资源过滤器的结果展示和用户交互逻辑。它负责处理资源的过滤、搜索、显示以及相关的 UI 控制，如标签按钮的可见性和面板宽度的切换。\n\n- **系统角色**：在Unity项目中，该类作为资源管理模块的核心部分，承担着用户输入处理、资源过滤、结果展示以及 UI 状态管理的重要职责。它是连接用户操作与资源展示的桥梁。\n\n- **主要特性与技术实现**：\n  - **资源过滤**：通过标签和搜索词过滤资源，并将结果传递给展示组件。\n  - **搜索历史**：记录用户的搜索历史，并支持通过下拉菜单重新选择历史记录。\n  - **动态 UI 控制**：根据过滤结果动态调整标签按钮的可见性，并控制清除按钮的显示状态。\n  - **面板宽度切换**：提供全屏和默认宽度的切换功能，提升用户体验。\n  - **事件驱动**：通过 Unity 的事件系统处理用户交互，如按钮点击和输入框文本变化。\n\n---\n\n### 2. 核心类解析\n\n#### **ResourceFilterResult**\n\n- **职责说明**：该类的主要职责是管理资源过滤器的结果展示和用户交互逻辑。它负责处理用户输入（如搜索词和标签选择）、过滤资源、更新 UI 组件以及维护搜索历史。\n\n- **关键方法清单**：\n  - `private void Start()`：初始化组件和事件监听。\n  - `private void PerformSearch()`：执行搜索操作并更新结果。\n  - `public void FilterAndPrintResources()`：过滤资源并将其传递给展示组件。\n  - `public void ClearAllFilters()`：清除所有过滤条件并重置 UI 状态。\n  - `private void UpdateClearButtonVisibility()`：根据过滤条件的状态更新清除按钮的可见性。\n\n- **继承关系**：\n  ```mermaid\n  ResourceFilterResult --> MonoBehaviour\n  ```\n\n- **依赖模块**：\n  - `ResourceFilter`：用于过滤资源。\n  - `ResourceCardSpawner`：用于展示过滤后的资源卡片。\n  - `MultipleTagButtonCreator`：用于创建和管理标签按钮。\n  - `SearchHistoryDropdownHandler`：用于管理搜索历史下拉菜单。\n  - `AiSearch`：用于处理 AI 搜索请求。\n\n---\n\n### 3. 关键方法详解\n\n#### **`Start()`**\n\n- **方法签名**：`private void Start()`\n- **功能描述**：在脚本初始化时执行，负责初始化组件引用、设置事件监听以及初始状态的配置。\n- **算法说明**：无复杂算法。\n- **调用关系**：由 Unity 引擎在脚本初始化时自动调用，后续可能调用 `FilterAndPrintResources()` 和 `PerformSearch()`。\n\n#### **`PerformSearch()`**\n\n- **方法签名**：`private void PerformSearch()`\n- **功能描述**：处理用户的搜索操作，获取搜索词，更新搜索历史，并重新过滤资源。\n- **算法说明**：无复杂算法。\n- **调用关系**：由 `searchButton.onClick.AddListener(PerformSearch)` 调用，频率取决于用户的点击操作。\n\n#### **`FilterAndPrintResources()`**\n\n- **方法签名**：`public void FilterAndPrintResources()`\n- **功能描述**：根据当前的过滤条件（标签、搜索词、id 列表）过滤资源，并将结果传递给展示组件。\n- **算法说明**：无复杂算法。\n- **调用关系**：被 `Start()`、`UpdateIdList()` 和 `ClearAllFilters()` 调用，频率取决于过滤条件的变更。\n\n#### **`ClearAllFilters()`**\n\n- **方法签名**：`public void ClearAllFilters()`\n- **功能描述**：清除所有过滤条件，并重置 UI 组件的状态。\n- **算法说明**：无复杂算法。\n- **调用关系**：由 `clearButton.onClick.AddListener(ClearAllFilters)` 调用，频率取决于用户的清除操作。\n\n#### **`UpdateClearButtonVisibility()`**\n\n- **方法签名**：`private void UpdateClearButtonVisibility()`\n- **功能描述**：检查当前是否存在过滤条件，更新清除按钮的",
    "chunk_order_index": 1,
    "full_doc_id": "doc-3710512ac1b3ad3f11d3ed72667385e4"
  },
  "chunk-9c15abae9fabbca0f5772c13b5c4b34b": {
    "tokens": 500,
    "content": "清除所有过滤条件，并重置 UI 组件的状态。\n- **算法说明**：无复杂算法。\n- **调用关系**：由 `clearButton.onClick.AddListener(ClearAllFilters)` 调用，频率取决于用户的清除操作。\n\n#### **`UpdateClearButtonVisibility()`**\n\n- **方法签名**：`private void UpdateClearButtonVisibility()`\n- **功能描述**：检查当前是否存在过滤条件，更新清除按钮的可见性。\n- **算法说明**：无复杂算法。\n- **调用关系**：被 `FilterAndPrintResources()` 调用，频率取决于过滤条件的变更。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n  class ResourceFilterResult {\n    +ResourceFilter resourceFilter\n    +ResourceCardSpawner resourceCardSpawner\n    +MultipleTagButtonCreator multipleTagButtonCreator\n    +SearchHistoryDropdownHandler searchHistoryDropdownHandler\n    +AiSearch aiSearch\n    +void Start()\n    +void PerformSearch()\n    +void FilterAndPrintResources()\n    +void ClearAllFilters()\n    +void UpdateClearButtonVisibility()\n    +void UpdateTagButtonVisibility()\n    +void ExtractTagsFromResources()\n    +void ToggleWidth()\n    +void AddSearchHistory()\n    +void ResetTagButtonStates()\n  }\n\n  class ResourceFilter {\n    +List<ResourceCardData> FilterResources()\n    +void PrintFilteredResources()\n  }\n\n  class ResourceCardSpawner {\n    +void SetFilteredResources()\n  }\n\n  class MultipleTagButtonCreator {\n    +void UpdateTagButtonVisibility()\n    +void ResetAllTagButtonStates()\n  }\n\n  class SearchHistoryDropdownHandler {\n    +void UpdateDropdownOptions()\n    +void OnSearchHistorySelected()\n  }\n\n  class AiSearch {\n    +void OnQueryResultReceived()\n  }\n\n  ResourceFilterResult --> ResourceFilter : uses\n  ResourceFilterResult --> ResourceCardSpawner : uses\n  ResourceFilterResult --> MultipleTagButtonCreator : uses\n  ResourceFilterResult --> SearchHistoryDropdownHandler : uses\n  ResourceFilterResult --> AiSearch : uses\n```\n\n---\n\n### 总结\n\nResourceFilterResult 类是资源管理模块的核心，负责协调资源过滤、搜索、展示以及用户交互逻辑。通过依赖注入和事件驱动的方式，它实现了灵活且易于维护的架构设计。",
    "chunk_order_index": 2,
    "full_doc_id": "doc-3710512ac1b3ad3f11d3ed72667385e4"
  },
  "chunk-40cdac35217e3cbe75f3e920edffbe37": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Linq;\n\npublic class ResourceCardSpawner : MonoBehaviour\n{\n    public GameObject resourceCardPrefab; // 资源卡的预制体\n    public Transform cardsParent; // 卡片生成的父对象\n    private List<ResourceCardData> initialResources; // 初始资源数据\n    private List<ResourceCardData> currentFilteredResources; // 当前筛选后的资源数据\n    private int currentPage = 0; // 当前页码\n    public int cardsPerPage = 5; // 每页显示的卡片数量\n\n    public TMP_InputField pageInputField; // 分页数值显示的TMP_InputField\n    public TMP_InputField cardsPerPageInputField; // 每页卡片数量的TMP_InputField\n    public Button prevButton; // 上一页按钮\n    public Button nextButton; // 下一页按钮\n\n    public TextMeshProUGUI totalResourcesText;  // 显示总资源数量的\n\n    //排列变量\n    public enum SortType\n    {\n        Default,\n        ModelFaces,\n        Height,\n        CreationDate\n    }\n\n    private SortType currentSortType = SortType.Default;\n    private bool sortDescending = false;\n\n    public Button defaultSortButton;\n    public Button modelFacesSortButton;\n    public Button heightSortButton;\n    public Button creationDateSortButton;\n    //筛选箭头表示\n    public Image modelFacesArrowUp;\n    public Image modelFacesArrowDown;\n    public Image heightArrowUp;\n    public Image heightArrowDown;\n    public Image creationDateArrowUp;\n    public Image creationDateArrowDown;\n\n    void Start()\n    {\n        defaultSortButton.onClick.AddListener(() => SetSortType(SortType.Default));\n        modelFacesSortButton.onClick.AddListener(() => SetSortType(SortType.ModelFaces));\n        heightSortButton.onClick.AddListener(() => SetSortType(SortType.Height));\n        creationDateSortButton.onClick.AddListener(() => SetSortType(SortType.CreationDate));\n\n        // 初始化pageInputField\n        pageInputField.onEndEdit.AddListener(OnPageInputChanged);\n\n        // 初始化每页卡片数量输入框，并显示当前每页的卡片数量\n        cardsPerPageInputField.text = cardsPerPage.ToString();\n        cardsPerPageInputField.onEndEdit.AddListener(OnCardsPerPageInputChanged);\n    }\n\n    private void OnPageInputChanged(string input)\n    {\n        int newPage;\n        if (int.TryParse(input, out newPage))\n        {\n            newPage = Mathf.Clamp(newPage - 1, 0, Mathf.CeilToInt(currentFilteredResources.Count / (float)cardsPerPage) - 1);\n            if (newPage != currentPage)\n            {\n                currentPage = newPage;\n                UpdateCardsOnPage();\n            }\n        }\n        else\n        {\n            // 如果输入无效，重置为当前页码\n            pageInputField.text = (currentPage + 1).ToString();\n        }\n    }\n\n    private void OnCardsPerPageInputChanged(string input)\n    {\n        int newCardsPerPage;\n        if (int.TryParse(input, out newCardsPerPage) && newCardsPerPage > 0)\n        {\n            cardsPerPage = newCardsPerPage;\n            currentPage = 0; // 重置到第一页\n            UpdateCardsOnPage();\n        }\n        else\n        {\n            // 如果输入无效，重置为当前每页卡片数量\n            cardsPerPageInputField.text = cardsPerPage.ToString();\n        }\n    }\n\n    public void SetSortType(SortType sortType)\n    {\n        if (currentSortType == sortType)\n        {\n            sortDescending = !sortDescending; // 如果已经在当前排序类型下，改变排序方向\n        }\n        else\n        {\n            currentSortType = sortType;\n            sortDescending = false; // 默认为升序\n        }\n\n        SortResources();\n    }\n\n    public void ResetSort()\n    {\n        currentSortType = SortType.Default;\n        sortDescending = false;\n        SortResources();\n    }\n\n    // 接收筛选后的资源数据并更新UI\n    public void SetFilteredResources(List<ResourceCardData> filteredResources)\n    {\n        initialResources = new List<ResourceCardData>(filteredResources); // 保存初始资源数据\n        currentFilteredResources = new List<ResourceCardData>(filteredResources);\n        currentPage = 0; // 重置到第一页\n\n        currentSortType = SortType.Default;\n        UpdateCardsOnPage();\n        UpdateTotalResourcesText();\n        //Debug.Log($\"筛选后的资源总数: {currentFilteredResources.Count}\"); // 添加打印日志\n    }\n\n    private void UpdateTotalResourcesText()\n    {\n        totalResourcesText.text = $\"筛选总数: {currentFilteredResources.Count}\";\n    }\n\n    // 更新当前页面上的卡片\n    private void UpdateCardsOnPage()\n    {\n        ClearCards();\n\n        if (currentFilteredResources == null || currentFilteredResources.Count == 0) return;\n\n        int start = currentPage * cardsPerPage;\n        int end = Mathf.Min(start + cardsPerPage, currentFilteredResources.Count);\n\n        for (int i = start; i < end; i++)\n        {\n            var resourceData = currentFilteredResources[i];\n            // 去除Name字段中的双引号\n            string nameWithoutQuotes = resourceData.Name.Replace(\"\\\"\", \"\");\n            string descriptionWithoutQuotes = resourceData.Description.Replace(\"\\\"\", \"\");\n            var newCard = Instantiate(resourceCardPrefab, cardsParent);\n            var cardUI = newCard.GetComponent<ResourceCardUI>();\n\n            cardUI?.SetupCard(\n                resourceData.ID,",
    "chunk_order_index": 0,
    "full_doc_id": "doc-9fd9a070f34db436b2711d279afec2bb"
  },
  "chunk-6803367c9558992f73a81f27713591af": {
    "tokens": 1200,
    "content": "for (int i = start; i < end; i++)\n        {\n            var resourceData = currentFilteredResources[i];\n            // 去除Name字段中的双引号\n            string nameWithoutQuotes = resourceData.Name.Replace(\"\\\"\", \"\");\n            string descriptionWithoutQuotes = resourceData.Description.Replace(\"\\\"\", \"\");\n            var newCard = Instantiate(resourceCardPrefab, cardsParent);\n            var cardUI = newCard.GetComponent<ResourceCardUI>();\n\n            cardUI?.SetupCard(\n                resourceData.ID,\n                nameWithoutQuotes, // 使用去掉引号的名称\n                descriptionWithoutQuotes,\n                resourceData.Height,\n                resourceData.PrefabPath,\n                resourceData.ThumbnailPath,\n                resourceData.ModelFaces,\n                resourceData.CreationDate,\n                resourceData.UpdatedDate,\n                resourceData.Version,\n                string.Join(\", \", resourceData.TypeTags),\n                string.Join(\", \", resourceData.ThemeTags),\n                string.Join(\", \", resourceData.FunctionTags),\n                string.Join(\", \", resourceData.DefinitionTags),\n                string.Join(\", \", resourceData.BatchTags),\n                string.Join(\", \", resourceData.PropertyTags)\n            );\n        }\n\n        UpdateUI();\n    }\n\n    // 清除当前页面的所有卡片\n    private void ClearCards()\n    {\n        foreach (Transform child in cardsParent)\n        {\n            Destroy(child.gameObject);\n        }\n    }\n\n    // 翻页方法，可供按钮等 UI 元素调用\n    public void NextPage()\n    {\n        if (currentPage * cardsPerPage < currentFilteredResources.Count - cardsPerPage)\n        {\n            currentPage++;\n            UpdateCardsOnPage();\n        }\n    }\n\n    public void PreviousPage()\n    {\n        if (currentPage > 0)\n        {\n            currentPage--;\n            UpdateCardsOnPage();\n        }\n    }\n\n    // 更新UI组件，如分页文本和按钮状态\n    private void UpdateUI()\n    {\n        int totalPages = Mathf.CeilToInt(currentFilteredResources.Count / (float)cardsPerPage);\n        pageInputField.text = $\"{currentPage + 1}/{totalPages}\"; // 显示为“当前页/总页数”\n        prevButton.interactable = currentPage > 0;\n        nextButton.interactable = currentPage * cardsPerPage < currentFilteredResources.Count - cardsPerPage;\n\n        // 隐藏所有箭头图标\n        modelFacesArrowUp.gameObject.SetActive(false);\n        modelFacesArrowDown.gameObject.SetActive(false);\n        heightArrowUp.gameObject.SetActive(false);\n        heightArrowDown.gameObject.SetActive(false);\n        creationDateArrowUp.gameObject.SetActive(false);\n        creationDateArrowDown.gameObject.SetActive(false);\n\n        // 根据当前的排序类型和方向显示箭头图标\n        switch (currentSortType)\n        {\n            case SortType.ModelFaces:\n                if (sortDescending)\n                    modelFacesArrowDown.gameObject.SetActive(true);\n                else\n                    modelFacesArrowUp.gameObject.SetActive(true);\n                break;\n            case SortType.Height:\n                if (sortDescending)\n                    heightArrowDown.gameObject.SetActive(true);\n                if (sortDescending)\n                    heightArrowDown.gameObject.SetActive(true);\n                else\n                    heightArrowUp.gameObject.SetActive(true);\n                break;\n            case SortType.CreationDate:\n                if (sortDescending)\n                    creationDateArrowDown.gameObject.SetActive(true);\n                else\n                    creationDateArrowUp.gameObject.SetActive(true);\n                break;\n            default:\n                // 默认排序，没有箭头显示\n                break;\n        }\n    }\n\n    private void SortResources()\n    {\n        if (currentFilteredResources == null) return;\n\n        switch (currentSortType)\n        {\n            case SortType.ModelFaces:\n                currentFilteredResources = sortDescending\n                    ? currentFilteredResources.OrderByDescending(res => res.ModelFaces).ToList()\n                    : currentFilteredResources.OrderBy(res => res.ModelFaces).ToList();\n                break;\n            case SortType.Height:\n                currentFilteredResources = sortDescending\n                    ? currentFilteredResources.OrderByDescending(res => res.Height).ToList()\n                    : currentFilteredResources.OrderBy(res => res.Height).ToList();\n                break;\n            case SortType.CreationDate:\n                currentFilteredResources = sortDescending\n                    ? currentFilteredResources.OrderByDescending(res => res.CreationDate).ToList()\n                    : currentFilteredResources.OrderBy(res => res.CreationDate).ToList();\n                break;\n            case SortType.Default:\n                currentFilteredResources = sortDescending\n                    ? initialResources.OrderByDescending(res => initialResources.IndexOf(res)).ToList()\n                    : new List<ResourceCardData>(initialResources); // 恢复初始顺序\n                break;\n        }\n\n        currentPage = 0;\n        UpdateCardsOnPage();\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\nResourceCardSpawner 是一个用于管理资源卡片生成、分页浏览和排序的脚本。它在资源管理系统中扮演核心角色，负责根据用户输入和筛选条件动态生成和显示资源卡片，支持分页浏览和多种排序方式。\n\n**主要特性与技术实现：**\n- **资源卡片生成与管理：** 使用Prefab生成卡片实例，动态调整显示内容。\n- **分页浏览：** 支持自定义每页显示数量，通过输入框和按钮实现分页导航。\n- **多维度排序：** 支持按模型面数、高度和创建日期排序，显示排序方向指示箭头。\n- **UI状态更新：** 动态更新分页信息、按钮状态和排序箭头。\n\n### 2. 核心类解析\n\n#### ResourceCardSpawner\n\n- **职责说明：** 管理资源卡片的生成、分页、排序和UI状态更新。\n- **",
    "chunk_order_index": 1,
    "full_doc_id": "doc-9fd9a070f34db436b2711d279afec2bb"
  },
  "chunk-61b8ea6594f79fd6c5b5e8d1dd1d6e10": {
    "tokens": 1111,
    "content": "页显示数量，通过输入框和按钮实现分页导航。\n- **多维度排序：** 支持按模型面数、高度和创建日期排序，显示排序方向指示箭头。\n- **UI状态更新：** 动态更新分页信息、按钮状态和排序箭头。\n\n### 2. 核心类解析\n\n#### ResourceCardSpawner\n\n- **职责说明：** 管理资源卡片的生成、分页、排序和UI状态更新。\n- **关键方法清单：**\n  - `Start()`: 初始化UI事件监听。\n  - `SetFilteredResources(List<ResourceCardData> filteredResources)`: 更新筛选后的资源数据。\n  - `SortResources()`: 根据当前排序类型和方向对资源进行排序。\n  - `UpdateCardsOnPage()`: 清除当前页面卡片并生成新卡片。\n  - `UpdateUI()`: 更新分页信息和按钮状态。\n- **继承关系：** ResourceCardSpawner -> MonoBehaviour\n- **依赖模块：**\n  - UnityEngine.UI（Button、TMP_InputField、TextMeshProUGUI）\n  - UnityEngine.Transform\n  - ResourceCardData、ResourceCardUI\n\n### 3. 关键方法详解\n\n#### `Start()`\n\n- **方法签名：** `void Start()`\n- **功能描述：** 初始化UI组件的事件监听器，包括排序按钮和输入框的回调函数。\n- **调用关系：** 在Unity生命周期中自动调用，初始化所有UI交互逻辑。\n\n#### `SetFilteredResources(List<ResourceCardData> filteredResources)`\n\n- **方法签名：** `public void SetFilteredResources(List<ResourceCardData> filteredResources)`\n- **功能描述：** 更新筛选后的资源数据，重置分页状态并刷新卡片显示。\n- **调用关系：** 由外部调用，如筛选系统完成筛选后调用，更新UI显示。\n\n#### `SortResources()`\n\n- **方法签名：** `private void SortResources()`\n- **功能描述：** 根据当前排序类型和方向对资源数据进行排序。\n- **算法说明：** 使用LINQ的OrderBy和OrderByDescending方法进行排序，支持升序和降序。\n- **调用关系：** 由`SetSortType()`和`ResetSort()`方法调用，触发资源排序和UI更新。\n\n#### `UpdateCardsOnPage()`\n\n- **方法签名：** `private void UpdateCardsOnPage()`\n- **功能描述：** 清除当前页面卡片并生成新卡片实例，设置卡片数据。\n- **调用关系：** 在分页、排序或筛选条件变化后调用，更新当前页面显示。\n\n#### `UpdateUI()`\n\n- **方法签名：** `private void UpdateUI()`\n- **功能描述：** 更新分页信息、按钮状态和排序箭头显示。\n- **调用关系：** 在分页、排序或筛选条件变化后调用，保持UI状态与当前数据一致。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class MonoBehaviour {\n        +string name\n    }\n    class ResourceCardSpawner {\n        -- MonoBehaviour\n        +GameObject resourceCardPrefab\n        +Transform cardsParent\n        +List<ResourceCardData> initialResources\n        +List<ResourceCardData> currentFilteredResources\n        +int currentPage\n        +int cardsPerPage\n        +TMP_InputField pageInputField\n        +TMP_InputField cardsPerPageInputField\n        +Button prevButton\n        +Button nextButton\n        +TextMeshProUGUI totalResourcesText\n        +enum SortType\n        +SortType currentSortType\n        +bool sortDescending\n        +Button defaultSortButton\n        +Button modelFacesSortButton\n        +Button heightSortButton\n        +Button creationDateSortButton\n        +Image modelFacesArrowUp\n        +Image modelFacesArrowDown\n        +Image heightArrowUp\n        +Image heightArrowDown\n        +Image creationDateArrowUp\n        +Image creationDateArrowDown\n        +void Start()\n        +void SetFilteredResources(List<ResourceCardData>)\n        +void SortResources()\n        +void UpdateCardsOnPage()\n        +void UpdateUI()\n    }\n    class ResourceCardData {\n        +string ID\n        +string Name\n        +string Description\n        +float Height\n        +string PrefabPath\n        +string ThumbnailPath\n        +int ModelFaces\n        +DateTime CreationDate\n        +DateTime UpdatedDate\n        +string Version\n        +List<string> TypeTags\n        +List<string> ThemeTags\n        +List<string> FunctionTags\n        +List<string> DefinitionTags\n        +List<string> BatchTags\n        +List<string> PropertyTags\n    }\n    class ResourceCardUI {\n        +void SetupCard(...)\n    }\n    ResourceCardSpawner --> ResourceCardData\n    ResourceCardSpawner --> ResourceCardUI\n    ResourceCardSpawner --> TMP_InputField\n    ResourceCardSpawner --> Button\n    ResourceCardSpawner --> TextMeshProUGUI\n    ResourceCardSpawner --> Image\n```\n\n通过以上分析，ResourceCardSpawner 类实现了资源卡片的动态生成、分页浏览和多维度排序功能，是资源管理系统中的核心组件。",
    "chunk_order_index": 2,
    "full_doc_id": "doc-9fd9a070f34db436b2711d279afec2bb"
  },
  "chunk-63054265269a4dc978b461686e7b0093": {
    "tokens": 11,
    "content": "度排序功能，是资源管理系统中的核心组件。",
    "chunk_order_index": 3,
    "full_doc_id": "doc-9fd9a070f34db436b2711d279afec2bb"
  },
  "chunk-e2214d6656e587eeb1becbfbfca39262": {
    "tokens": 1109,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing TMPro;\n\npublic class SearchHistoryDropdownHandler : MonoBehaviour\n{\n    public TMP_Dropdown searchHistoryDropdown;\n    public ResourceFilterResult resourceFilterResult;\n\n    private void Start()\n    {\n        if (searchHistoryDropdown != null)\n        {\n            searchHistoryDropdown.onValueChanged.AddListener(OnSearchHistorySelected);\n        }\n\n        UpdateDropdownOptions();\n    }\n\n    public void UpdateDropdownOptions()\n    {\n        if (searchHistoryDropdown != null && resourceFilterResult != null)\n        {\n            searchHistoryDropdown.onValueChanged.RemoveListener(OnSearchHistorySelected);\n\n            var searchHistory = resourceFilterResult.GetSearchHistory();\n\n            searchHistoryDropdown.ClearOptions();\n            searchHistoryDropdown.options.Add(new TMP_Dropdown.OptionData(\"\"));\n\n            searchHistoryDropdown.AddOptions(searchHistory);\n            searchHistoryDropdown.value = 0;\n\n            searchHistoryDropdown.onValueChanged.AddListener(OnSearchHistorySelected);\n        }\n    }\n\n    public void OnSearchHistorySelected(int index)\n    {\n        if (index > 0 && resourceFilterResult != null)\n        {\n            var searchHistory = resourceFilterResult.GetSearchHistory();\n            if (index - 1 < searchHistory.Count)\n            {\n                string selectedTerm = searchHistory[index - 1];\n\n                // 将选中的记录填写到Search Input Field和Dropdown的Caption Text中\n                resourceFilterResult.searchInputField.text = selectedTerm;\n                searchHistoryDropdown.captionText.text = selectedTerm;\n            }\n        }\n    }\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n**功能定位：**\nSearchHistoryDropdownHandler 是一个 MonoBehaviour 类，用于管理搜索历史记录的下拉菜单。它负责更新下拉菜单的选项，并在用户选择历史记录时更新搜索输入框。\n\n**在系统中的角色：**\n该类在 UI 交互中扮演重要角色，允许用户快速访问之前的搜索记录，提升用户体验。\n\n**主要特性与技术实现：**\n- 使用 TextMeshPro 的 TMP_Dropdown 组件处理下拉菜单。\n- 通过事件监听器响应用户选择。\n- 依赖 ResourceFilterResult 类获取和更新搜索历史记录。\n\n### 2. 核心类解析\n\n**类名称：SearchHistoryDropdownHandler**\n\n- **职责说明：**\n  管理搜索历史记录的下拉菜单，更新选项并响应用户选择。\n\n- **关键方法清单：**\n  - `void Start()`\n  - `public void UpdateDropdownOptions()`\n  - `public void OnSearchHistorySelected(int index)`\n\n- **继承关系：**\n  SearchHistoryDropdownHandler -> MonoBehaviour\n\n- **依赖模块：**\n  - TMP_Dropdown (TextMeshPro)\n  - ResourceFilterResult\n\n### 3. 关键方法详解\n\n**方法一：void Start()**\n\n- **方法签名：**\n  ```csharp\n  private void Start()\n  ```\n\n- **功能描述：**\n  初始化时设置事件监听器，并调用 UpdateDropdownOptions 更新下拉菜单选项。\n\n- **调用关系：**\n  在 MonoBehaviour 的生命周期中自动调用，频率为一次。\n\n**方法二：public void UpdateDropdownOptions()**\n\n- **方法签名：**\n  ```csharp\n  public void UpdateDropdownOptions()\n  ```\n\n- **功能描述：**\n  更新下拉菜单的选项，包括移除旧选项、获取新搜索历史、添加新选项并重新设置事件监听器。\n\n- **算法说明：**\n  1. 移除现有的事件监听器。\n  2. 获取最新的搜索历史记录。\n  3. 清空当前选项，添加空选项。\n  4. 添加搜索历史到下拉菜单，设置默认选中。\n  5. 重新添加事件监听器。\n\n- **调用关系：**\n  在 Start 方法中调用，以及可能在其他地方（如搜索历史更新时）。\n\n**方法三：public void OnSearchHistorySelected(int index)**\n\n- **方法签名：**\n  ```csharp\n  public void OnSearchHistorySelected(int index)\n  ```\n\n- **功能描述：**\n  处理用户选择的搜索历史记录，更新输入框和下拉菜单的显示文本。\n\n- **算法说明：**\n  1. 检查索引是否有效。\n  2. 获取选中的搜索词。\n  3. 更新输入框和下拉菜单的文本。\n\n- **调用关系：**\n  由 TMP_Dropdown 的 onValueChanged 事件触发，频率取决于用户选择次数。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class SearchHistoryDropdownHandler {\n        +TMP_Dropdown searchHistoryDropdown\n        +ResourceFilterResult resourceFilterResult\n        +void Start()\n        +public void UpdateDropdownOptions()\n        +public void OnSearchHistorySelected(int index)\n    }\n    SearchHistoryDropdownHandler --> TMP_Dropdown\n    SearchHistoryDropdownHandler --> ResourceFilterResult\n```\n\n**图示说明：**\n- SearchHistoryDropdownHandler 依赖于 TMP_Dropdown 和 ResourceFilterResult。\n- 没有继承关系，也没有组合或聚合关系，主要通过依赖关系与其它模块交互。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-e2214d6656e587eeb1becbfbfca39262"
  },
  "chunk-8eed20c5d96f801d524f4e16394ac1fb": {
    "tokens": 9,
    "content": "依赖关系与其它模块交互。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-e2214d6656e587eeb1becbfbfca39262"
  },
  "chunk-8d04a7de44e5281c7b0b4f565cb077e9": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\n\npublic class ResourceFilter : MonoBehaviour\n{\n    private ResourceManager resourceManager;\n\n    private void Awake()\n    {\n        resourceManager = GetComponent<ResourceManager>();\n    }\n\n    public List<ResourceCardData> FilterResources(string[] typeTags, string[] themeTags, string[] functionTags, string[] batchTags, string[] definitionTags, string[] propertyTags, string searchTerm, List<string> idList)\n    {\n        var allResources = resourceManager.GetAllResources();\n\n        var filteredResources = allResources.Where(resource =>\n            (batchTags == null || batchTags.Length == 0 || batchTags.All(tag => resource.BatchTags.Contains(tag))) &&\n            (functionTags == null || functionTags.Length == 0 || functionTags.All(tag => resource.FunctionTags.Contains(tag))) &&\n            (themeTags == null || themeTags.Length == 0 || themeTags.All(tag => resource.ThemeTags.Contains(tag))) &&\n            (typeTags == null || typeTags.Length == 0 || typeTags.All(tag => resource.TypeTags.Contains(tag))) &&\n            (definitionTags == null || definitionTags.Length == 0 || definitionTags.All(tag => resource.DefinitionTags.Contains(tag))) &&\n            (propertyTags == null || propertyTags.Length == 0 || propertyTags.All(tag => resource.PropertyTags.Contains(tag)))\n        ).ToList();\n\n        // 搜索词筛选：包括名称、描述、ID、缩略图路径和所有类型的标签\n        if (!string.IsNullOrEmpty(searchTerm))\n        {\n            searchTerm = searchTerm.ToLower();\n            filteredResources = filteredResources.Where(resource =>\n                resource.Name.ToLower().Contains(searchTerm) ||\n                resource.Description.ToLower().Contains(searchTerm) ||\n                resource.ID.ToLower().Contains(searchTerm) || // 新增ID字段筛选\n                resource.ThumbnailPath.ToLower().Contains(searchTerm) || // 新增缩略图路径筛选\n                resource.TypeTags.Any(tag => tag.ToLower().Contains(searchTerm)) ||\n                resource.ThemeTags.Any(tag => tag.ToLower().Contains(searchTerm)) ||\n                resource.FunctionTags.Any(tag => tag.ToLower().Contains(searchTerm)) ||\n                resource.BatchTags.Any(tag => tag.ToLower().Contains(searchTerm)) ||\n                resource.DefinitionTags.Any(tag => tag.ToLower().Contains(searchTerm)) ||\n                resource.PropertyTags.Any(tag => tag.ToLower().Contains(searchTerm))\n            ).ToList();\n        }\n\n        // ID 列表筛选\n        if (idList != null && idList.Count > 0)\n        {\n            filteredResources = filteredResources.Where(resource => idList.Contains(resource.ID)).ToList();\n        }\n\n        return filteredResources; // 返回过滤后的资源列表\n    }\n\n    // 新增方法：根据资源ID列表获取资源\n    public List<ResourceCardData> GetResourcesByIds(List<string> ids)\n    {\n        var allResources = resourceManager.GetAllResources();\n        return allResources.Where(resource => ids.Contains(resource.ID)).ToList();\n    }\n\n    // 打印符合条件的资源信息\n    public void PrintFilteredResources(List<ResourceCardData> filteredResources)\n    {\n        if (filteredResources == null || filteredResources.Count == 0)\n        {\n            return;\n        }\n        foreach (var resource in filteredResources)\n        {\n            // Debug.Log($\"Name: {resource.Name}, Description: {resource.Description}, Height: {resource.Height},\" +\n            //     $\"Type Tags: {string.Join(\", \", resource.TypeTags)}, Theme Tags: {string.Join(\", \", resource.ThemeTags)},\" +\n            //     $\"Function Tags: {string.Join(\", \", resource.FunctionTags)}, Definition Tags: {string.join(\", \", resource.DefinitionTags)},\" +\n            //     $\"Batch Tags: {string.Join(\", \", resource.BatchTags)}, Property Tags: {string.Join(\", \", resource.PropertyTags)},\" +\n            //     $\"Prefab Path: {resource.PrefabPath}, Thumbnail Path: {resource.ThumbnailPath}\");\n        }\n    }\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n- **功能定位**：`ResourceFilter` 类是一个资源过滤器，用于根据多种标签和条件筛选资源数据。它通过 `ResourceManager` 获取资源数据，并根据类型标签、主题标签、功能标签等进行过滤。\n\n- **角色和重要性**：在系统中，`ResourceFilter` 起着资源管理的核心作用，帮助快速定位和筛选符合条件的资源。这对于资源检索和管理至关重要。\n\n- **主要特性与技术实现**：\n  - 多标签过滤：支持多种标签组合筛选（类型、主题、功能、批次、定义、属性）。\n  - 搜索词过滤：支持基于资源名称、描述、ID和缩略图路径的模糊搜索。\n  - ID列表过滤：支持通过资源ID列表进行精确筛选。\n  - 打印资源信息：用于调试和验证筛选结果。\n  - **技术实现**：使用 LINQ 进行数据筛选，通过依赖 `ResourceManager` 获取资源数据。\n\n---\n\n### 2. 核心类解析\n\n#### `ResourceFilter`\n\n- **职责说明**：`ResourceFilter` 的主要职责是根据给定的条件对资源进行过滤和筛选。它通过 `ResourceManager` 获取资源数据，并根据标签、搜索词和 ID 列表等条件进行多维度筛选。\n\n- **关键方法清单**：\n  - `public List<ResourceCardData> FilterResources(string[] typeTags, string[] themeTags, string[] functionTags, string[] batchTags, string[] definitionTags, string[] propertyTags, string searchTerm, List<string> idList)`\n  - `public",
    "chunk_order_index": 0,
    "full_doc_id": "doc-6a23252cd44482eeda3ca8df322bfbe8"
  },
  "chunk-d7e31560ca9ec4ec68e75a22673609c0": {
    "tokens": 968,
    "content": "对资源进行过滤和筛选。它通过 `ResourceManager` 获取资源数据，并根据标签、搜索词和 ID 列表等条件进行多维度筛选。\n\n- **关键方法清单**：\n  - `public List<ResourceCardData> FilterResources(string[] typeTags, string[] themeTags, string[] functionTags, string[] batchTags, string[] definitionTags, string[] propertyTags, string searchTerm, List<string> idList)`\n  - `public List<ResourceCardData> GetResourcesByIds(List<string> ids)`\n  - `public void PrintFilteredResources(List<ResourceCardData> filteredResources)`\n\n- **继承关系**：\n  ```mermaid\n  ResourceFilter -> MonoBehaviour\n  ```\n\n- **依赖模块**：\n  - `ResourceManager`（通过 `GetComponent<ResourceManager>()` 获取）\n\n---\n\n### 3. 关键方法详解\n\n#### 方法 1：`FilterResources`\n\n- **方法签名**：\n  ```csharp\n  public List<ResourceCardData> FilterResources(string[] typeTags, string[] themeTags, string[] functionTags, string[] batchTags, string[] definitionTags, string[] propertyTags, string searchTerm, List<string> idList)\n  ```\n\n- **功能描述**：\n  根据多个标签数组、搜索词和 ID 列表对资源进行多维度筛选。首先通过标签筛选，然后根据搜索词进行模糊匹配，最后根据 ID 列表进行精确筛选。\n\n- **算法说明**：\n  - 使用 LINQ 的 `Where` 方法进行过滤。\n  - 标签筛选：检查每个标签数组是否为空，如果不为空则要求资源的所有标签都包含指定的标签。\n  - 搜索词筛选：将搜索词转换为小写后，检查资源的名称、描述、ID、缩略图路径和所有标签是否包含搜索词。\n  - ID 列表筛选：仅返回 ID 列表中包含的资源。\n\n- **调用关系**：\n  - 通常由 UI 控制器或用户交互逻辑调用，调用频率较高。\n\n---\n\n#### 方法 2：`GetResourcesByIds`\n\n- **方法签名**：\n  ```csharp\n  public List<ResourceCardData> GetResourcesByIds(List<string> ids)\n  ```\n\n- **功能描述**：\n  根据给定的资源 ID 列表，返回对应的资源数据列表。\n\n- **算法说明**：\n  - 通过LINQ的`Where`方法筛选出 ID 匹配的资源。\n\n- **调用关系**：\n  - 通常由需要快速获取特定资源的模块调用，调用频率中等。\n\n---\n\n#### 方法 3：`PrintFilteredResources`\n\n- **方法签名**：\n  ```csharp\n  public void PrintFilteredResources(List<ResourceCardData> filteredResources)\n  ```\n\n- **功能描述**：\n  打印筛选后的资源信息，用于调试和验证。\n\n- **算法说明**：\n  - 遍历资源列表并使用 `Debug.Log` 输出资源的详细信息。\n\n- **调用关系**：\n  - 通常由开发人员在调试阶段调用，调用频率较低。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class ResourceFilter {\n        +List<ResourceCardData> FilterResources(...)\n        +List<ResourceCardData> GetResourcesByIds(...)\n        +void PrintFilteredResources(...)\n        -ResourceManager resourceManager\n    }\n    class ResourceManager {\n        +List<ResourceCardData> GetAllResources()\n    }\n    class ResourceCardData {\n        +string Name\n        +string Description\n        +string ID\n        +string ThumbnailPath\n        +string[] TypeTags\n        +string[] ThemeTags\n        +string[] FunctionTags\n        +string[] BatchTags\n        +string[] DefinitionTags\n        +string[] PropertyTags\n        +string PrefabPath\n    }\n    ResourceFilter --> ResourceManager :GetComponent\n    ResourceFilter --> ResourceCardData :List of\n```\n\n---\n\n### 总结\n\n`ResourceFilter` 类通过多维度的标签、搜索词和 ID 筛选功能，为资源管理提供了灵活且高效的支持。它在系统中扮演着资源检索的核心角色，依赖 `ResourceManager` 获取资源数据，并通过 LINQ 实现高效的过滤逻辑。通过清晰的继承关系和依赖管理，`ResourceFilter` 确保了系统的模块化和可维护性。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-6a23252cd44482eeda3ca8df322bfbe8"
  },
  "chunk-9648700e5cbcfc442d0088814b10eeae": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEditor;\n\npublic class MultipleTagButtonCreator : MonoBehaviour\n{\n    // 六个TagLibrary的引用，每个都对应一个资源文件\n    public TagLibrary typeTagLibrary;\n    public TagLibrary themeTagLibrary;\n    public TagLibrary functionTagLibrary;\n    public TagLibrary batchTagLibrary;\n    public TagLibrary propertyTagLibrary;\n    public TagLibrary definitionTagLibrary;\n\n    // 六种类型的按钮预制体\n    public GameObject typeButtonPrefab;\n    public GameObject themeButtonPrefab;\n    public GameObject functionButtonPrefab;\n    public GameObject batchButtonPrefab;\n    public GameObject propertyButtonPrefab;\n    public GameObject definitionButtonPrefab;\n\n    // 六个按钮父对象的引用，每个都对应一个UI面板\n    public Transform typeButtonParent;\n    public Transform themeButtonParent;\n    public Transform functionButtonParent;\n    public Transform batchButtonParent;\n    public Transform propertyButtonParent;\n    public Transform definitionButtonParent;\n\n    // ResourceFilterResult的引用\n    public ResourceFilterResult filterResult;\n\n    // 用于更改按钮颜色的字段\n    public Color selectedColor = Color.green;\n\n    // 存储所有标签按钮的字典\n    private Dictionary<string, (Button button, Color originalColor)> tagButtons = new Dictionary<string, (Button, Color)>();\n\n    private void Start()\n    {\n        if (filterResult == null)\n        {\n            Debug.LogError(\"ResourceFilterResult 引用未设置。\");\n            return;\n        }\n\n        // 动态创建按钮\n        CreateButtonsForLibrary(typeTagLibrary, typeButtonPrefab, typeButtonParent, \"type\");\n        CreateButtonsForLibrary(themeTagLibrary, themeButtonPrefab, themeButtonParent, \"theme\");\n        CreateButtonsForLibrary(functionTagLibrary, functionButtonPrefab, functionButtonParent, \"function\");\n        CreateButtonsForLibrary(batchTagLibrary, batchButtonPrefab, batchButtonParent, \"batch\");\n        CreateButtonsForLibrary(propertyTagLibrary, propertyButtonPrefab, propertyButtonParent, \"property\");\n        CreateButtonsForLibrary(definitionTagLibrary, definitionButtonPrefab, definitionButtonParent, \"definition\");\n    }\n\n    // 新增方法：根据给定的标签集合更新按钮的可见性\n    public void UpdateTagButtonVisibility(HashSet<string> visibleTags)\n    {\n        foreach (KeyValuePair<string, (Button button, Color originalColor)> tagButtonPair in tagButtons)\n        {\n            // 如果visibleTags包含这个标签，那么按钮应该显示，否则隐藏\n            tagButtonPair.Value.button.gameObject.SetActive(visibleTags.Contains(tagButtonPair.Key));\n        }\n    }\n\n    // 对指定的TagLibrary创建按钮的方法\n    private void CreateButtonsForLibrary(TagLibrary tagLibrary, GameObject buttonPrefab, Transform buttonParent, string tagType)\n    {\n        if (tagLibrary == null || buttonPrefab == null || buttonParent == null)\n        {\n            Debug.LogError(\"请确保所有引用都已正确设置。\");\n            return;\n        }\n\n        // 清除旧的按钮\n        foreach (Transform child in buttonParent)\n        {\n            Destroy(child.gameObject);\n        }\n\n        // 为每个标签创建按钮\n        foreach (var tag in tagLibrary.Tags)\n        {\n            GameObject buttonObj = Instantiate(buttonPrefab, buttonParent);\n            var textComponent = buttonObj.GetComponentInChildren<TextMeshProUGUI>();\n            var button = buttonObj.GetComponent<Button>();\n            var buttonImage = buttonObj.GetComponent<Image>();\n            if (textComponent != null && button != null)\n            {\n                textComponent.text = tag;\n                Color originalColor = buttonImage.color;  // 保存初始颜色\n                button.onClick.AddListener(() => ToggleTagAndFilter(tag, buttonImage, originalColor, tagType));\n\n                // 保存按钮状态\n                tagButtons[tag] = (button, originalColor);\n            }\n            else\n            {\n                Debug.LogError(\"预制体上没有找到TextMeshProUGUI或Button组件。\");\n            }\n        }\n    }\n\n    // 切换标签并更新筛选结果的方法\n    private void ToggleTagAndFilter(string tag, Image buttonImage, Color originalColor, string tagType)\n    {\n        List<string> updatedTags = new List<string>();\n\n        // 根据传递的tagType选择正确的标签数组\n        switch (tagType)\n        {\n            case \"type\":\n                updatedTags = filterResult.typeTag.ToList();\n                break;\n            case \"theme\":\n                updatedTags = filterResult.themeTag.ToList();\n                break;\n            case \"function\":\n                updatedTags = filterResult.functionTag.ToList();\n                break;\n            case \"batch\":\n                updatedTags = filterResult.batchTag.ToList();\n                break;\n            case \"property\":\n                updatedTags = filterResult.propertyTag.ToList();\n                break;\n            case \"definition\":\n                updatedTags = filterResult.definitionTag.ToList();\n                break;\n        }\n\n        // 添加或移除标签，并更新按钮颜色\n        if (!updatedTags.Contains(tag))\n        {\n            updatedTags.Add(tag);\n            buttonImage.color = selectedColor;\n        }\n        else\n        {\n            updatedTags.Remove(tag);\n            buttonImage.color = originalColor; // 恢复到原始颜色\n        }\n\n        // 将更新后的标签数组保存回对应的标签字段\n        switch (tagType)\n        {\n            case \"type\":\n                filterResult.typeTag = updatedTags.ToArray();\n                break;\n            case \"theme\":\n                filterResult.themeTag = updatedTags.ToArray();\n                break;\n            case \"function\":\n                filterResult.functionTag = updatedTags.ToArray();\n                break;\n            case \"batch\":\n                filterResult.batchTag = updatedTags.ToArray",
    "chunk_order_index": 0,
    "full_doc_id": "doc-bf7d8ae9907921df8cae7cf9bc0961b3"
  },
  "chunk-396bafa0ab003b6574e8c8184b199ea4": {
    "tokens": 1200,
    "content": "原始颜色\n        }\n\n        // 将更新后的标签数组保存回对应的标签字段\n        switch (tagType)\n        {\n            case \"type\":\n                filterResult.typeTag = updatedTags.ToArray();\n                break;\n            case \"theme\":\n                filterResult.themeTag = updatedTags.ToArray();\n                break;\n            case \"function\":\n                filterResult.functionTag = updatedTags.ToArray();\n                break;\n            case \"batch\":\n                filterResult.batchTag = updatedTags.ToArray();\n                break;\n            case \"property\":\n                filterResult.propertyTag = updatedTags.ToArray();\n                break;\n            case \"definition\":\n                filterResult.definitionTag = updatedTags.ToArray();\n                break;\n        }\n\n        filterResult.FilterAndPrintResources();\n    }\n\n    // 重置所有标签按钮状态的方法\n    public void ResetAllTagButtonStates()\n    {\n        foreach (var tagButtonPair in tagButtons)\n        {\n            tagButtonPair.Value.button.interactable = true;\n            tagButtonPair.Value.button.image.color = tagButtonPair.Value.originalColor;\n        }\n    }\n}\n\n\n\n源代码内容解释如下：\n### 1. 功能概览\n\n**功能定位：**  \n`MultipleTagButtonCreator` 是一个用于动态创建和管理标签按钮的脚本，支持通过点击按钮切换标签状态，并根据标签状态过滤资源。它在资源管理与展示系统中扮演核心角色，提供灵活的标签筛选功能。\n\n**系统角色：**  \n该脚本负责将标签数据转换为UI按钮，并通过按钮交互控制资源过滤逻辑，是用户与系统交互的重要接口。\n\n**主要特性与技术实现：**  \n- **动态按钮生成：** 根据不同的标签库动态创建按钮，支持六种不同类型的标签。\n- **状态管理：** 维护按钮的选中状态，并通过颜色变化提供视觉反馈。\n- **过滤机制：** 集成 `ResourceFilterResult` 实现资源过滤逻辑。\n- **工厂模式：** 使用预制体快速生成按钮实例。\n- **事件驱动：** 通过按钮点击事件触发标签切换和过滤操作。\n\n---\n\n### 2. 核心类解析\n\n**类名称：** `MultipleTagButtonCreator`\n\n**职责说明：**  \n- 动态生成不同类型的标签按钮。\n- 管理按钮的交互状态和视觉反馈。\n- 根据标签状态更新资源过滤结果。\n\n**关键方法清单：**  \n- `public void UpdateTagButtonVisibility(HashSet<string> visibleTags)`：更新按钮可见性。\n- `private void CreateButtonsForLibrary(TagLibrary tagLibrary, GameObject buttonPrefab, Transform buttonParent, string tagType)`：生成指定标签库的按钮。\n- `private void ToggleTagAndFilter(string tag, Image buttonImage, Color originalColor, string tagType)`：切换标签并更新过滤结果。\n- `public void ResetAllTagButtonStates()`：重置所有按钮状态。\n\n**继承关系：**  \n```mermaid\nclassDiagram\n    class MultipleTagButtonCreator {\n        +MonoBehaviour\n    }\n```\n\n**依赖模块：**  \n- `TagLibrary`：存储不同类型的标签数据。\n- `ResourceFilterResult`：处理资源过滤逻辑。\n- `UnityEngine.UI`：提供按钮和UI组件功能。\n- `TextMeshPro`：用于文本显示。\n\n---\n\n### 3. 关键方法详解\n\n#### 方法一：`UpdateTagButtonVisibility`\n\n**方法签名：**  \n```csharp\npublic void UpdateTagButtonVisibility(HashSet<string> visibleTags)\n```\n\n**功能描述：**  \n根据传入的可见标签集合，动态控制按钮的显示或隐藏。  \n- 如果按钮对应的标签在集合中，则显示按钮；否则隐藏。\n\n**调用关系：**  \n通常由资源管理模块调用，频率取决于过滤操作的触发频率（如用户筛选设置变化）。\n\n---\n\n#### 方法二：`CreateButtonsForLibrary`\n\n**方法签名：**  \n```csharp\nprivate void CreateButtonsForLibrary(TagLibrary tagLibrary, GameObject buttonPrefab, Transform buttonParent, string tagType)\n```\n\n**功能描述：**  \n根据指定的标签库生成按钮，并绑定点击事件。  \n- 清除旧按钮。\n- 遍历标签库中的每个标签，生成按钮并设置文本。\n- 将按钮状态存储到字典中，以便后续管理。\n\n**算法说明：**  \n- 使用工厂模式生成按钮实例。\n- 通过预制体快速复用按钮样式和组件。\n\n**调用关系：**  \n在 `Start` 方法中被调用，生成所有类型的标签按钮。\n\n---\n\n#### 方法三：`ToggleTagAndFilter`\n\n**方法签名：**  \n```csharp\nprivate void ToggleTagAndFilter(string tag, Image buttonImage, Color originalColor, string tagType)\n```\n\n**功能描述：**  \n切换标签状态并更新按钮颜色。  \n- 根据标签类型从 `ResourceFilterResult` 中获取标签数组。\n- 添加或移除当前标签，并更新按钮颜色。\n- 调用 `FilterAndPrintResources` 执行资源过滤。\n\n**算法说明：**  \n- 使用 `switch` 语句处理不同标签类型。\n- 通过颜色变化提供直观的视觉反馈。\n\n**调用关系：**  \n由按钮的点击事件触发，频率取决于用户的交互操作。\n\n---\n\n#### 方法四：`ResetAllTagButtonStates`\n\n**方法签名：**  \n```csharp\npublic void ResetAllTagButtonStates()\n```\n\n**功能描述：**  \n重置所有按钮的状态，包括颜色和交互性。  \n- 恢",
    "chunk_order_index": 1,
    "full_doc_id": "doc-bf7d8ae9907921df8cae7cf9bc0961b3"
  },
  "chunk-313598e398c7b81aca0cdb45f0b11df0": {
    "tokens": 552,
    "content": "语句处理不同标签类型。\n- 通过颜色变化提供直观的视觉反馈。\n\n**调用关系：**  \n由按钮的点击事件触发，频率取决于用户的交互操作。\n\n---\n\n#### 方法四：`ResetAllTagButtonStates`\n\n**方法签名：**  \n```csharp\npublic void ResetAllTagButtonStates()\n```\n\n**功能描述：**  \n重置所有按钮的状态，包括颜色和交互性。  \n- 恢复按钮的原始颜色。\n- 重新启用所有按钮的交互功能。\n\n**调用关系：**  \n通常在过滤操作完成后调用，频率较低。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class MultipleTagButtonCreator {\n        +TagLibrary typeTagLibrary\n        +TagLibrary themeTagLibrary\n        +TagLibrary functionTagLibrary\n        +TagLibrary batchTagLibrary\n        +TagLibrary propertyTagLibrary\n        +TagLibrary definitionTagLibrary\n        +GameObject typeButtonPrefab\n        +GameObject themeButtonPrefab\n        +GameObject functionButtonPrefab\n        +GameObject batchButtonPrefab\n        +GameObject propertyButtonPrefab\n        +GameObject definitionButtonPrefab\n        +Transform typeButtonParent\n        +Transform themeButtonParent\n        +Transform functionButtonParent\n        +Transform batchButtonParent\n        +Transform propertyButtonParent\n        +Transform definitionButtonParent\n        +ResourceFilterResult filterResult\n        +Color selectedColor\n        +Dictionary<string, (Button, Color)> tagButtons\n        +void Start()\n        +void UpdateTagButtonVisibility(HashSet<string> visibleTags)\n        +void CreateButtonsForLibrary(TagLibrary, GameObject, Transform, string)\n        +void ToggleTagAndFilter(string, Image, Color, string)\n        +void ResetAllTagButtonStates()\n    }\n    class TagLibrary {\n        +List<string> Tags\n    }\n    class ResourceFilterResult {\n        +string[] typeTag\n        +string[] themeTag\n        +string[] functionTag\n        +string[] batchTag\n        +string[] propertyTag\n        +string[] definitionTag\n        +void FilterAndPrintResources()\n    }\n    class GameObject {}\n    class Transform {}\n    class Button {}\n    class Image {}\n    class TextMeshProUGUI {}\n    MultipleTagButtonCreator --> TagLibrary\n    MultipleTagButtonCreator --> ResourceFilterResult\n    MultipleTagButtonCreator --> GameObject\n    MultipleTagButtonCreator --> Transform\n    MultipleTagButtonCreator --> Button\n    MultipleTagButtonCreator --> Image\n    MultipleTagButtonCreator --> TextMeshProUGUI\n```",
    "chunk_order_index": 2,
    "full_doc_id": "doc-bf7d8ae9907921df8cae7cf9bc0961b3"
  },
  "chunk-679c851e6dd7b7f5f4f50502d86436ad": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Linq;\n\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\n\npublic class SelectedCardUI : MonoBehaviour\n{\n    public TextMeshProUGUI idText;\n    public TextMeshProUGUI nameText;\n    public TextMeshProUGUI descriptionText;\n    public TextMeshProUGUI heightText;\n    public TextMeshProUGUI versionText;\n    public TextMeshProUGUI prefabPathText;\n    public Image thumbnailImage;\n    public TextMeshProUGUI typeTagsText;\n    public TextMeshProUGUI themeTagsText;\n    public TextMeshProUGUI functionTagsText;\n    public TextMeshProUGUI definitionTagsText;\n    public TextMeshProUGUI batchTagsText;\n    public TextMeshProUGUI propertyTagsText;\n    public TextMeshProUGUI modelFacesText;\n    public TextMeshProUGUI creationDateText;\n    public TextMeshProUGUI updatedDateText;\n    public Button deleteButton;\n\n    public GameObject targetParent;\n\n    public GameObject distinctionUIInstance;\n    public GameObject pathErrorUIInstance;\n\n    public ItemDetailsDisplay itemDetailsDisplay;\n\n    private static SelectedCardUI currentSelectedCard;\n\n    void Start()\n    {\n        if (distinctionUIInstance != null)\n        {\n            distinctionUIInstance.SetActive(false);\n        }\n        if (pathErrorUIInstance != null)\n        {\n            pathErrorUIInstance.SetActive(false);\n        }\n    }\n\n    public void SetupCard(\n        string id,\n        string name,\n        string description,\n        string height,\n        string version,\n        string prefabPath,\n        string thumbnailPath,\n        string typeTags,\n        string themeTags,\n        string functionTags,\n        string definitionTags,\n        string batchTags,\n        string propertyTags,\n        string modelFaces,\n        string creationDate,\n        string updatedDate\n    )\n    {\n        idText.text = id;\n        nameText.text = name;\n        descriptionText.text = description;\n        heightText.text = $\"{height:F2}\";\n        versionText.text = version;\n        prefabPathText.text = prefabPath;\n        typeTagsText.text = typeTags;\n        themeTagsText.text = themeTags;\n        functionTagsText.text = functionTags;\n        definitionTagsText.text = definitionTags;\n        batchTagsText.text = batchTags;\n        propertyTagsText.text = propertyTags;\n        modelFacesText.text = modelFaces;\n        creationDateText.text = creationDate;\n        updatedDateText.text = updatedDate;\n\n        // 在运行时和编辑器中使用不同的方式加载图片\n        thumbnailImage.sprite = LoadSpriteFromPath(thumbnailPath);\n\n        deleteButton.gameObject.SetActive(false);\n        deleteButton.onClick.AddListener(OnDeleteButtonClicked);\n\n        if (pathErrorUIInstance != null)\n        {\n            pathErrorUIInstance.SetActive(false);\n        }\n    }\n\n    private Sprite LoadSpriteFromPath(string thumbnailPath)\n    {\n#if UNITY_EDITOR\n        string pathForLoading = \"Assets/ZTResource/Resources/ZT_IconTextures/\" + thumbnailPath + \".png\";\n        Texture2D texture = AssetDatabase.LoadAssetAtPath<Texture2D>(pathForLoading);\n        if (texture == null)\n        {\n            Debug.LogError(\"Failed to load texture at path: \" + pathForLoading);\n            return null;\n        }\n        return Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f));\n#else\n        string resourcePath = \"ZT_IconTextures/\" + thumbnailPath;\n        Texture2D texture = Resources.Load<Texture2D>(resourcePath);\n        if (texture == null)\n        {\n            Debug.LogError(\"Failed to load texture from Resources: \" + resourcePath);\n            return null;\n        }\n        return Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f));\n#endif\n    }\n\n    public void OnCardClicked()\n    {\n        itemDetailsDisplay.DisplayItemDetails(\n            idText.text,\n            nameText.text,\n            descriptionText.text,\n            heightText.text,\n            modelFacesText.text,\n            creationDateText.text,\n            updatedDateText.text,\n            versionText.text,\n            propertyTagsText.text\n        );\n\n#if UNITY_EDITOR\n        if (!string.IsNullOrEmpty(prefabPathText.text))\n        {\n            string assetPath = prefabPathText.text;\n            var asset = AssetDatabase.LoadAssetAtPath<GameObject>(assetPath);\n            if (asset != null)\n            {\n                Selection.activeObject = asset;\n                EditorGUIUtility.PingObject(asset);\n            }\n            else\n            {\n                Debug.LogError(\"Cannot find asset at path: \" + assetPath);\n                ShowPathErrorUI();\n            }\n        }\n#endif\n\n        if (targetParent == null)\n        {\n            return;\n        }\n\n        bool isAlreadyAdded = targetParent.transform.Cast<Transform>().Any(child => child.name == prefabPathText.text);\n\n        if (isAlreadyAdded)\n        {\n            return;\n        }\n\n        foreach (Transform child in targetParent.transform)\n        {\n            Destroy(child.gameObject);\n        }\n\n#if UNITY_EDITOR\n        string resourcePath = prefabPathText.text;\n        GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(resourcePath);\n        if (prefab != null)\n        {\n            GameObject instantiatedPrefab = Instantiate(prefab, targetParent.transform.position, Quaternion.identity, targetParent.transform);\n            instantiatedPrefab.name = nameText.text;\n        }\n#endif\n\n        if (currentSelectedCard != null)\n        {\n            currentSelectedCard.deleteButton.gameObject.SetActive(false);\n        }\n\n        currentSelectedCard = this;\n        deleteButton.gameObject.SetActive(true);\n    }\n\n    private",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b81ceae76ef2565c36542eb9977669f1"
  },
  "chunk-4745a76e078e277ff439780d2c07fce6": {
    "tokens": 1200,
    "content": ".LoadAssetAtPath<GameObject>(resourcePath);\n        if (prefab != null)\n        {\n            GameObject instantiatedPrefab = Instantiate(prefab, targetParent.transform.position, Quaternion.identity, targetParent.transform);\n            instantiatedPrefab.name = nameText.text;\n        }\n#endif\n\n        if (currentSelectedCard != null)\n        {\n            currentSelectedCard.deleteButton.gameObject.SetActive(false);\n        }\n\n        currentSelectedCard = this;\n        deleteButton.gameObject.SetActive(true);\n    }\n\n    private void OnDeleteButtonClicked()\n    {\n        CardInfo cardToRemove = SelectedCardSpawner.Instance.ExistingCards.FirstOrDefault(card => card.Name == nameText.text);\n\n        if (cardToRemove != null)\n        {\n            SelectedCardSpawner.Instance.RemoveCardInfo(cardToRemove);\n        }\n\n        Destroy(gameObject);\n        currentSelectedCard = null;\n    }\n\n    public void SetDistinctionUIVisibility(bool isVisible)\n    {\n        if (distinctionUIInstance != null)\n        {\n            distinctionUIInstance.SetActive(isVisible);\n        }\n    }\n\n    public void SetPathErrorUIVisibility(bool isVisible)\n    {\n        if (pathErrorUIInstance != null)\n        {\n            pathErrorUIInstance.SetActive(isVisible);\n        }\n    }\n\n    public void ShowPathErrorUI()\n    {\n        if (pathErrorUIInstance != null)\n        {\n            pathErrorUIInstance.SetActive(true);\n        }\n    }\n\n    public void HidePathErrorUI()\n    {\n        if (pathErrorUIInstance != null)\n        {\n            pathErrorUIInstance.SetActive(false);\n        }\n    }\n}\n\n源代码内容解释如下：\n```markdown\n# 分析报告：SelectedCardUI 类\n\n## 1. 功能概览\n\n### 功能定位\n`SelectedCardUI` 类是一个 MonoBehaviour，主要负责在 Unity 场景中显示和管理选中的卡片信息。它通过 UI 组件展示卡片的详细属性，包括 ID、名称、描述、版本、缩略图等。\n\n### 系统角色\n该类在卡片选择和显示系统中扮演核心角色，是用户与卡片数据交互的主要界面。它不仅展示数据，还处理用户点击行为和删除操作，确保数据的准确性和一致性。\n\n### 主要特性\n- **卡片信息显示**：通过 TextMeshPro 和 Unity UI 组件展示多维度卡片数据。\n- **缩略图加载**：支持在 Unity 编辑器和运行时环境中从不同路径加载图片。\n- **用户交互**：响应点击事件，展示详细信息，管理删除操作。\n- **错误处理**：显示路径错误提示，确保用户获得反馈。\n\n### 技术实现\n- 使用 TextMeshProUGUI 和 Image 组件进行 UI 展示。\n- 通过 `LoadSpriteFromPath` 方法在不同环境中加载资源。\n- 单例模式管理当前选中的卡片实例。\n\n## 2. 核心类解析\n\n### 类名称\n`SelectedCardUI`\n\n#### 职责说明\n管理选中的卡片信息显示，处理用户交互，包括点击和删除操作，同时管理错误提示UI的显示。\n\n#### 关键方法清单\n```csharp\npublic void SetupCard(string id, string name, string description, ...)\npublic void OnCardClicked()\npublic void OnDeleteButtonClicked()\nprivate Sprite LoadSpriteFromPath(string thumbnailPath)\npublic void SetDistinctionUIVisibility(bool isVisible)\npublic void SetPathErrorUIVisibility(bool isVisible)\npublic void ShowPathErrorUI()\npublic void HidePathErrorUI()\n```\n\n#### 继承关系\n```mermaid\ngraph TD;\n    SelectedCardUI --> MonoBehaviour\n```\n\n#### 依赖模块\n- `UnityEngine`\n- `UnityEngine.UI`\n- `TextMeshPro`\n- `System.Linq`\n- `ItemDetailsDisplay`\n- `SelectedCardSpawner`\n\n## 3. 关键方法详解\n\n### 3.1 SetupCard\n#### 方法签名\n```csharp\npublic void SetupCard(string id, string name, string description, ...)\n```\n\n#### 功能描述\n设置卡片的显示内容，接收大量参数并将它们分配到对应的 UI 组件中。同时加载缩略图。\n\n#### 算法说明\n直接赋值参数到 UI 组件，并调用 `LoadSpriteFromPath` 加载缩略图。\n\n#### 调用关系\n- 被 `SelectedCardSpawner` 或其他卡片管理类调用，频率较高。\n\n### 3.2 OnCardClicked\n#### 方法签名\n```csharp\npublic void OnCardClicked()\n```\n\n#### 功能描述\n处理卡片点击事件，显示详细信息。在 Unity 编辑器中加载预制体，在运行时实例化预制体，并管理删除按钮的显示。\n\n#### 算法说明\n调用 `ItemDetailsDisplay.DisplayItemDetails` 显示详细信息，检查并加载预制体，管理删除按钮可见性。\n\n#### 调用关系\n- 由 Unity UI 系统调用，频率取决于用户点击操作。\n\n### 3.3 OnDeleteButtonClicked\n#### 方法签名\n```csharp\npublic void OnDeleteButtonClicked()\n```\n\n#### 功能描述\n处理删除按钮点击事件，从管理器中移除卡片信息，并销毁当前 GameObject。\n\n#### 算法说明\n查找并移除卡片信息，销毁自身实例。\n\n#### 调用关系\n- 由删除按钮的点击事件触发，频率较低。\n\n### 3.4 LoadSpriteFromPath\n#### 方法签名\n```csharp\nprivate Sprite LoadSpriteFromPath(string thumbnailPath)\n```\n\n#### 功能描述\n根据路径加载图片，返回 Sprite 对象。\n\n#### 算",
    "chunk_order_index": 1,
    "full_doc_id": "doc-b81ceae76ef2565c36542eb9977669f1"
  },
  "chunk-9a4cb49a370adf71db4e8cb002f38ad1": {
    "tokens": 287,
    "content": "卡片信息，并销毁当前 GameObject。\n\n#### 算法说明\n查找并移除卡片信息，销毁自身实例。\n\n#### 调用关系\n- 由删除按钮的点击事件触发，频率较低。\n\n### 3.4 LoadSpriteFromPath\n#### 方法签名\n```csharp\nprivate Sprite LoadSpriteFromPath(string thumbnailPath)\n```\n\n#### 功能描述\n根据路径加载图片，返回 Sprite 对象。\n\n#### 算法说明\n根据 Unity 环境不同，使用 `AssetDatabase` 或 `Resources.Load` 加载资源，处理加载失败的情况。\n\n#### 调用关系\n- 被 `SetupCard` 调用，频率较高。\n\n## 4. 架构关系图\n\n```mermaid\ngraph TD;\n    SelectedCardUI --> MonoBehaviour;\n    SelectedCardUI --> ItemDetailsDisplay;\n    SelectedCardUI --> SelectedCardSpawner;\n    SelectedCardUI --> TextMeshProUGUI;\n    SelectedCardUI --> Image;\n    SelectedCardUI --> Button;\n```\n\n## 总结\n\n`SelectedCardUI` 类是一个综合性的 UI 管理器，负责卡片信息的显示和用户交互。它通过直接的字段赋值和复杂的资源加载逻辑，确保卡片信息的准确展示，并通过事件处理机制响应用户操作，是项目中不可或缺的一部分。",
    "chunk_order_index": 2,
    "full_doc_id": "doc-b81ceae76ef2565c36542eb9977669f1"
  },
  "chunk-8f3da44ef4863ae4f52ebc4b29762b7a": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n\n\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SelectedCardSpawner : MonoBehaviour\n{\n    public GameObject selectedCardPrefab;\n    public Transform contentParent;\n    private List<CardInfo> existingCards = new List<CardInfo>();\n\n    public static SelectedCardSpawner Instance { get; private set; }\n\n    void Awake()\n    {\n        if (Instance == null)\n        {\n            Instance = this;\n        }\n        else\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    public List<CardInfo> ExistingCards => existingCards;\n\n    public void SpawnSelectedCard(\n        string id,\n        string name,\n        string description,\n        string height,\n        string version,\n        string prefabPath,\n        string thumbnailPath, // 确保传递缩略图路径\n        string typeTags,\n        string themeTags,\n        string functionTags,\n        string definitionTags,\n        string batchTags,\n        string propertyTags,\n        string modelFaces,\n        string creationDate,\n        string updatedDate\n    )\n    {\n\n        CardInfo newCard = new CardInfo(\n            id,\n            name,\n            description,\n            height,\n            version,\n            prefabPath,\n            thumbnailPath,\n            typeTags,\n            themeTags,\n            functionTags,\n            definitionTags,\n            batchTags,\n            propertyTags,\n            modelFaces,\n            creationDate,\n            updatedDate\n        );\n\n        // 检查是否已经存在完全相同的卡片\n        if (existingCards.Contains(newCard))\n        {\n            return;\n        }\n\n        // 不存在完全相同的卡片，进行实例化和设置\n        GameObject selectedCard = Instantiate(selectedCardPrefab, contentParent);\n        SelectedCardUI selectedCardUI = selectedCard.GetComponent<SelectedCardUI>();\n        if (selectedCardUI != null)\n        {\n            selectedCardUI.SetupCard(\n                id,\n                name,\n                description,\n                height,\n                version,\n                prefabPath,\n                thumbnailPath, // 确保传递缩略图路径\n                typeTags,\n                themeTags,\n                functionTags,\n                definitionTags,\n                batchTags,\n                propertyTags,\n                modelFaces,\n                creationDate,\n                updatedDate\n            );\n            existingCards.Add(newCard); // 添加到已存在卡片列表中\n        }\n    }\n\n\n    public void RemoveCardInfo(CardInfo cardInfo)\n    {\n        if (existingCards.Contains(cardInfo))\n        {\n            existingCards.Remove(cardInfo);\n        }\n    }\n\n    public void DeleteAllCards()\n    {\n        // 遍历contentParent的所有子物体并销毁它们\n        foreach (Transform child in contentParent)\n        {\n            Destroy(child.gameObject);\n        }\n\n        // 清空维护已存在卡片的列表\n        existingCards.Clear();\n    }\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n**功能定位**  \n`SelectedCardSpawner` 是一个负责在 Unity 场景中生成和管理选中卡片实例的类。它主要用于展示和维护卡片信息，确保卡片实例的唯一性和有序性。\n\n**角色和重要性**  \n这个类在系统中扮演卡片展示管理者的角色，确保卡片信息的正确性和一致性。它通过单例模式（Singleton Pattern）提供全局访问，避免重复实例化，确保系统资源的高效利用和稳定性。\n\n**主要特性与技术实现**  \n- **单例模式**：确保只有一个实例存在，保证全局唯一性。  \n- **卡片实例化**：根据提供的参数生成卡片实例，并设置其属性。  \n- **重复检查**：避免生成重复的卡片实例，确保卡片信息的唯一性。  \n- **卡片删除**：支持删除单个卡片实例或所有卡片实例，清理资源。\n\n### 2. 核心类解析\n\n**类名称**：`SelectedCardSpawner`  \n\n- **职责说明**：  \n  该类的主要职责是管理选中卡片的生成和删除。它通过单例模式提供全局访问，确保卡片实例的唯一性和有序性。  \n\n- **关键方法清单**：  \n  - `public void SpawnSelectedCard(...)`：生成新的卡片实例。  \n  - `public void RemoveCardInfo(CardInfo cardInfo)`：删除指定的卡片信息。  \n  - `public void DeleteAllCards()`：删除所有卡片实例并清理数据。  \n\n- **继承关系**：  \n  `SelectedCardSpawner -> MonoBehaviour`  \n\n- **依赖模块**：  \n  - `UnityEngine`：用于游戏对象操作和 Unity 引擎功能。  \n\n### 3. 关键方法详解\n\n#### 方法 1：`public void SpawnSelectedCard(...)`\n\n- **方法签名**：  \n  ```csharp\n  public void SpawnSelectedCard(\n      string id,\n      string name,\n      string description,\n      string height,\n      string version,\n      string prefabPath,\n      string thumbnailPath,\n      string typeTags,\n      string themeTags,\n      string functionTags,\n      string definitionTags,\n      string batchTags,\n      string propertyTags,\n      string modelFaces,\n      string creationDate,\n      string updatedDate\n  )\n  ```\n\n- **功能描述**：  \n  该方法根据提供的参数生成一个新的卡片实例，并将其添加到现有的卡片列表中。它首先检查是否已经存在完全相同的卡片，如果存在则跳过生成；否则，生成新的卡片实例并设置其属性。\n\n- **算法说明**：  \n  使用 `CardInfo` 类的 `Contains` 方法检查是否存在",
    "chunk_order_index": 0,
    "full_doc_id": "doc-6aa6f965efffd14a282c990f9bc669eb"
  },
  "chunk-6cbc580be92b87005b19b72d38fcfac1": {
    "tokens": 646,
    "content": "creationDate,\n      string updatedDate\n  )\n  ```\n\n- **功能描述**：  \n  该方法根据提供的参数生成一个新的卡片实例，并将其添加到现有的卡片列表中。它首先检查是否已经存在完全相同的卡片，如果存在则跳过生成；否则，生成新的卡片实例并设置其属性。\n\n- **算法说明**：  \n  使用 `CardInfo` 类的 `Contains` 方法检查是否存在重复卡片。如果不存在，则实例化卡片Prefab，并调用 `SelectedCardUI` 的 `SetupCard` 方法设置卡片属性。\n\n- **调用关系**：  \n  通常在需要生成新卡片时调用，例如用户选择一张新卡片或系统需要展示新卡片信息时。调用频率取决于卡片生成的频率。\n\n#### 方法 2：`public void RemoveCardInfo(CardInfo cardInfo)`\n\n- **方法签名**：  \n  ```csharp\n  public void RemoveCardInfo(CardInfo cardInfo)\n  ```\n\n- **功能描述**：  \n  该方法从现有的卡片列表中删除指定的卡片信息。它主要用于清理不再需要的卡片数据。\n\n- **算法说明**：  \n  使用 `List<CardInfo>` 的 `Remove` 方法从列表中删除指定的卡片信息。\n\n- **调用关系**：  \n  通常在需要删除单个卡片时调用，例如用户取消选择一张卡片或系统需要清理过时的卡片信息时。调用频率取决于卡片删除的频率。\n\n#### 方法 3：`public void DeleteAllCards()`\n\n- **方法签名**：  \n  ```csharp\n  public void DeleteAllCards()\n  ```\n\n- **功能描述**：  \n  该方法删除所有现有的卡片实例，并清空维护卡片信息的列表。它用于批量清理所有卡片数据。\n\n- **算法说明**：  \n  遍历 `contentParent` 的所有子物体并销毁它们，然后清空 `existingCards` 列表。\n\n- **调用关系**：  \n  通常在需要清理所有卡片时调用，例如系统重置或用户退出当前场景时。调用频率较低，但可能在关键节点被调用。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class MonoBehaviour\n    class SelectedCardSpawner\n    SelectedCardSpawner --|> MonoBehaviour : 继承\n    SelectedCardSpawner --> UnityEngine : 依赖\n    SelectedCardSpawner --> UnityEngine.UI : 依赖\n```\n\n**说明**：  \n- **继承关系**：`SelectedCardSpawner` 继承自 `MonoBehaviour`，这是 Unity 引擎中的基类。  \n- **依赖关系**：`SelectedCardSpawner` 依赖 `UnityEngine` 模块（用于游戏对象操作）和 `UnityEngine.UI` 模块（用于 UI 组件操作）。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-6aa6f965efffd14a282c990f9bc669eb"
  },
  "chunk-c358ae26302e836e3c92de070b9bb779": {
    "tokens": 777,
    "content": "文件源代码内容如下：\n﻿using UnityEngine;\n\n// 放在一个通用的命名空间中\n[CreateAssetMenu(fileName = \"NewTagLibrary\", menuName = \"TagSystem/TagLibrary\", order = 0)]\npublic class TagLibrary : ScriptableObject, ITagLibrary\n{\n    public string category;\n    public string[] tags;\n\n    public string[] Tags => tags;\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 代码文件整体功能定位\n这是一个Unity脚本文件，定义了一个名为 `TagLibrary` 的类。该类继承自 `ScriptableObject`，并实现了 `ITagLibrary` 接口。其主要功能是提供一种管理标签（Tag）的机制，允许开发人员配置和存储标签数据。\n\n#### 在系统/项目中的角色和重要性\n`TagLibrary` 类在Unity项目中扮演标签管理器的角色，通常用于需要对游戏对象或资源进行分类和标记的场景。它是可配置的脚本对象，允许通过Unity编辑器创建和管理标签集合，具有较高的灵活性和可维护性。\n\n#### 支持的主要特性与技术实现方案\n- **标签管理**：通过 `string[] tags` 数组存储标签数据。\n- **配置能力**：继承自 `ScriptableObject`，可以通过Unity编辑器直接配置。\n- **接口实现**：实现 `ITagLibrary` 接口，提供统一的标签访问方式。\n\n---\n\n### 2. 核心类解析\n\n#### `TagLibrary` 类\n\n- **职责说明**：该类用于存储和管理标签数据，提供对标签的访问接口。\n- **关键方法清单**：\n  - `public string Tags => tags;`（读取属性）\n- **继承关系**：\n  ```mermaid\n  classDiagram\n    TagLibrary --> ScriptableObject\n    ScriptableObject --> MonoBehaviour\n    MonoBehaviour --> Component\n    Component --> Object\n  ```\n- **依赖模块**：无直接依赖项，仅依赖Unity内置类型和接口。\n\n---\n\n### 3. 关键方法详解\n\n#### 方法：`public string Tags => tags;`\n\n- **方法签名**：`public string Tags { get; }`\n- **功能描述**：该方法返回一个字符串数组 `tags`，表示所有可用的标签。这是一个只读属性，确保标签数据在运行时不可修改。\n- **算法说明**：直接返回预先配置的 `tags` 数组，逻辑简单，属于直接访问类型。\n- **调用关系**：通常会被其他需要使用标签的类（如 `TagManager` 或 `GameObject`）调用，调用频率取决于具体使用场景，可能在初始化或运行时频繁调用。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n  class TagLibrary {\n    +string category\n    +string[] tags\n    +string Tags { get; }\n  }\n  TagLibrary --> ScriptableObject\n  TagLibrary implements ITagLibrary\n  class ScriptableObject\n  class ITagLibrary {\n    +string Tags { get; }\n  }\n```\n\n---\n\n### 总结\n`TagLibrary` 是一个轻量级的标签管理类，通过Unity的 `ScriptableObject` 机制提供配置能力和数据持久化功能。它实现了 `ITagLibrary` 接口，确保了代码的可扩展性和可测试性。其核心功能是提供对标签数据的访问，适用于需要对对象进行分类和标记的场景。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-c358ae26302e836e3c92de070b9bb779"
  },
  "chunk-2cfc4f8bf6ddd616e7600c7de04233f5": {
    "tokens": 729,
    "content": "文件源代码内容如下：\nusing UnityEngine;\n\n// ¶¨Òå ITagLibrary ½Ó¿Ú£¬È·±£ÔÚÔËÐÐÊ±ºÍ±à¼­Æ÷ÖÐ¶¼¿ÉÒÔÊ¹ÓÃ\npublic interface ITagLibrary\n{\n    string[] Tags { get; }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n- **功能定位**：该代码文件定义了一个接口`ITagLibrary`，旨在为系统提供标签管理功能。它主要负责定义标签的获取接口，供其他组件使用。\n\n- **角色和重要性**：在系统中，`ITagLibrary`作为标签管理的基础设施，扮演着核心角色。它为任何需要标签支持的模块提供了统一的访问接口，确保了系统的模块化和可扩展性。\n\n- **支持的主要特性与技术实现方案**：\n  - 提供统一的标签访问接口，确保系统各模块能够方便地获取标签信息。\n  - 使用接口（Interface）设计模式，允许不同的实现类根据具体需求灵活实现标签管理功能。\n  - 通过属性`Tags`暴露标签数据，支持标签的集中管理和灵活获取。\n\n---\n\n### 2. 核心类解析\n\n#### **`ITagLibrary` 接口**\n\n- **职责说明**：定义标签管理的标准接口，规定了标签数据的获取方式。任何实现此类接口的类都必须提供标签数据的获取功能。\n\n- **关键方法清单**：\n  - `string[] Tags { get; }`：获取所有可用的标签。\n\n- **继承关系**：作为接口，`ITagLibrary`没有父类，但可以被其他类实现。例如：\n  ```\n  ChildClass (实现 ITagLibrary) -> ITagLibrary\n  ```\n\n- **依赖模块**：无直接依赖模块（仅接口定义）。\n\n---\n\n### 3. 关键方法详解\n\n#### **`string[] Tags { get; }`**\n\n- **方法签名**：`string[] Tags { get; }`\n\n- **功能描述**：该属性用于获取所有可用的标签。任何实现`ITagLibrary`接口的类都必须提供此属性，返回一个包含所有标签的字符串数组。\n\n- **算法说明**：无具体算法实现，由具体实现类决定如何获取和返回标签数据。\n\n- **调用关系**：此属性通常会被需要标签信息的类调用，例如游戏对象、UI组件或其他需要基于标签进行操作的模块。调用频率取决于系统的具体需求，可能在初始化阶段或动态操作时调用。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    interface ITagLibrary {\n        string[] Tags\n    }\n\n    class TagManager implements ITagLibrary {\n        string[] Tags\n    }\n\n    ITagLibrary ..> TagManager : 实现\n```\n\n---\n\n### 总结\n\n`ITagLibrary`接口为系统提供了一个统一的标签管理接口，任何需要标签信息的模块都可以通过实现此接口来获取标签数据。这种设计模式允许系统灵活扩展，支持多种不同的标签管理实现，同时确保了代码的清晰和模块化。通过使用接口，系统能够更好地遵循开闭原则，提高代码的可维护性和可扩展性。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-2cfc4f8bf6ddd616e7600c7de04233f5"
  },
  "chunk-cd3f0bc70ea763430463c232ae5e017b": {
    "tokens": 875,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEngine;\n\n[CustomEditor(typeof(TagLibrary))]\npublic class TagLibraryEditor : Editor\n{\n    public override void OnInspectorGUI()\n    {\n        TagLibrary tagLibrary = (TagLibrary)target;\n\n        tagLibrary.category = EditorGUILayout.TextField(\"Category\", tagLibrary.category);\n\n        SerializedProperty tagsProperty = serializedObject.FindProperty(\"tags\");\n        EditorGUILayout.PropertyField(tagsProperty, new GUIContent(\"Tags\"), true);\n\n        serializedObject.ApplyModifiedProperties();\n    }\n}\n#endif\n\n源代码内容解释如下：\n### 代码分析报告\n\n#### 1. 功能概览\n\n- **功能总结**：该代码文件是一个Unity编辑器扩展脚本，实现了对`TagLibrary`类的自定义Inspector面板。它允许用户在Unity编辑器中通过友好的GUI界面编辑`TagLibrary`类的属性。\n- **角色与重要性**：在Unity项目中，该脚本为`TagLibrary`类提供了一个定制的编辑界面，增强了开发体验，方便管理和维护标签数据。这对于需要频繁调整标签的项目尤为重要。\n- **主要特性与技术实现**：\n  - 使用Unity的`EditorGUILayout`创建自定义Inspector。\n  - 支持实时更新`TagLibrary`的属性。\n  - 通过`SerializedProperty`安全地处理序列化数据。\n\n#### 2. 核心类解析\n\n**类名称：TagLibraryEditor**\n\n- **职责说明**：该类负责提供一个自定义的Inspector面板，用于编辑`TagLibrary`类的属性。它通过重写`OnInspectorGUI`方法，实现了对`category`和`tags`属性的可视化编辑。\n- **关键方法清单**：\n  - `public override void OnInspectorGUI()`\n- **继承关系**：\n  ```\n  TagLibraryEditor -> Editor\n  ```\n- **依赖模块**：\n  - `UnityEditor.Editor`（Unity编辑器核心类）\n  - `UnityEngine.Object`（Unity对象基类）\n  - `TagLibrary`（项目内部类）\n\n#### 3. 关键方法详解\n\n**方法名称：OnInspectorGUI**\n\n- **方法签名**：\n  ```csharp\n  public override void OnInspectorGUI()\n  ```\n- **功能描述**：\n  重写`Editor`类的`OnInspectorGUI`方法，用于绘制自定义Inspector界面。具体步骤如下：\n  1. 获取`TagLibrary`实例。\n  2. 使用`EditorGUILayout.TextField`创建一个文本输入框，用于编辑`category`属性。\n  3. 使用`EditorGUILayout.PropertyField`创建一个属性字段，用于编辑`tags`数组。\n  4. 调用`serializedObject.ApplyModifiedProperties()`将修改后的属性应用到`TagLibrary`实例。\n- **算法说明**：\n  该方法利用Unity的`SerializedProperty`机制，确保对序列化属性的修改是安全且高效的。通过`EditorGUILayout`提供的GUI控件，构建了一个直观的编辑界面。\n- **调用关系**：\n  - 该方法由Unity编辑器自动调用，每次Inspector面板更新时执行。\n  - 调用频率：每当Inspector面板刷新或用户与界面交互时。\n\n#### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n  class Editor {\n    +void OnInspectorGUI()\n  }\n\n  class TagLibraryEditor {\n    +void OnInspectorGUI()\n  }\n\n  TagLibraryEditor --> Editor\n  TagLibraryEditor ..> TagLibrary : 依赖\n```\n\n---\n\n### 总结\n\n该代码通过继承`Editor`类并重写`OnInspectorGUI`方法，为`TagLibrary`类提供了一个自定义的Inspector面板。它利用Unity的GUI工具包创建了一个用户友好的编辑界面，支持对`TagLibrary`类的属性进行实时编辑。这种自定义Inspector在需要频繁调整标签数据的项目中非常有用，能够显著提高开发效率。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-cd3f0bc70ea763430463c232ae5e017b"
  },
  "chunk-c676820e0da487ffbdaec1d974689195": {
    "tokens": 1084,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\n\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[Serializable]\npublic class TagGroup\n{\n    public string groupName;\n    public List<TagLibrary> tagLibraries;\n}\n\n[CreateAssetMenu(fileName = \"TagLibraryManager\", menuName = \"TagSystem/TagLibraryManager\", order = 1)]\npublic class TagLibraryManager : ScriptableObject\n{\n    public List<TagGroup> tagGroups;\n}\n\n\n#endif\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 功能定位\n该代码文件实现了一个简单的标签管理器系统，用于 Unity 编辑器环境中管理标签组和标签库。主要功能包括标签分组、标签库的存储与管理。\n\n#### 系统角色\n该系统在 Unity 项目中扮演标签管理器的角色，用于组织和管理游戏中的标签数据，方便其他组件或脚本快速访问和使用这些标签信息。\n\n#### 主要特性与技术实现\n- **标签分组管理**：支持将标签库划分为不同的组，便于分类管理。\n- **序列化存储**：使用 `[Serializable]` 属性，支持将标签数据序列化存储为 Unity 资源文件。\n- **AssetMenu 创建**：通过 `[CreateAssetMenu]` 属性，可以直接在 Unity 编辑器中创建 `TagLibraryManager` 资源实例。\n\n---\n\n### 2. 核心类解析\n\n#### `TagGroup` 类\n- **职责说明**：表示一个标签组，用于存储一组标签库。\n- **关键方法清单**：无显式方法，主要通过字段存储数据。\n- **继承关系**：`TagGroup` 无显式父类，直接继承自 `UnityEngine.Object`。\n- **依赖模块**：无。\n\n#### `TagLibraryManager` 类\n- **职责说明**：负责管理所有标签组和标签库的容器类，提供存储和访问标签数据的功能。\n- **关键方法清单**：\n  - `public List<TagGroup> tagGroups;`：存储所有标签组的列表。\n- **继承关系**：`TagLibraryManager -> ScriptableObject -> UnityEngine.Object`。\n- **依赖模块**：依赖 `UnityEngine` 模块。\n\n---\n\n### 3. 关键方法详解\n\n#### `TagGroup` 类\n```csharp\npublic class TagGroup\n{\n    public string groupName;\n    public List<TagLibrary> tagLibraries;\n}\n```\n\n- **方法签名**：无显式方法。\n- **功能描述**：该类通过字段存储标签组名称和标签库列表，方便对标签进行分组管理。\n- **算法说明**：无。\n- **调用关系**：由 `TagLibraryManager` 类调用，用于存储和管理标签组数据。\n\n#### `TagLibraryManager` 类\n```csharp\n[CreateAssetMenu(fileName = \"TagLibraryManager\", menuName = \"TagSystem/TagLibraryManager\", order = 1)]\npublic class TagLibraryManager : ScriptableObject\n{\n    public List<TagGroup> tagGroups;\n}\n```\n\n- **方法签名**：无显式方法。\n- **功能描述**：该类通过 `tagGroups` 字段存储所有标签组数据，是一个 ScriptableObject 资源，便于在 Unity 编辑器中管理和持久化存储标签数据。\n- **算法说明**：无。\n- **调用关系**：由 Unity 编辑器的 AssetMenu 调用，用于创建和管理标签数据。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class UnityEngine.Object {\n        #+ string name\n        #+ int hideFlags\n    }\n\n    class ScriptableObject {\n        #+ UnityEngine.Object\n    }\n\n    class TagGroup {\n        #+ string groupName\n        #+ List<TagLibrary> tagLibraries\n    }\n\n    class TagLibraryManager {\n        #+ List<TagGroup> tagGroups\n    }\n\n    TagGroup --> TagLibrary\n    TagLibraryManager --> TagGroup\n    TagGroup ..> UnityEngine.Object\n    TagLibraryManager --> ScriptableObject\n    ScriptableObject --> UnityEngine.Object\n```\n\n#### 说明\n1. **继承层次结构**：\n   - `TagGroup` 和 `TagLibraryManager` 都继承自 `UnityEngine.Object`。\n   - `TagLibraryManager` 继承自 `ScriptableObject`，而 `ScriptableObject` 继承自 `UnityEngine.Object`。\n\n2. **组合/聚合关系**：\n   - `TagGroup` 包含 `List<TagLibrary>`，表示标签组包含多个标签库。\n   - `TagLibraryManager` 包含 `List<TagGroup>`，表示标签管理器包含多个标签组。\n\n3. **重要依赖关系**：\n   - `TagGroup` 依赖 `UnityEngine` 模块中的 `Object` 类。\n   - `TagLibraryManager` 依赖 `UnityEngine` 模块中的 `ScriptableObject` 类。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-c676820e0da487ffbdaec1d974689195"
  },
  "chunk-bafd13e4d97b68b05f39c31edbc4b280": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEngine;\nusing System.Collections;\nusing Unity.EditorCoroutines.Editor;\nusing System.IO;\n\npublic class BatchScreenshotEditor : EditorWindow\n{\n    private Vector3 cameraDefaultRotation = new Vector3(15f, -45f, 0f); // 默认视图相机角度\n    private Vector3 cameraFrontRotation = new Vector3(15f, 0f, 0f); // 正视图相机角度\n    private Vector3 cameraTopRotation = new Vector3(45f, 0f, 0f); // 顶视图相机角度\n\n    [MenuItem(\"ZTResource/批量截图\", false, 2)]\n    public static void ShowWindow()\n    {\n        GetWindow<BatchScreenshotEditor>(\"批量截图\");\n    }\n\n    private void OnGUI()\n    {\n        GUILayout.Label(\"截图设置\", EditorStyles.boldLabel);\n\n        cameraDefaultRotation = EditorGUILayout.Vector3Field(\"默认视图角度 (XYZ)\", cameraDefaultRotation);\n        cameraFrontRotation = EditorGUILayout.Vector3Field(\"正视图角度 (XYZ)\", cameraFrontRotation);\n        cameraTopRotation = EditorGUILayout.Vector3Field(\"顶视图角度 (XYZ)\", cameraTopRotation);\n\n        if (GUILayout.Button(\"开始截图\"))\n        {\n            StartCaptureScreenshots();\n        }\n    }\n\n    private void StartCaptureScreenshots()\n    {\n        GameObject parentObject = GameObject.Find(\"Target\"); // 替换为实际父物体名称\n        if (parentObject == null)\n        {\n            Debug.LogError(\"Parent object not found. Please ensure the parent object name is correct.\");\n            return;\n        }\n\n        EditorCoroutineUtility.StartCoroutine(CaptureScreenshotsCoroutine(parentObject), this);\n    }\n\n    private IEnumerator CaptureScreenshotsCoroutine(GameObject parentObject)\n    {\n        // 查找并隐藏 reference_role 物体\n        GameObject referenceRole = GameObject.Find(\"reference_role\");\n        if (referenceRole != null)\n        {\n            referenceRole.SetActive(false);\n        }\n        else\n        {\n            Debug.LogError(\"reference_role not found.\");\n        }\n\n        // 获取 Main_Camera\n        Camera cam = Camera.main;\n        if (cam == null)\n        {\n            Debug.LogError(\"Main_Camera not found.\");\n            yield break;\n        }\n\n        // 保存相机的原始 Field of View、位置和旋转\n        float originalFOV = cam.fieldOfView;\n        Vector3 originalPosition = cam.transform.position;\n        Quaternion originalRotation = cam.transform.rotation;\n\n        // 设置相机 Field of View 为 14\n        cam.fieldOfView = 14;\n\n        int width = 512;\n        int height = 512;\n        int totalChildren = parentObject.transform.childCount;\n\n        SetAllChildrenActive(parentObject, false);\n\n        for (int i = 0; i < totalChildren; i++)\n        {\n            GameObject child = parentObject.transform.GetChild(i).gameObject;\n            child.SetActive(true);\n\n            yield return new WaitForEndOfFrame();\n\n            MeshRenderer[] meshRenderers = child.GetComponentsInChildren<MeshRenderer>();\n            SkinnedMeshRenderer[] skinnedMeshRenderers = child.GetComponentsInChildren<SkinnedMeshRenderer>();\n            if (meshRenderers.Length == 0 && skinnedMeshRenderers.Length == 0)\n            {\n                Debug.LogError($\"子物体 {child.name} 没有MeshRenderer或SkinnedMeshRenderer组件。\");\n                child.SetActive(false);\n                continue;\n            }\n\n            // 批量截图\n            RenderAndSaveBatchScreenshot(child, cam, width, height);\n\n            // 三视图截图\n            string prefabFolder = CreateFolderForPrefab(child);\n            RenderAndSaveScreenshot(child, cam, width, height, cameraDefaultRotation, Path.Combine(prefabFolder, $\"{child.name}_Default.png\"));\n            RenderAndSaveScreenshot(child, cam, width, height, cameraFrontRotation, Path.Combine(prefabFolder, $\"{child.name}_Front.png\"));\n            RenderAndSaveScreenshot(child, cam, width, height, cameraTopRotation, Path.Combine(prefabFolder, $\"{child.name}_Top.png\"));\n\n            child.SetActive(false);\n\n            float progress = (float)i / totalChildren;\n            EditorUtility.DisplayProgressBar(\"截图进度\", \"正在截图: \" + child.name, progress);\n\n            yield return new WaitForEndOfFrame();\n        }\n\n        EditorUtility.ClearProgressBar();\n\n        // 恢复 reference_role 物体\n        if (referenceRole != null)\n        {\n            referenceRole.SetActive(true);\n        }\n\n        // 恢复相机的 Field of View、位置和旋转\n        cam.fieldOfView = originalFOV;\n        cam.transform.position = originalPosition;\n        cam.transform.rotation = originalRotation;\n\n        EditorUtility.DisplayDialog(\"截图完毕\", \"所有截图已完成！\", \"确定\");\n\n        Debug.Log(\"Screenshots taken for all children under \" + parentObject.name);\n    }\n\n\n\n    private void RenderAndSaveBatchScreenshot(GameObject child, Camera cam, int width, int height)\n    {\n        // 设置相机默认角度\n        cam.transform.rotation = Quaternion.Euler(cameraDefaultRotation);\n\n        // 设置相机背景为黑色（非透明）\n        cam.clearFlags = CameraClearFlags.SolidColor;\n        cam.backgroundColor = Color.black; // 黑色背景\n\n        Bounds bounds = GetTotalBounds(child);\n        float distance = bounds.extents.magnitude / Mathf.Sin(Mathf.Deg2Rad * cam.fieldOfView / 2f);\n        Vector3 cameraPosition = bounds.center - cam.transform.forward * distance;\n\n        cam.transform.position = cameraPosition;\n        cam.transform.LookAt(bounds.center);\n\n        RenderTexture rt = new RenderTexture(width, height",
    "chunk_order_index": 0,
    "full_doc_id": "doc-ebe1c4564d5cae4727c4b669f8c7e762"
  },
  "chunk-409b1adec50c051335d582b73219ccb3": {
    "tokens": 1200,
    "content": "= CameraClearFlags.SolidColor;\n        cam.backgroundColor = Color.black; // 黑色背景\n\n        Bounds bounds = GetTotalBounds(child);\n        float distance = bounds.extents.magnitude / Mathf.Sin(Mathf.Deg2Rad * cam.fieldOfView / 2f);\n        Vector3 cameraPosition = bounds.center - cam.transform.forward * distance;\n\n        cam.transform.position = cameraPosition;\n        cam.transform.LookAt(bounds.center);\n\n        RenderTexture rt = new RenderTexture(width, height, 24);\n        cam.targetTexture = rt;\n        Texture2D screenshot = new Texture2D(width, height, TextureFormat.RGB24, false); // 使用RGB24格式，不带透明通道\n        cam.Render();\n        RenderTexture.active = rt;\n        screenshot.ReadPixels(new Rect(0, 0, width, height), 0, 0);\n        screenshot.Apply();\n\n        byte[] bytes = screenshot.EncodeToPNG();\n\n        // 获取Prefab路径\n        string prefabPath = AssetDatabase.GetAssetPath(PrefabUtility.GetCorrespondingObjectFromSource(child));\n        if (string.IsNullOrEmpty(prefabPath))\n        {\n            Debug.LogError($\"未找到子物体 {child.name} 的Prefab路径。\");\n            return;\n        }\n\n        // 去除路径中的 \"Assets/ArtResource/Scenes/Standard/\" 部分，并删除 \".prefab\" 后缀\n        string relativePath = prefabPath.Replace(\"Assets/ArtResource/Scenes/Standard/\", \"\").Replace(\".prefab\", \"\").Replace(\"/\", \"\");\n\n        // 设置保存文件路径\n        string filename = string.Format(\"Assets/ZTResource/Resources/ZT_IconTextures/{0}.png\", relativePath);\n        System.IO.File.WriteAllBytes(filename, bytes);\n\n        // 设置图片导入属性为Sprite\n        SetTextureImporterSettings(filename);\n\n        cam.targetTexture = null;\n        RenderTexture.active = null;\n        DestroyImmediate(rt);\n    }\n\n    private void RenderAndSaveScreenshot(GameObject child, Camera cam, int width, int height, Vector3 rotation, string filepath)\n    {\n        cam.transform.rotation = Quaternion.Euler(rotation);\n\n        cam.clearFlags = CameraClearFlags.SolidColor;\n        cam.backgroundColor = new Color(0, 0, 0, 0); // 设置背景为透明\n\n        Bounds bounds = GetTotalBounds(child);\n        float distance = bounds.extents.magnitude / Mathf.Sin(Mathf.Deg2Rad * cam.fieldOfView / 2f);\n        Vector3 cameraPosition = bounds.center - cam.transform.forward * distance;\n\n        cam.transform.position = cameraPosition;\n        cam.transform.LookAt(bounds.center);\n\n        RenderTexture rt = new RenderTexture(width, height, 24);\n        cam.targetTexture = rt;\n        Texture2D screenshot = new Texture2D(width, height, TextureFormat.RGBA32, false); // 使用RGBA32格式，带透明通道\n        cam.Render();\n        RenderTexture.active = rt;\n        screenshot.ReadPixels(new Rect(0, 0, width, height), 0, 0);\n        screenshot.Apply();\n\n        byte[] bytes = screenshot.EncodeToPNG();\n        File.WriteAllBytes(filepath, bytes);\n\n        cam.targetTexture = null;\n        RenderTexture.active = null;\n        DestroyImmediate(rt);\n    }\n\n    private string CreateFolderForPrefab(GameObject child)\n    {\n        string prefabName = child.name;\n        string folderPath = $\"Assets/ZTResource/Resources/Al_NeedsTextures/{prefabName}\";\n        if (!Directory.Exists(folderPath))\n        {\n            Directory.CreateDirectory(folderPath);\n        }\n        return folderPath;\n    }\n\n    private void SetTextureImporterSettings(string path)\n    {\n        AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);\n        TextureImporter importer = (TextureImporter)AssetImporter.GetAtPath(path);\n        if (importer != null)\n        {\n            importer.textureType = TextureImporterType.Sprite;\n            importer.spriteImportMode = SpriteImportMode.Single;\n        }\n    }\n\n    private Bounds GetTotalBounds(GameObject go)\n    {\n        MeshRenderer[] meshRenderers = go.GetComponentsInChildren<MeshRenderer>();\n        SkinnedMeshRenderer[] skinnedMeshRenderers = go.GetComponentsInChildren<SkinnedMeshRenderer>();\n\n        if (meshRenderers.Length == 0 && skinnedMeshRenderers.Length == 0)\n        {\n            return new Bounds(go.transform.position, Vector3.zero);\n        }\n\n        Bounds bounds = new Bounds(go.transform.position, Vector3.zero);\n\n        foreach (var renderer in meshRenderers)\n        {\n            bounds.Encapsulate(renderer.bounds);\n        }\n\n        foreach (var skinnedRenderer in skinnedMeshRenderers)\n        {\n            bounds.Encapsulate(skinnedRenderer.bounds);\n        }\n\n        return bounds;\n    }\n\n    private void SetAllChildrenActive(GameObject parent, bool state)\n    {\n        foreach (Transform child in parent.transform)\n        {\n            child.gameObject.SetActive(state);\n        }\n    }\n}\n#endif\n源代码内容解释如下：\n### 1. 功能概览\n\n- **功能定位**：该代码文件实现了一个用于批量生成游戏物体截图的Unity编辑器扩展工具。用户可以通过该工具快速生成物体的多视角截图，并自动保存至指定路径，同时支持批量处理和截图参数配置。\n\n- **系统角色**：作为Unity编辑器的扩展，该工具在游戏资源生成和预览中扮演重要角色，显著提升了截图生成的效率和一致性。\n\n- **主要特性与技术实现**：\n  - **多视角截图**：支持默认视图、正视图、顶视图三种视角的截图生成。\n  - **批量处理**：可以一次性处理多个子物体，自动生成和保存截图。\n  - **",
    "chunk_order_index": 1,
    "full_doc_id": "doc-ebe1c4564d5cae4727c4b669f8c7e762"
  },
  "chunk-0385f80daec0e9ad26f33f0c33a385cb": {
    "tokens": 1200,
    "content": "作为Unity编辑器的扩展，该工具在游戏资源生成和预览中扮演重要角色，显著提升了截图生成的效率和一致性。\n\n- **主要特性与技术实现**：\n  - **多视角截图**：支持默认视图、正视图、顶视图三种视角的截图生成。\n  - **批量处理**：可以一次性处理多个子物体，自动生成和保存截图。\n  - **自动化路径管理**：自动创建保存文件夹，并根据Prefab路径生成文件名。\n  - **相机控制**：动态调整相机位置和旋转，确保截图视角正确。\n  - **资源管理**：自动设置截图生成的纹理导入属性。\n\n### 2. 核心类解析\n\n**BatchScreenshotEditor**\n\n- **职责说明**：实现批量截图功能的自定义编辑器窗口，提供用户界面和截图逻辑。\n\n- **关键方法清单**：\n  - `public static void ShowWindow()`：显示编辑器窗口。\n  - `private void OnGUI()`：绘制用户界面。\n  - `private void StartCaptureScreenshots()`：启动截图协程。\n  - `private IEnumerator CaptureScreenshotsCoroutine(GameObject parentObject)`：处理截图逻辑。\n  - `private void RenderAndSaveBatchScreenshot(GameObject child, Camera cam, int width, int height)`：渲染并保存批量截图。\n  - `private void RenderAndSaveScreenshot(GameObject child, Camera cam, int width, int height, Vector3 rotation, string filepath)`：渲染并保存三视图截图。\n  - `private string CreateFolderForPrefab(GameObject child)`：创建预制体文件夹。\n  - `private void SetTextureImporterSettings(string path)`：设置纹理导入属性。\n  - `private Bounds GetTotalBounds(GameObject go)`：计算物体包围盒。\n  - `private void SetAllChildrenActive(GameObject parent, bool state)`：设置子物体激活状态。\n\n- **继承关系**：\n  ```\n  BatchScreenshotEditor -> EditorWindow\n  ```\n\n- **依赖模块**：\n  - `UnityEngine`：用于游戏对象和相机操作。\n  - `UnityEditor`：用于编辑器扩展和资源操作。\n  - `System.IO`：用于文件和目录操作。\n  - `Unity.EditorCoroutines.Editor`：用于协程处理。\n\n### 3. 关键方法详解\n\n**1. `ShowWindow`**\n\n- **方法签名**：`[MenuItem(\"ZTResource/批量截图\", false, 2)] public static void ShowWindow()`\n- **功能描述**：通过Unity的MenuItem属性，添加一个菜单项，点击后显示BatchScreenshotEditor窗口。\n- **调用关系**：由Unity编辑器调用，作为用户入口。\n\n**2. `OnGUI`**\n\n- **方法签名**：`private void OnGUI()`\n- **功能描述**：绘制编辑器窗口的用户界面，包括标签、输入框和按钮。用户可以通过输入框调整相机角度，并点击按钮启动截图过程。\n- **调用关系**：由Unity编辑器周期性调用，维护界面显示。\n\n**3. `StartCaptureScreenshots`**\n\n- **方法签名**：`private void StartCaptureScreenshots()`\n- **功能描述**：查找目标父物体，并启动截图协程。如果未找到目标物体，显示错误信息。\n- **调用关系**：由`OnGUI`中的按钮点击事件调用。\n\n**4. `CaptureScreenshotsCoroutine`**\n\n- **方法签名**：`private IEnumerator CaptureScreenshotsCoroutine(GameObject parentObject)`\n- **功能描述**：处理截图的主逻辑，包括隐藏参考物体、相机设置、遍历子物体、渲染截图、进度显示和恢复状态。\n- **算法说明**：使用协程处理长时间任务，避免阻塞主线程。使用包围盒计算相机位置，确保物体在画面中居中。\n- **调用关系**：由`StartCaptureScreenshots`启动。\n\n**5. `RenderAndSaveBatchScreenshot`**\n\n- **方法签名**：`private void RenderAndSaveBatchScreenshot(GameObject child, Camera cam, int width, int height)`\n- **功能描述**：渲染并保存批量截图，设置相机角度和背景颜色，计算包围盒确定相机位置，生成纹理并保存为PNG。\n- **调用关系**：由`CaptureScreenshotsCoroutine`调用，处理每个子物体的批量截图。\n\n**6. `RenderAndSaveScreenshot`**\n\n- **方法签名**：`private void RenderAndSaveScreenshot(GameObject child, Camera cam, int width, int height, Vector3 rotation, string filepath)`\n- **功能描述**：渲染并保存三视图截图，根据传入的旋转角度设置相机，生成纹理并保存。\n- **调用关系**：由`CaptureScreenshotsCoroutine`调用，处理每个子物体的三视图截图。\n\n**7. `CreateFolderForPrefab`**\n\n- **方法签名**：`private string CreateFolderForPrefab(GameObject child)`\n- **功能描述**：为每个预制体创建保存文件夹，确保截图保存路径正确。\n- **调用关系**：由`CaptureScreenshotsCoroutine`调用，处理截图保存路径。\n\n**8. `SetTextureImporterSettings`**\n\n- **方法签名**：`private void SetTextureImporterSettings(string path)`\n- **功能描述**",
    "chunk_order_index": 2,
    "full_doc_id": "doc-ebe1c4564d5cae4727c4b669f8c7e762"
  },
  "chunk-17de16554d348b47403ebe7b55c1a6a7": {
    "tokens": 544,
    "content": "`CreateFolderForPrefab`**\n\n- **方法签名**：`private string CreateFolderForPrefab(GameObject child)`\n- **功能描述**：为每个预制体创建保存文件夹，确保截图保存路径正确。\n- **调用关系**：由`CaptureScreenshotsCoroutine`调用，处理截图保存路径。\n\n**8. `SetTextureImporterSettings`**\n\n- **方法签名**：`private void SetTextureImporterSettings(string path)`\n- **功能描述**：设置生成的纹理为Sprite类型，以便在Unity中正确显示。\n- **调用关系**：由`RenderAndSaveBatchScreenshot`调用，处理纹理导入属性。\n\n**9. `GetTotalBounds`**\n\n- **方法签名**：`private Bounds GetTotalBounds(GameObject go)`\n- **功能描述**：计算物体及其子物体的包围盒，用于确定相机的位置和视角。\n- **调用关系**：由`RenderAndSaveBatchScreenshot`和`RenderAndSaveScreenshot`调用，计算相机参数。\n\n**10. `SetAllChildrenActive`**\n\n- **方法签名**：`private void SetAllChildrenActive(GameObject parent, bool state)`\n- **功能描述**：设置父物体下所有子物体的激活状态，避免渲染时出现不需要的物体。\n- **调用关系**：由`CaptureScreenshotsCoroutine`调用，控制子物体的可见性。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class BatchScreenshotEditor {\n        +ShowWindow()\n        +OnGUI()\n        +StartCaptureScreenshots()\n        +CaptureScreenshotsCoroutine(GameObject)\n        +RenderAndSaveBatchScreenshot(GameObject, Camera, int, int)\n        +RenderAndSaveScreenshot(GameObject, Camera, int, int, Vector3, string)\n        +CreateFolderForPrefab(GameObject)\n        +SetTextureImporterSettings(string)\n        +GetTotalBounds(GameObject)\n        +SetAllChildrenActive(GameObject, bool)\n        #cameraDefaultRotation\n        #cameraFrontRotation\n        #cameraTopRotation\n    }\n\n    BatchScreenshotEditor --|> EditorWindow\n    BatchScreenshotEditor --* GameObject\n    BatchScreenshotEditor --* Camera\n    BatchScreenshotEditor --* Transform\n    BatchScreenshotEditor --* MeshRenderer\n    BatchScreenshotEditor --* SkinnedMeshRenderer\n    BatchScreenshotEditor --* RenderTexture\n    BatchScreenshotEditor --* Texture2D\n    BatchScreenshotEditor --* AssetDatabase\n    BatchScreenshotEditor --* EditorCoroutineUtility\n```",
    "chunk_order_index": 3,
    "full_doc_id": "doc-ebe1c4564d5cae4727c4b669f8c7e762"
  },
  "chunk-0bdb9533bfc93481a66ffa881709394b": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\n\nusing UnityEditor;\nusing UnityEngine;\nusing System.IO;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class CsvDuplicateRemover : ScriptableObject\n{\n    private static string rilFilePath = \"Assets/ZTResource/Resources/ZT_TagLibrary/ResourceIndexLibrary.csv\"; // RIL的文件路径\n\n    [MenuItem(\"ZTResource/Tools/CSV查重-资源库\", false, 6)]\n    public static void RemoveDuplicateEntries()\n    {\n        try\n        {\n            // 读取CSV文件内容\n            string[] lines = File.ReadAllLines(rilFilePath, Encoding.UTF8);\n            if (lines.Length == 0)\n            {\n                Debug.LogWarning(\"CSV文件为空。\");\n                return;\n            }\n\n            // 创建一个字典来存储唯一的资源条目\n            Dictionary<string, string> uniqueEntries = new Dictionary<string, string>();\n            List<string> headers = new List<string>();\n\n            // 遍历CSV文件内容\n            for (int i = 0; i < lines.Length; i++)\n            {\n                if (i == 0)\n                {\n                    // 保留表头\n                    headers.Add(lines[i]);\n                    continue;\n                }\n\n                string[] columns = lines[i].Split(',');\n                string resourceId = columns[0].Trim('\\\"');\n\n                // 如果字典中不包含该资源ID，则添加\n                if (!uniqueEntries.ContainsKey(resourceId))\n                {\n                    uniqueEntries.Add(resourceId, lines[i]);\n                }\n            }\n\n            // 重新生成CSV内容\n            StringBuilder csvContentBuilder = new StringBuilder();\n            foreach (var header in headers)\n            {\n                csvContentBuilder.AppendLine(header);\n            }\n            foreach (var entry in uniqueEntries.Values)\n            {\n                csvContentBuilder.AppendLine(entry);\n            }\n\n            // 写回CSV文件\n            File.WriteAllText(rilFilePath, csvContentBuilder.ToString(), Encoding.UTF8);\n            AssetDatabase.Refresh();\n            EditorUtility.DisplayDialog(\"查重处理\", \"CSV查重处理已完成。\", \"确定\");\n        }\n        catch (IOException ex)\n        {\n            if (IsFileLocked(ex))\n            {\n                EditorUtility.DisplayDialog(\"错误\", \"无法更新资源库，文件可能为只读或已被打开，请关闭文件后重试。\", \"确定\");\n            }\n            else\n            {\n                throw;\n            }\n        }\n    }\n\n    private static bool IsFileLocked(IOException exception)\n    {\n        int errorCode = System.Runtime.InteropServices.Marshal.GetHRForException(exception) & ((1 << 16) - 1);\n        return errorCode == 32 || errorCode == 33;\n    }\n}\n\n#endif\n\n源代码内容解释如下：\n```markdown\n# 代码文件分析\n\n## 1. 功能概览\n\n### 功能定位\n该代码文件是一个Unity编辑器工具，用于处理CSV文件中的重复资源条目。其主要功能是从指定的CSV文件中去除重复的条目，并保留唯一的资源记录。\n\n### 在系统中的角色\n该工具在Unity项目中扮演资源管理工具的角色，特别是在处理资源库索引文件（如ResourceIndexLibrary.csv）时，确保资源条目的唯一性，避免重复条目带来的潜在问题。\n\n### 主要特性与技术实现\n- **文件操作**：读取和写入CSV文件，处理文件锁定异常。\n- **数据去重**：使用字典数据结构存储唯一资源条目。\n- **异常处理**：优雅地处理文件操作中的异常，特别是文件被锁定的情况。\n- **Unity编辑器集成**：通过Unity的编辑器扩展API（MenuItem）提供用户界面操作。\n\n---\n\n## 2. 核心类解析\n\n### `CsvDuplicateRemover`类\n\n#### 职责说明\n该类的主要职责是提供一个工具，用于从CSV文件中去除重复的资源条目。它通过读取CSV文件、存储唯一条目、重新生成文件以及处理异常来实现这一功能。\n\n#### 关键方法清单\n- `public static void RemoveDuplicateEntries()`：执行CSV文件查重和去重操作。\n- `private static bool IsFileLocked(IOException exception)`：检查文件是否被锁定。\n\n#### 继承关系\n```mermaid\nclassDiagram\n    CsvDuplicateRemover --> ScriptableObject\n```\n\n#### 依赖模块\n- `UnityEngine`：用于Unity的基本功能。\n- `UnityEditor`：用于Unity编辑器扩展功能。\n- `System.IO`：用于文件操作。\n- `System.Text`：用于字符串操作。\n- `System.Collections.Generic`：用于字典数据结构。\n\n---\n\n## 3. 关键方法详解\n\n### 方法1：`RemoveDuplicateEntries()`\n\n#### 方法签名\n```csharp\n[MenuItem(\"ZTResource/Tools/CSV查重-资源库\", false, 6)]\npublic static void RemoveDuplicateEntries()\n```\n\n#### 功能描述\n该方法通过读取指定的CSV文件，去除重复的资源条目，然后将处理后的数据写回原文件。具体步骤包括：\n1. 读取CSV文件内容。\n2. 使用字典存储唯一资源条目。\n3. 重新生成CSV内容并写回文件。\n4. 处理文件锁定异常。\n\n#### 算法说明\n- 使用`Dictionary<string, string>`来存储唯一的资源条目，键为资源ID，值为完整的条目内容。\n- 遍历CSV文件的每一行，跳过表头，逐行检查资源ID是否已存在字典中。\n-",
    "chunk_order_index": 0,
    "full_doc_id": "doc-e460d84505cacf863670ba8c2b96322a"
  },
  "chunk-84a63224e0137229bed1998169d52bff": {
    "tokens": 487,
    "content": "内容。\n2. 使用字典存储唯一资源条目。\n3. 重新生成CSV内容并写回文件。\n4. 处理文件锁定异常。\n\n#### 算法说明\n- 使用`Dictionary<string, string>`来存储唯一的资源条目，键为资源ID，值为完整的条目内容。\n- 遍历CSV文件的每一行，跳过表头，逐行检查资源ID是否已存在字典中。\n- 如果不存在，则将该条目添加到字典中。\n\n#### 调用关系\n该方法通过Unity的`MenuItem`属性直接调用，用户可以在Unity编辑器的菜单中点击执行。\n\n---\n\n### 方法2：`IsFileLocked(IOException exception)`\n\n#### 方法签名\n```csharp\nprivate static bool IsFileLocked(IOException exception)\n```\n\n#### 功能描述\n该方法用于检查给定的IO异常是否是由于文件被锁定（如被其他程序占用）引起的。\n\n#### 算法说明\n- 使用`Marshal.GetHRForException`获取异常的错误代码。\n- 检查错误代码是否为32（文件被占用）或33（文件被共享）。\n\n#### 调用关系\n该方法在`RemoveDuplicateEntries()`方法中调用，用于处理文件写入失败的异常。\n\n---\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n    CsvDuplicateRemover --> ScriptableObject\n    CsvDuplicateRemover : +private static string rilFilePath\n    CsvDuplicateRemover : +public static void RemoveDuplicateEntries()\n    CsvDuplicateRemover : +private static bool IsFileLocked(IOException)\n```\n\n### 解释\n- **继承关系**：`CsvDuplicateRemover`继承自`ScriptableObject`，利用Unity的ScriptableObject特性。\n- **依赖关系**：该类依赖多个命名空间，如`UnityEngine`、`UnityEditor`、`System.IO`等，用于实现文件操作和异常处理。\n\n---\n\n通过以上分析，我们可以清晰地了解该代码文件的功能、结构以及实现细节。该工具在Unity项目中是一个非常实用的资源管理工具，能够有效地去除CSV文件中的重复条目，确保资源库的整洁和高效。\n```",
    "chunk_order_index": 1,
    "full_doc_id": "doc-e460d84505cacf863670ba8c2b96322a"
  },
  "chunk-e4adda956665168334afa01677993542": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing UnityEngine.EventSystems;\n\npublic class ZTCameraControl : MonoBehaviour\n{\n    // 添加比较用的人物模型引用\n    public GameObject comparisonObject;\n    public GameObject targetObject; // 观察的目标物体\n    public RectTransform uiPanel; // 用于调整相机Viewport的UI Panel\n    public float rotateSpeed = 5.0f; // 旋转速度\n    public float panSpeed = 0.5f; // 平移速度\n    public float zoomSpeed = 2.0f; // 缩放速度\n    public float focusMultiplier = 1.0f; // 默认倍数为1\n\n    private Vector3 targetCenter; // 目标的视觉中心\n    private float distanceToTarget; // 相机到目标的距离\n\n    private int lastChildCount = -1; // 用于存储上一次检查时的子物体数量\n\n    void Start()\n    {\n        FocusOnTarget();\n        AdjustCameraViewport();\n    }\n\n    void Update()\n    {\n        // 检查目标对象是否存在\n        if (targetObject == null) return;\n\n        // 检测子物体数量是否有变化\n        int currentChildCount = targetObject.transform.childCount;\n        if (currentChildCount != lastChildCount)\n        {\n            FocusOnTarget();\n            lastChildCount = currentChildCount; // 更新记录的子物体数量\n        }\n\n        // 每帧调整相机视口\n        AdjustCameraViewport();\n    }\n\n    void LateUpdate()\n    {\n        if (targetObject == null) return;\n\n        // 检查当前是否有UI元素在处理事件，以防止在UI交互时控制相机\n        if (EventSystem.current.IsPointerOverGameObject()) return; // 对于鼠标输入\n                                                                   // 对于触摸输入，您需要检查所有的触摸点\n        foreach (Touch touch in Input.touches)\n        {\n            if (EventSystem.current.IsPointerOverGameObject(touch.fingerId)) return;\n        }\n\n        // 左键拖动 - 旋转\n        if (Input.GetMouseButton(0))\n        {\n            float horizontal = Input.GetAxis(\"Mouse X\") * rotateSpeed;\n            float vertical = Input.GetAxis(\"Mouse Y\") * rotateSpeed;\n\n            transform.RotateAround(targetCenter, Vector3.up, horizontal);\n            transform.RotateAround(targetCenter, transform.right, -vertical);\n        }\n\n        // 右键拖动 - 平移\n        if (Input.GetMouseButton(1))\n        {\n            float h = Input.GetAxis(\"Mouse X\") * panSpeed;\n            float v = Input.GetAxis(\"Mouse Y\") * panSpeed;\n\n            transform.Translate(-h, -v, 0);\n        }\n\n        // 滚轮滑动 - 缩放\n\n        float scroll = Input.GetAxis(\"Mouse ScrollWheel\") * zoomSpeed;\n\n        // 使用已声明的变量来处理正交相机和透视相机的逻辑\n        if (Camera.main.orthographic)\n        {\n            Camera.main.orthographicSize -= scroll;\n            Camera.main.orthographicSize = Mathf.Max(Camera.main.orthographicSize, 0.1f);\n        }\n        else\n        {\n            transform.Translate(0, 0, scroll, Space.Self);\n        }\n\n        // 按F聚焦到目标\n        if (Input.GetKeyDown(KeyCode.F))\n        {\n            FocusOnTarget();\n        }\n    }\n\n    public void ToggleCameraMode()\n    {\n        // 检查相机当前的投影模式，并切换到另一种模式\n        if (Camera.main.orthographic)\n        {\n            // 从正交模式切换到透视模式\n            Camera.main.orthographic = false;\n            Camera.main.fieldOfView = 27; // 或者任何适合您场景的FOV值\n        }\n        else\n        {\n            // 从透视模式切换到正交模式\n            Camera.main.orthographic = true;\n            Vector3 currentCameraPosition = Camera.main.transform.position;\n            Vector3 currentCameraRotation = Camera.main.transform.eulerAngles;\n\n            // 计算正交相机大小\n            float distance = (targetCenter - Camera.main.transform.position).magnitude;\n            Camera.main.orthographicSize = distance * Mathf.Tan(Mathf.Deg2Rad * Camera.main.fieldOfView / 2);\n\n            // 调整相机位置和角度以保持视角不变\n            Camera.main.transform.position = currentCameraPosition;\n            Camera.main.transform.rotation = Quaternion.Euler(currentCameraRotation);\n        }\n    }\n\n    public void FocusOnTarget()\n    {\n        if (targetObject == null)\n        {\n            return;\n        }\n\n        // 获取目标物体及其所有子物体中带有MeshRenderer组件的物体\n        MeshRenderer[] meshRenderers = targetObject.GetComponentsInChildren<MeshRenderer>(true);\n        if (meshRenderers.Length == 0)\n        {\n            return;\n        }\n\n        // 初始化bounds以计算视觉中心\n        Bounds bounds = new Bounds();\n        bool hasBounds = false; // 用于标记是否找到了第一个有效的bounds\n\n        foreach (MeshRenderer meshRenderer in meshRenderers)\n        {\n            if (hasBounds)\n            {\n                bounds.Encapsulate(meshRenderer.bounds);\n            }\n            else\n            {\n                bounds = meshRenderer.bounds;\n                hasBounds = true;\n            }\n        }\n\n        if (!hasBounds)\n        {\n            Debug.LogError(\"Unable to find bounds for Target Object.\");\n            return;\n        }\n\n        targetCenter = bounds.center;\n\n        // 根据视觉中心的位置和大小调整相机的位置",
    "chunk_order_index": 0,
    "full_doc_id": "doc-eda6209de6dc591910b79a7ff7c449df"
  },
  "chunk-baebba7bb854a22f96b86d1a241f5edb": {
    "tokens": 1200,
    "content": "(MeshRenderer meshRenderer in meshRenderers)\n        {\n            if (hasBounds)\n            {\n                bounds.Encapsulate(meshRenderer.bounds);\n            }\n            else\n            {\n                bounds = meshRenderer.bounds;\n                hasBounds = true;\n            }\n        }\n\n        if (!hasBounds)\n        {\n            Debug.LogError(\"Unable to find bounds for Target Object.\");\n            return;\n        }\n\n        targetCenter = bounds.center;\n\n        // 根据视觉中心的位置和大小调整相机的位置\n        float objectSize = bounds.extents.magnitude;\n        distanceToTarget = objectSize / Mathf.Tan(Mathf.Deg2Rad * Camera.main.fieldOfView / 2) * focusMultiplier;\n        transform.position = targetCenter - transform.forward * distanceToTarget;\n\n        if (comparisonObject != null)\n        {\n            // 计算并更新人物模型在X和Z轴上的位置，保持Y轴位置不变\n            Vector3 edgePosition = new Vector3(\n                bounds.max.x, // 或者bounds.min.x，取决于您希望人物模型站在物体的哪一边\n                comparisonObject.transform.position.y, // 保持当前的Y轴位置\n                targetCenter.z // 您可以选择保持在物体中心的Z位置，或者根据需要调整\n            );\n\n            comparisonObject.transform.position = edgePosition;\n        }\n\n        // 根据相机是否为正交相机，应用不同的逻辑\n        if (Camera.main.orthographic)\n        {\n            // 正交相机模式下聚焦\n            Camera.main.orthographicSize = objectSize * focusMultiplier;\n            //transform.position = new Vector3(bounds.center.x, bounds.center.y, transform.position.z);\n\n        }\n        else\n        {\n            // 透视相机模式下聚焦\n            distanceToTarget = objectSize / Mathf.Tan(Mathf.Deg2Rad * Camera.main.fieldOfView / 2) * focusMultiplier;\n            //transform.position = targetCenter - transform.forward * distanceToTarget;\n        }\n        transform.LookAt(targetCenter);\n    }\n\n    private void AdjustCameraViewport()\n    {\n        if (uiPanel == null || Camera.main == null) return;\n\n        // 获取UIPanel在屏幕空间的矩形\n        Vector3[] worldCorners = new Vector3[4];\n        uiPanel.GetWorldCorners(worldCorners);\n\n        // 获取屏幕尺寸\n        float screenWidth = Screen.width;\n        float screenHeight = Screen.height;\n\n        // 计算Viewport Rect的参数\n        float x = worldCorners[0].x / screenWidth;\n        float y = worldCorners[0].y / screenHeight;\n        float width = (worldCorners[2].x - worldCorners[0].x) / screenWidth;\n        float height = (worldCorners[2].y - worldCorners[0].y) / screenHeight;\n\n        // 设置相机的Viewport Rect\n        Camera.main.rect = new Rect(x, y, width, height);\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 功能定位\n该代码实现了一个相机控制脚本，主要用于在Unity场景中对目标物体进行动态观察和调整。支持通过鼠标输入实现旋转、平移、缩放操作，并提供两种投影模式（正交和透视）的切换功能。同时，脚本还支持根据目标物体的子物体数量动态调整相机视角，以及根据UI Panel调整相机的视口大小。\n\n#### 项目角色\n该脚本在系统中扮演用户交互与场景观察的核心角色，是用户与虚拟场景之间的重要纽带。它允许用户通过直观的鼠标操作来探索和分析目标物体，适用于需要精细观察和动态调整的场景。\n\n#### 主要特性与技术实现\n- **相机控制**：支持鼠标左键旋转、右键平移、滚轮缩放。\n- **投影模式切换**：支持正交投影和透视投影模式的动态切换。\n- **动态聚焦**：根据目标物体的子物体数量动态调整相机视角。\n- **视口调整**：根据UI Panel的位置和大小调整相机的视口区域。\n- **事件系统集成**：通过Unity的EventSystem实现对UI交互的响应。\n\n---\n\n### 2. 核心类解析\n\n#### `ZTCameraControl`\n\n- **职责说明**\n  - 管理相机的观察、旋转、平移和缩放操作。\n  - 动态调整相机的视角和视口大小。\n  - 支持正交和透视投影模式的切换。\n  - 处理鼠标和键盘输入事件。\n\n- **关键方法清单**\n  - `void Start()`\n  - `void Update()`\n  - `void LateUpdate()`\n  - `public void ToggleCameraMode()`\n  - `public void FocusOnTarget()`\n  - `private void AdjustCameraViewport()`\n\n- **继承关系**\n  ```\n  ZTCameraControl -> MonoBehaviour -> Component -> Object\n  ```\n\n- **依赖模块**\n  - `UnityEngine`：用于相机控制、变换操作和输入处理。\n  - `UnityEngine.EventSystems`：用于检测鼠标是否悬停在UI元素上。\n\n---\n\n### 3. 关键方法详解\n\n#### `void Start()`\n- **方法签名**\n  ```csharp\n  void Start()\n  ```\n- **功能描述**\n  初始化相机的视角和视口大小。\n- **调用关系**\n  在脚本",
    "chunk_order_index": 1,
    "full_doc_id": "doc-eda6209de6dc591910b79a7ff7c449df"
  },
  "chunk-1c40b2606ee9739e3aebc7553951f3a5": {
    "tokens": 849,
    "content": "- `UnityEngine`：用于相机控制、变换操作和输入处理。\n  - `UnityEngine.EventSystems`：用于检测鼠标是否悬停在UI元素上。\n\n---\n\n### 3. 关键方法详解\n\n#### `void Start()`\n- **方法签名**\n  ```csharp\n  void Start()\n  ```\n- **功能描述**\n  初始化相机的视角和视口大小。\n- **调用关系**\n  在脚本生命周期的开始阶段被自动调用，执行`FocusOnTarget()`和`AdjustCameraViewport()`。\n\n---\n\n#### `void Update()`\n- **方法签名**\n  ```csharp\n  void Update()\n  ```\n- **功能描述**\n  每帧检查目标物体的子物体数量变化，并动态调整相机视角和视口大小。\n- **调用关系**\n  每帧由Unity引擎自动调用，触发`FocusOnTarget()`和`AdjustCameraViewport()`。\n\n---\n\n#### `void LateUpdate()`\n- **方法签名**\n  ```csharp\n  void LateUpdate()\n  ```\n- **功能描述**\n  处理用户的鼠标输入事件，实现相机的旋转、平移和缩放操作。同时，支持键盘快捷键`F`键聚焦到目标物体。\n- **调用关系**\n  每帧由Unity引擎自动调用，主要处理用户交互逻辑。\n\n---\n\n#### `public void ToggleCameraMode()`\n- **方法签名**\n  ```csharp\n  public void ToggleCameraMode()\n  ```\n- **功能描述**\n  切换相机的投影模式（正交/透视），并调整相机的视口大小和位置以保持视角一致。\n- **算法说明**\n  - 判断当前投影模式。\n  - 切换到另一种模式时，重新计算相机的视口大小和位置。\n- **调用关系**\n  可通过外部调用（如按钮点击）触发，通常用于用户交互。\n\n---\n\n#### `public void FocusOnTarget()`\n- **方法签名**\n  ```csharp\n  public void FocusOnTarget()\n  ```\n- **功能描述**\n  根据目标物体及其子物体的边界计算相机的聚焦中心，并调整相机的位置和视口大小。\n- **算法说明**\n  - 收集目标物体及其子物体的`MeshRenderer`组件。\n  - 计算所有`MeshRenderer`的包围盒，确定视觉中心。\n  - 根据投影模式调整相机的位置和视口大小。\n- **调用关系**\n  由`Start()`、`Update()`和键盘快捷键`F`键触发。\n\n---\n\n#### `private void AdjustCameraViewport()`\n- **方法签名**\n  ```csharp\n  private void AdjustCameraViewport()\n  ```\n- **功能描述**\n  根据UI Panel在屏幕空间的位置和大小调整相机的视口区域。\n- **算法说明**\n  - 获取UI Panel的四个角落点的屏幕坐标。\n  - 计算视口区域的相对位置和大小。\n  - 更新相机的`rect`属性以应用调整后的视口。\n- **调用关系**\n  由`Start()`、`Update()`和`LateUpdate()`触发。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class ZTCameraControl {\n        +MonoBehaviour MonoBehaviour\n        +Component Component\n        +Object Object\n        +void Start()\n        +void Update()\n        +void LateUpdate()\n        +void ToggleCameraMode()\n        +void FocusOnTarget()\n        +void AdjustCameraViewport()\n    }\n    ZTCameraControl --> MonoBehaviour\n    ZTCameraControl --> \"UnityEngine.Camera\" as Camera\n    ZTCameraControl --> \"UnityEngine.RectTransform\" as RectTransform\n    ZTCameraControl --> \"UnityEngine.EventSystems.EventSystem\" as EventSystem\n```",
    "chunk_order_index": 2,
    "full_doc_id": "doc-eda6209de6dc591910b79a7ff7c449df"
  },
  "chunk-0651f8ba73d06420243e2ea01963313b": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEngine;\nusing System.IO;\nusing System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class ScriptEncodingConverter : EditorWindow\n{\n    private List<string> filePaths = new List<string>(); // 存储拖拽的文件路径\n    private HashSet<string> directories = new HashSet<string>(); // 存储拖拽的文件夹路径\n\n    [MenuItem(\"ZTResource/Tools/其他/**批量修改编码**\")]\n    public static void ShowWindow()\n    {\n        GetWindow<ScriptEncodingConverter>(\"Script Encoding Converter\");\n    }\n\n    private void OnGUI()\n    {\n        GUILayout.Label(\"批量修改脚本编码\", EditorStyles.boldLabel);\n\n        // 显示拖拽区域\n        GUILayout.Label(\"拖拽文件夹或文件到这里:\");\n        HandleDragAndDrop();\n\n        // 显示当前已添加的文件夹和文件\n        GUILayout.Label(\"已添加的文件夹:\");\n        DisplayPathsWithRemoveButton(directories.ToList(), directories);\n\n        GUILayout.Label(\"已添加的文件:\");\n        DisplayPathsWithRemoveButton(filePaths, null);\n\n        EditorGUILayout.Space();\n\n        if (GUILayout.Button(\"转换为 UTF-8\"))\n        {\n            if (EditorUtility.DisplayDialog(\"确认\", \"确定要将所有脚本文件转换为UTF-8编码吗？此操作将覆盖源文件。\", \"确定\", \"取消\"))\n            {\n                ConvertFilesToUTF8();\n            }\n        }\n    }\n\n    private void HandleDragAndDrop()\n    {\n        Event evt = Event.current;\n        Rect dropArea = GUILayoutUtility.GetRect(0.0f, 50.0f, GUILayout.ExpandWidth(true));\n        GUI.Box(dropArea, \"拖拽文件夹或文件到这里\");\n\n        switch (evt.type)\n        {\n            case EventType.DragUpdated:\n            case EventType.DragPerform:\n                if (!dropArea.Contains(evt.mousePosition))\n                    return;\n\n                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;\n\n                if (evt.type == EventType.DragPerform)\n                {\n                    DragAndDrop.AcceptDrag();\n\n                    foreach (string draggedObject in DragAndDrop.paths)\n                    {\n                        if (Directory.Exists(draggedObject))\n                        {\n                            directories.Add(draggedObject);\n                        }\n                        else if (File.Exists(draggedObject) && Path.GetExtension(draggedObject).Equals(\".cs\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            filePaths.Add(draggedObject);\n                        }\n                    }\n                }\n                Event.current.Use();\n                break;\n        }\n    }\n\n    private void ConvertFilesToUTF8()\n    {\n        try\n        {\n            List<string> allFiles = new List<string>(filePaths);\n\n            // 获取所有文件夹中的 .cs 文件\n            foreach (string directory in directories)\n            {\n                allFiles.AddRange(Directory.GetFiles(directory, \"*.cs\", SearchOption.AllDirectories)\n                                           .Where(f => !Path.GetFileName(f).StartsWith(\"._\")));\n            }\n\n            if (allFiles.Count == 0)\n            {\n                Debug.LogError(\"未选择任何文件。\");\n                return;\n            }\n\n            // 使用 UTF-8 编码写入文件\n            foreach (string file in allFiles)\n            {\n                string content = File.ReadAllText(file, Encoding.GetEncoding(\"GB2312\"));\n                File.WriteAllText(file, content, new UTF8Encoding(false)); // 不包含 BOM\n                Debug.Log($\"已转换文件: {file}\");\n            }\n\n            AssetDatabase.Refresh();\n            Debug.Log($\"文件已转换为 UTF-8 编码。转换了 {allFiles.Count} 个 .cs 文件。\");\n        }\n        catch (System.Exception ex)\n        {\n            Debug.LogError(\"转换文件编码时出错: \" + ex.Message);\n        }\n    }\n\n    private void DisplayPathsWithRemoveButton(List<string> paths, HashSet<string> pathSet)\n    {\n        for (int i = 0; i < paths.Count; i++)\n        {\n            GUILayout.BeginHorizontal();\n            GUILayout.Label(paths[i]);\n            if (GUILayout.Button(\"移除\", GUILayout.Width(60)))\n            {\n                if (pathSet != null)\n                {\n                    pathSet.Remove(paths[i]);\n                }\n                else\n                {\n                    filePaths.RemoveAt(i);\n                }\n            }\n            GUILayout.EndHorizontal();\n        }\n    }\n}\n#endif\n\n源代码内容解释如下：\n# ScriptEncodingConverter代码分析\n\n## 1. 功能概览\n\n### 功能定位\nScriptEncodingConverter是一个Unity编辑器扩展工具，主要用于批量将C#脚本文件的编码从GB2312转换为UTF-8，支持拖放文件或文件夹进行处理。\n\n### 系统角色\n作为Unity编辑器工具，该脚本简化了开发者处理脚本文件编码的工作流程，提升了开发效率，是项目维护和代码管理的重要辅助工具。\n\n### 主要特性\n- **拖放功能**：支持将文件或文件夹拖放到窗口中\n- **批量处理**：可以一次性处理多个文件或整个文件夹下的所有脚本\n- **编码转换**：将文件编码从GB2312转换为UTF-8\n- **可视化界面**：提供友好的用户界面，显示已添加的文件和文件夹，并支持移除操作\n- **错误处理**：具有基本的异常处理机制，确保操作的稳定性\n\n## 2. 核心类解析\n\n### ScriptEncodingConverter类\n- **职责说明**：该类继承自EditorWindow，用于创建一个自定义的编辑器窗口，提供文件拖放、路径显示和编码转换功能。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-1151746ba8609f37de5ffb84c816939a"
  },
  "chunk-492a8bc485c8824e655d0ef289925395": {
    "tokens": 1085,
    "content": "**可视化界面**：提供友好的用户界面，显示已添加的文件和文件夹，并支持移除操作\n- **错误处理**：具有基本的异常处理机制，确保操作的稳定性\n\n## 2. 核心类解析\n\n### ScriptEncodingConverter类\n- **职责说明**：该类继承自EditorWindow，用于创建一个自定义的编辑器窗口，提供文件拖放、路径显示和编码转换功能。\n\n- **关键方法清单**：\n  - `public static void ShowWindow()`：显示编辑器窗口\n  - `private void OnGUI()`：绘制用户界面\n  - `private void HandleDragAndDrop()`：处理拖放事件\n  - `private void ConvertFilesToUTF8()`：执行编码转换\n  - `private void DisplayPathsWithRemoveButton(List<string> paths, HashSet<string> pathSet)`：显示路径并提供移除功能\n\n- **继承关系**：\n  ```mermaid\n  classDiagram\n    ScriptEncodingConverter <|-- EditorWindow\n  ```\n\n- **依赖模块**：\n  - `EditorWindow`：Unity编辑器窗口基类\n  - `AssetDatabase`：用于刷新资源数据库\n  - `EditorUtility`：提供编辑器实用工具\n  - `GUILayout`, `GUILayoutUtility`, `GUI`：用于构建用户界面\n  - `Directory`, `File`, `Path`：用于文件和目录操作\n  - `Encoding`：用于编码转换\n\n## 3. 关键方法详解\n\n### 3.1. ShowWindow方法\n- **方法签名**：\n  ```csharp\n  [MenuItem(\"ZTResource/Tools/其他/**批量修改编码**\")]\n  public static void ShowWindow()\n  ```\n- **功能描述**：通过MenuItem属性注册到Unity编辑器菜单中，点击后调用GetWindow方法显示ScriptEncodingConverter窗口。\n- **调用关系**：被Unity编辑器菜单调用，频率为用户点击时。\n\n### 3.2. OnGUI方法\n- **方法签名**：\n  ```csharp\n  private void OnGUI()\n  ```\n- **功能描述**：绘制编辑器窗口的用户界面，包括拖放区域、已添加路径的显示和转换按钮。\n- **调用关系**：由Unity编辑器框架定期调用，用于更新界面。\n\n### 3.3. HandleDragAndDrop方法\n- **方法签名**：\n  ```csharp\n  private void HandleDragAndDrop()\n  ```\n- **功能描述**：处理用户的拖放操作，将拖放的文件或文件夹路径添加到相应的集合中。\n- **算法说明**：通过检查拖放事件，判断拖放的路径是文件还是文件夹，并分别添加到filePaths或directories中。\n- **调用关系**：在OnGUI方法中被调用，频率为用户执行拖放操作时。\n\n### 3.4. ConvertFilesToUTF8方法\n- **方法签名**：\n  ```csharp\n  private void ConvertFilesToUTF8()\n  ```\n- **功能描述**：将所有已添加的C#脚本文件从GB2312编码转换为UTF-8编码。\n- **算法说明**：\n  1. 收集所有要转换的文件路径。\n  2. 读取文件内容，使用GB2312编码解码。\n  3. 使用UTF-8编码重新写入文件内容。\n  4. 刷新Unity资源数据库。\n- **调用关系**：在用户点击“转换为 UTF-8”按钮时被调用，频率为用户操作时。\n\n### 3.5. DisplayPathsWithRemoveButton方法\n- **方法签名**：\n  ```csharp\n  private void DisplayPathsWithRemoveButton(List<string> paths, HashSet<string> pathSet)\n  ```\n- **功能描述**：显示已添加的路径，并提供移除按钮。\n- **算法说明**：遍历路径列表，为每个路径创建水平布局，显示路径名称和移除按钮，点击移除按钮后从集合中移除对应路径。\n- **调用关系**：在OnGUI方法中被调用，频率为界面更新时。\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n    ScriptEncodingConverter <|-- EditorWindow\n    ScriptEncodingConverter --> AssetDatabase\n    ScriptEncodingConverter --> EditorUtility\n    ScriptEncodingConverter --> GUILayout\n    ScriptEncodingConverter --> GUILayoutUtility\n    ScriptEncodingConverter --> GUI\n    ScriptEncodingConverter --> System.IO.Directory\n    ScriptEncodingConverter --> System.IO.File\n    ScriptEncodingConverter --> System.IO.Path\n    ScriptEncodingConverter --> System.Text.Encoding\n```\n\n## 5. 总结\n\nScriptEncodingConverter通过提供一个用户友好的界面，简化了开发者处理脚本文件编码的工作流程，是Unity项目开发中一个实用的辅助工具。它利用了Unity编辑器的扩展机制，结合文件处理功能，实现了批量编码转换的便捷操作。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-1151746ba8609f37de5ffb84c816939a"
  },
  "chunk-c159ddb56a014653e6e215b675e1ee52": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\n\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing UnityEditor;\nusing UnityEngine;\n/// <summary>\n/// 通过项目已用资源记录表，生成新CSV，方便添加到购物记录里。\n/// </summary>\n\npublic class CsvMatcherEditor : EditorWindow\n{\n    private Object extractedResourcesFile;\n    private Object resourceIndexLibraryFile;\n    private string outputPath = \"Assets/MatchedResources.csv\";\n\n    [MenuItem(\"ZTResource/Tools/已用资源合并到购物记录\", false, 8)]\n    public static void ShowWindow()\n    {\n        GetWindow<CsvMatcherEditor>(\"CSV Matcher\");\n    }\n\n    private void OnGUI()\n    {\n        GUILayout.Label(\"CSV Matcher Settings\", EditorStyles.boldLabel);\n\n        extractedResourcesFile = EditorGUILayout.ObjectField(\"Extracted Resources CSV\", extractedResourcesFile, typeof(Object), false);\n        resourceIndexLibraryFile = EditorGUILayout.ObjectField(\"Resource Index Library CSV\", resourceIndexLibraryFile, typeof(Object), false);\n        outputPath = EditorGUILayout.TextField(\"Output Path\", outputPath);\n\n        if (GUILayout.Button(\"Match CSVs\"))\n        {\n            MatchCSVs();\n        }\n    }\n\n    private void MatchCSVs()\n    {\n        if (extractedResourcesFile == null || resourceIndexLibraryFile == null)\n        {\n            Debug.LogError(\"请指定有效的CSV文件。\");\n            return;\n        }\n\n        string extractedResourcesPath = AssetDatabase.GetAssetPath(extractedResourcesFile);\n        string resourceIndexLibraryPath = AssetDatabase.GetAssetPath(resourceIndexLibraryFile);\n\n        var extractedResources = ReadCsv(extractedResourcesPath);\n        var resourceIndexLibrary = ReadCsv(resourceIndexLibraryPath);\n\n        var matchedResources = new List<string[]>();\n\n        foreach (var extracted in extractedResources)\n        {\n            var matchingRow = resourceIndexLibrary.FirstOrDefault(ri => ri[0].Contains(extracted[0])); // 使用Contains进行部分匹配\n            if (matchingRow != null)\n            {\n                matchedResources.Add(matchingRow);\n            }\n        }\n\n        WriteCsv(outputPath, matchedResources);\n        Debug.Log(\"匹配完成，结果已保存至 \" + outputPath);\n    }\n\n    private List<string[]> ReadCsv(string path)\n    {\n        var lines = File.ReadAllLines(path);\n        return lines.Select(line => line.Split(',')).ToList();\n    }\n\n    private void WriteCsv(string path, List<string[]> records)\n    {\n        var lines = records.Select(record => string.Join(\",\", record)).ToList();\n        File.WriteAllLines(path, lines, Encoding.UTF8);\n    }\n}\n#endif\n\n源代码内容解释如下：\n```markdown\n# 代码文件分析\n\n## 1. 功能概览\n\n- **功能总结**：该代码文件实现了一个Unity编辑器工具，用于将两个CSV文件进行匹配，生成一个新的CSV文件。主要目的是通过已用资源记录表，生成新CSV，方便添加到购物记录里。\n\n- **系统角色**：该工具作为Unity编辑器扩展，在资源管理和数据处理中起到重要作用，帮助开发者高效地整理和匹配资源数据。\n\n- **主要特性与技术实现**：\n  - **CSV文件处理**：能够读取和写入CSV文件。\n  - **数据匹配**：通过部分匹配（Contains）实现资源匹配。\n  - **GUI界面**：提供友好的用户界面，方便用户选择输入文件和输出路径。\n  - **依赖**：主要依赖Unity编辑器API和基本文件操作。\n\n---\n\n## 2. 核心类解析\n\n### CsvMatcherEditor\n\n- **职责说明**：该类是一个Unity编辑器窗口，用于提供一个图形用户界面，使用户能够选择输入的CSV文件和输出路径，并执行CSV文件的匹配操作。\n\n- **关键方法清单**：\n  - `public static void ShowWindow()`：显示编辑器窗口。\n  - `private void OnGUI()`：绘制用户界面。\n  - `private void MatchCSVs()`：执行CSV文件的匹配逻辑。\n  - `private List<string[]> ReadCsv(string path)`：读取CSV文件。\n  - `private void WriteCsv(string path, List<string[]> records)`：写入CSV文件。\n\n- **继承关系**：\n  ```\n  CsvMatcherEditor -> EditorWindow\n  ```\n\n- **依赖模块**：\n  - `UnityEngine.AssetDatabase`\n  - `UnityEngine.Debug`\n  - `System.IO.File`\n  - `System.Linq`\n\n---\n\n## 3. 关键方法详解\n\n### 1. `public static void ShowWindow()`\n\n- **方法签名**：`public static void ShowWindow()`\n\n- **功能描述**：这是一个静态方法，用于显示`CsvMatcherEditor`编辑器窗口。调用`GetWindow<CsvMatcherEditor>`创建并显示窗口。\n\n- **调用关系**：通过`MenuItem`属性绑定到Unity编辑器菜单，用户点击菜单项时调用。\n\n---\n\n### 2. `private void OnGUI()`\n\n- **方法签名**：`private void OnGUI()`\n\n- **功能描述**：这是Unity编辑器窗口的回调方法，负责绘制用户界面。界面包含三个部分：\n  - 选择提取资源CSV文件的字段。\n  - 选择资源索引库CSV文件的字段。\n  - 输出路径的文本框。\n  - 一个“Match CSVs”按钮，点击后调用`MatchCSVs()`方法。\n\n- **调用关系**：由Unity编辑器框架自动调用，每次窗口更新时执行。\n\n---\n\n### 3. `private void Match",
    "chunk_order_index": 0,
    "full_doc_id": "doc-2cfc9cb9b7cb34b2eb2d2c02f9974784"
  },
  "chunk-1f4532dbc676c2b69ab567be334055f1": {
    "tokens": 726,
    "content": "回调方法，负责绘制用户界面。界面包含三个部分：\n  - 选择提取资源CSV文件的字段。\n  - 选择资源索引库CSV文件的字段。\n  - 输出路径的文本框。\n  - 一个“Match CSVs”按钮，点击后调用`MatchCSVs()`方法。\n\n- **调用关系**：由Unity编辑器框架自动调用，每次窗口更新时执行。\n\n---\n\n### 3. `private void MatchCSVs()`\n\n- **方法签名**：`private void MatchCSVs()`\n\n- **功能描述**：执行CSV文件的匹配逻辑。主要步骤如下：\n  1. 检查输入文件是否有效。\n  2. 读取两个CSV文件的内容。\n  3. 对每个提取的资源进行匹配，匹配规则是资源索引库中资源ID包含提取资源的资源ID。\n  4. 将匹配结果写入新的CSV文件。\n\n- **算法说明**：使用LINQ的`FirstOrDefault`方法进行部分匹配，匹配规则是资源索引库中资源ID包含提取资源的资源ID。\n\n- **调用关系**：由`OnGUI()`方法中的按钮点击事件调用，调用频率取决于用户的操作。\n\n---\n\n### 4. `private List<string[]> ReadCsv(string path)`\n\n- **方法签名**：`private List<string[]> ReadCsv(string path)`\n\n- **功能描述**：读取指定路径的CSV文件，返回一个包含CSV行数据的列表。每行数据被拆分为字符串数组。\n\n- **算法说明**：使用`File.ReadAllLines`读取所有行，然后使用`Split(',')`将每行数据拆分为字符串数组。\n\n- **调用关系**：由`MatchCSVs()`方法调用，用于读取提取资源CSV和资源索引库CSV。\n\n---\n\n### 5. `private void WriteCsv(string path, List<string[]> records)`\n\n- **方法签名**：`private void WriteCsv(string path, List<string[]> records)`\n\n- **功能描述**：将指定的记录列表写入指定路径的CSV文件。每行记录被转换为CSV格式的字符串。\n\n- **算法说明**：使用`string.Join(\",\", record)`将每行记录转换为CSV格式的字符串，然后使用`File.WriteAllLines`写入文件。\n\n- **调用关系**：由`MatchCSVs()`方法调用，用于将匹配结果写入新的CSV文件。\n\n---\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n  class CsvMatcherEditor {\n    +void ShowWindow()\n    +void OnGUI()\n    +void MatchCSVs()\n    +List<string[]> ReadCsv(string)\n    +void WriteCsv(string, List<string[]>)\n    +static void ShowWindow()\n  }\n\n  CsvMatcherEditor --> EditorWindow\n  CsvMatcherEditor --> AssetDatabase\n  CsvMatcherEditor --> File\n  CsvMatcherEditor --> Debug\n```\n\n- **继承层次结构**：`CsvMatcherEditor`继承自`EditorWindow`。\n- **组合/聚合关系**：无。\n- **重要依赖关系**：\n  - `AssetDatabase`：用于获取资产路径。\n  - `File`：用于读取和写入CSV文件。\n  - `Debug`：用于日志输出。\n- **接口实现情况**：无。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-2cfc9cb9b7cb34b2eb2d2c02f9974784"
  },
  "chunk-a892d4b15f540d26ea495be054a4278c": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\n\nusing UnityEditor;\nusing UnityEngine;\nusing System.Collections.Generic;\nusing System.IO;\n\n/// <summary>\n/// 用于管理和添加ResourceInfo脚本的编辑器窗口\n/// </summary>\npublic class AddResourceInfo : EditorWindow\n{\n    private List<string> directories = new List<string>();\n    private static List<GameObject> objectsWithoutResourceInfo = new List<GameObject>();\n\n    [MenuItem(\"ZTResource/ResourceInfo批处理\", false, 5)]\n    static void Init()\n    {\n        AddResourceInfo window = (AddResourceInfo)EditorWindow.GetWindow(typeof(AddResourceInfo));\n        window.Show();\n    }\n\n    void OnGUI()\n    {\n        GUILayout.Label(\"ResourceInfo批处理\", EditorStyles.boldLabel);\n\n        GUILayout.Space(10);\n\n        HandleDragAndDrop();\n\n        if (directories.Count > 0)\n        {\n            GUILayout.Label(\"已选择的目录：\");\n            DisplayPathsWithRemoveButton(directories);\n        }\n\n        if (GUILayout.Button(\"选择未添加ResourceInfo的预制体\"))\n        {\n            SelectObjectsWithoutResourceInfo();\n        }\n\n        if (GUILayout.Button(\"添加ResourceInfo\"))\n        {\n            AddResourceInfoScript();\n        }\n\n        GUILayout.Space(10);\n\n        GUIStyle highlightStyle = new GUIStyle(GUI.skin.button);\n        highlightStyle.normal.textColor = Color.white;\n        highlightStyle.normal.background = MakeTex(2, 2, Color.red);\n\n        if (objectsWithoutResourceInfo.Count > 0 && GUILayout.Button(\"重新选择上次的预制体\", highlightStyle))\n        {\n            ReSelectPreviousObjects();\n        }\n    }\n\n    private void HandleDragAndDrop()\n    {\n        Event evt = Event.current;\n        Rect dropArea = GUILayoutUtility.GetRect(0.0f, 50.0f, GUILayout.ExpandWidth(true));\n        GUI.Box(dropArea, \"拖拽文件夹或Prefab到这里\");\n\n        switch (evt.type)\n        {\n            case EventType.DragUpdated:\n            case EventType.DragPerform:\n                if (!dropArea.Contains(evt.mousePosition))\n                    return;\n\n                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;\n\n                if (evt.type == EventType.DragPerform)\n                {\n                    DragAndDrop.AcceptDrag();\n\n                    foreach (Object draggedObject in DragAndDrop.objectReferences)\n                    {\n                        string assetPath = AssetDatabase.GetAssetPath(draggedObject);\n\n                        // 判断是否是文件夹\n                        if (Directory.Exists(assetPath))\n                        {\n                            directories.Add(assetPath);\n                        }\n                        // 判断是否是Prefab\n                        else if (draggedObject is GameObject)\n                        {\n                            directories.Add(assetPath); // 直接添加Prefab的路径\n                        }\n                    }\n                }\n                Event.current.Use();\n                break;\n        }\n    }\n\n\n    private void DisplayPathsWithRemoveButton(List<string> paths)\n    {\n        for (int i = 0; i < paths.Count; i++)\n        {\n            GUILayout.BeginHorizontal();\n            GUILayout.Label(paths[i]);\n            if (GUILayout.Button(\"移除\", GUILayout.Width(60)))\n            {\n                paths.RemoveAt(i);\n            }\n            GUILayout.EndHorizontal();\n        }\n    }\n\n    void SelectObjectsWithoutResourceInfo()\n    {\n        objectsWithoutResourceInfo.Clear();\n\n        foreach (string directory in directories)\n        {\n            // 如果是文件夹，查找其中的Prefab\n            if (Directory.Exists(directory))\n            {\n                string[] guids = AssetDatabase.FindAssets(\"t:Prefab\", new[] { directory });\n                foreach (string guid in guids)\n                {\n                    string assetPath = AssetDatabase.GUIDToAssetPath(guid);\n                    GameObject obj = AssetDatabase.LoadAssetAtPath<GameObject>(assetPath);\n\n                    if (obj != null && obj.GetComponent<ResourceInfo>() == null)\n                    {\n                        objectsWithoutResourceInfo.Add(obj);\n                    }\n                }\n            }\n            // 如果是Prefab，直接处理\n            else if (File.Exists(directory) && directory.EndsWith(\".prefab\"))\n            {\n                GameObject obj = AssetDatabase.LoadAssetAtPath<GameObject>(directory);\n                if (obj != null && obj.GetComponent<ResourceInfo>() == null)\n                {\n                    objectsWithoutResourceInfo.Add(obj);\n                }\n            }\n        }\n\n        if (objectsWithoutResourceInfo.Count > 0)\n        {\n            Selection.objects = objectsWithoutResourceInfo.ToArray();\n            Debug.Log($\"选择了 {objectsWithoutResourceInfo.Count} 个未添加 ResourceInfo 脚本的预制体。\");\n        }\n        else\n        {\n            Debug.Log(\"没有找到未添加 ResourceInfo 脚本的预制体。\");\n        }\n    }\n\n\n    void ReSelectPreviousObjects()\n    {\n        if (objectsWithoutResourceInfo.Count > 0)\n        {\n            Selection.objects = objectsWithoutResourceInfo.ToArray();\n            Debug.Log(\"重新选择了上次的预制体。\");\n        }\n        else\n        {\n            Debug.Log(\"没有上次的预制体记录。\");\n        }\n    }\n\n    void AddResourceInfoScript()\n    {\n        int addedCount = 0;\n        int alreadyExistCount = 0;\n\n        foreach (GameObject obj in Selection.gameObjects)\n        {\n            ResourceInfo resourceInfo = obj.GetComponent<ResourceInfo>();\n            if (resourceInfo == null)\n            {\n                resourceInfo = obj.AddComponent<ResourceInfo>();\n\n                // 使用路径生成ID，替换原有的GUID生成方式\n                string prefabPath = AssetDatabase.GetAssetPath(obj);\n                string basePath = \"Assets/ArtResource/Scenes/Standard/\";\n\n                if (prefabPath.StartsWith(basePath))\n                {\n                    prefabPath = prefabPath.Substring(basePath.Length);\n                }\n\n                string resourceId = System.IO.Path.ChangeExtension(prefabPath, null); // 去掉文件后缀作为ID\n                resource",
    "chunk_order_index": 0,
    "full_doc_id": "doc-d2ab28801302cab8f9d3123d6999b365"
  },
  "chunk-0e01e643ec10177391f49a31ff685495": {
    "tokens": 1200,
    "content": "<ResourceInfo>();\n\n                // 使用路径生成ID，替换原有的GUID生成方式\n                string prefabPath = AssetDatabase.GetAssetPath(obj);\n                string basePath = \"Assets/ArtResource/Scenes/Standard/\";\n\n                if (prefabPath.StartsWith(basePath))\n                {\n                    prefabPath = prefabPath.Substring(basePath.Length);\n                }\n\n                string resourceId = System.IO.Path.ChangeExtension(prefabPath, null); // 去掉文件后缀作为ID\n                resourceInfo.id = resourceId;\n                resourceInfo.resourceName = \"未打标签\";\n                resourceInfo.creationDate = System.DateTime.Now.ToString(\"yyyy/MM/dd\");\n                resourceInfo.version = \"0\"; // 版本从0开始\n\n                // 按照 ResourceInfoEditor 的方式查找缩略图\n                string modifiedPrefabPath = prefabPath.Replace(\"/\", \"\");\n                string prefabName = System.IO.Path.GetFileNameWithoutExtension(modifiedPrefabPath);\n\n                // 构建缩略图路径\n                string thumbnailPath = $\"Assets/ZTResource/Resources/ZT_IconTextures/{prefabName}.png\";\n                Texture2D newThumbnail = AssetDatabase.LoadAssetAtPath<Texture2D>(thumbnailPath);\n\n                if (newThumbnail)\n                {\n                    resourceInfo.resourceThumbnail = newThumbnail;\n                    Debug.Log($\"找到并设置了缩略图: {thumbnailPath}\");\n                }\n                else\n                {\n                    Debug.LogWarning($\"未找到缩略图文件：{thumbnailPath}\");\n                }\n\n                RefreshData(resourceInfo);\n                addedCount++;\n                Debug.Log($\"已添加 ResourceInfo 脚本到: {obj.name}\");\n            }\n            else\n            {\n                alreadyExistCount++;\n                Debug.LogWarning($\"{obj.name} 已经存在 ResourceInfo 脚本\");\n            }\n        }\n\n        Debug.Log($\"操作完成，共添加了 {addedCount} 个 ResourceInfo 脚本，{alreadyExistCount} 个对象已经存在 ResourceInfo 脚本。\");\n    }\n\n\n\n    static void RefreshData(ResourceInfo resourceInfo)\n    {\n        if (resourceInfo != null && resourceInfo.gameObject != null)\n        {\n            string facesCount = CalculateModelFaces(resourceInfo.gameObject);\n            resourceInfo.modelFaces = facesCount;\n\n            string dimensions = CalculatePrefabDimensions(resourceInfo.gameObject);\n            resourceInfo.itemHeight = dimensions;\n\n            EditorUtility.SetDirty(resourceInfo);\n            Debug.Log(\"更新信息已完成！\");\n        }\n    }\n\n    static string CalculateModelFaces(GameObject prefab)\n    {\n        int totalFaces = 0;\n        MeshFilter[] meshFilters = prefab.GetComponentsInChildren<MeshFilter>();\n        foreach (MeshFilter meshFilter in meshFilters)\n        {\n            if (meshFilter.sharedMesh != null)\n            {\n                totalFaces += meshFilter.sharedMesh.triangles.Length / 3;\n            }\n        }\n        return totalFaces.ToString();\n    }\n\n    static string CalculatePrefabDimensions(GameObject prefab)\n    {\n        Renderer[] renderers = prefab.GetComponentsInChildren<Renderer>();\n\n        if (renderers.Length == 0)\n        {\n            Debug.Log(\"预制体中没有找到任何模型\");\n            return string.Empty;\n        }\n\n        Bounds overallBounds = renderers[0].bounds;\n\n        foreach (Renderer renderer in renderers)\n        {\n            overallBounds.Encapsulate(renderer.bounds);\n        }\n\n        float length = Mathf.Round(overallBounds.size.x * 10) / 10f;\n        float width = Mathf.Round(overallBounds.size.z * 10) / 10f;\n        float height = Mathf.Round(overallBounds.size.y * 10) / 10f;\n\n        return $\"{length}|{width}|{height}\";\n    }\n\n    void OnDestroy()\n    {\n        objectsWithoutResourceInfo.Clear();\n    }\n\n    private Texture2D MakeTex(int width, int height, Color col)\n    {\n        Color[] pix = new Color[width * height];\n        for (int i = 0; i < pix.Length; i++)\n        {\n            pix[i] = col;\n        }\n        Texture2D result = new Texture2D(width, height);\n        result.SetPixels(pix);\n        result.Apply();\n        return result;\n    }\n}\n\n#endif\n\n源代码内容解释如下：\n## 1. 功能概览\n\n- **功能定位**：这是一个用于Unity编辑器的自定义窗口脚本，主要功能是管理和批量添加ResourceInfo脚本到预制体（Prefab）上。它支持拖放文件夹或Prefab，自动查找未添加ResourceInfo的预制体，并为其添加ResourceInfo脚本，同时自动填充部分资源信息。\n\n- **系统角色**：在Unity项目中，ResourceInfo脚本通常用于记录资源的元数据（如ID、名称、创建日期、版本等）。这个编辑器窗口提供了一个高效的批量处理工具，帮助开发者快速为多个预制体添加和管理这些元数据。\n\n- **主要特性与技术实现**：\n  - 拖放功能支持将文件夹或Prefab直接拖入窗口\n  - 自动查找未添加ResourceInfo脚本的预制体\n  - 批量添加ResourceInfo脚本并自动填充部分属性\n  - 自动生成资源ID（基于文件路径）\n  - 自动查找并设置缩略图\n  - 计算模型面数和预制体尺寸\n  - 提供重新选择上次处理的预制体功能\n\n## 2. 核心类解析\n\n### AddResourceInfo\n\n- **职责说明**：这是一个自定义的EditorWindow类，用于提供一个编辑器窗口，通过拖放或选择操作批量处理预制体，为其添加ResourceInfo脚本并填充相关属性。\n\n- **关键方法清单**：\n  -",
    "chunk_order_index": 1,
    "full_doc_id": "doc-d2ab28801302cab8f9d3123d6999b365"
  },
  "chunk-08a6b13aab14631787434815b79a8a94": {
    "tokens": 1200,
    "content": "- 计算模型面数和预制体尺寸\n  - 提供重新选择上次处理的预制体功能\n\n## 2. 核心类解析\n\n### AddResourceInfo\n\n- **职责说明**：这是一个自定义的EditorWindow类，用于提供一个编辑器窗口，通过拖放或选择操作批量处理预制体，为其添加ResourceInfo脚本并填充相关属性。\n\n- **关键方法清单**：\n  - `void Init()` - 静态方法，用于创建并显示窗口\n  - `void OnGUI()` - 绘制窗口界面\n  - `void HandleDragAndDrop()` - 处理拖放操作\n  - `void SelectObjectsWithoutResourceInfo()` - 查找未添加ResourceInfo的预制体\n  - `void AddResourceInfoScript()` - 批量添加ResourceInfo脚本\n  - `void RefreshData(ResourceInfo resourceInfo)` - 更新ResourceInfo数据\n  - `static string CalculateModelFaces(GameObject prefab)` - 计算模型面数\n  - `static string CalculatePrefabDimensions(GameObject prefab)` - 计算预制体尺寸\n\n- **继承关系**：\n  ```\n  AddResourceInfo -> EditorWindow -> Object\n  ```\n\n- **依赖模块**：\n  - `UnityEngine` (Unity核心类库)\n  - `UnityEditor` (Unity编辑器API)\n  - `System.Collections.Generic` (List等集合类)\n  - `System.IO` (文件操作相关类)\n\n## 3. 关键方法详解\n\n### AddResourceInfoScript()\n\n- **方法签名**：\n  ```csharp\n  void AddResourceInfoScript()\n  ```\n\n- **功能描述**：\n  遍历当前选中的预制体（通过Selection.gameObjects获取），为每个预制体添加ResourceInfo脚本。如果预制体已经存在ResourceInfo脚本，则跳过。对于新添加的脚本，会根据预制体的文件路径生成资源ID，并设置默认的资源名称、创建日期和版本。同时，会尝试从固定路径查找对应的缩略图，并调用RefreshData方法更新模型面数和预制体尺寸。\n\n- **算法说明**：\n  1. 遍历Selection.gameObjects获取所有选中的预制体\n  2. 对于每个预制体，检查是否已存在ResourceInfo脚本\n  3. 如果不存在，添加ResourceInfo脚本\n  4. 根据预制体的文件路径生成资源ID\n  5. 设置默认的资源名称、创建日期和版本\n  6. 尝试从固定路径查找缩略图\n  7. 更新模型面数和预制体尺寸\n\n- **调用关系**：\n  - 被`OnGUI()`方法中的按钮点击事件调用\n  - 调用`RefreshData()`方法\n\n### RefreshData(ResourceInfo resourceInfo)\n\n- **方法签名**：\n  ```csharp\n  static void RefreshData(ResourceInfo resourceInfo)\n  ```\n\n- **功能描述**：\n  更新ResourceInfo脚本中的模型面数和预制体尺寸信息。模型面数通过遍历预制体中的所有MeshFilter组件获取，预制体尺寸通过遍历所有Renderer组件获取包围盒。\n\n- **算法说明**：\n  - 遍历预制体的所有子组件中的MeshFilter，累加所有网格的三角面数\n  - 遍历预制体的所有子组件中的Renderer，获取整体包围盒\n  - 将包围盒的尺寸四舍五入到小数点后一位\n\n- **调用关系**：\n  - 被`AddResourceInfoScript()`方法调用\n\n### CalculateModelFaces(GameObject prefab)\n\n- **方法签名**：\n  ```csharp\n  static string CalculateModelFaces(GameObject prefab)\n  ```\n\n- **功能描述**：\n  计算预制体中所有网格的总面数。通过遍历预制体中的所有MeshFilter组件，累加每个网格的三角面数。\n\n- **算法说明**：\n  1. 获取预制体中的所有MeshFilter组件\n  2. 对于每个MeshFilter，如果其共享网格不为空，则累加其三角面数（三角面数 = 网格三角形索引数组长度 / 3）\n  3. 返回总面数的字符串表示\n\n- **调用关系**：\n  - 被`RefreshData()`方法调用\n\n### CalculatePrefabDimensions(GameObject prefab)\n\n- **方法签名**：\n  ```csharp\n  static string CalculatePrefabDimensions(GameObject prefab)\n  ```\n\n- **功能描述**：\n  计算预制体的整体尺寸。通过遍历预制体中的所有Renderer组件，获取所有Renderer的包围盒，并合并为一个整体包围盒，从而得到预制体的尺寸。\n\n- **算法说明**：\n  1. 获取预制体中的所有Renderer组件\n  2. 如果没有找到Renderer组件，返回空字符串\n  3. 初始化整体包围盒为第一个Renderer的包围盒\n  4. 遍历所有Renderer，将每个Renderer的包围盒合并到整体包围盒中\n  5. 将整体包围盒的尺寸四舍五入到小数点后一位，格式化为字符串返回\n\n- **调用关系**：\n  - 被`RefreshData()`方法调用\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n    AddResourceInfo <|-- EditorWindow\n    AddResourceInfo --> ResourceInfo",
    "chunk_order_index": 2,
    "full_doc_id": "doc-d2ab28801302cab8f9d3123d6999b365"
  },
  "chunk-a04fd639747ec3f29b7031ba314899b0": {
    "tokens": 141,
    "content": "遍历所有Renderer，将每个Renderer的包围盒合并到整体包围盒中\n  5. 将整体包围盒的尺寸四舍五入到小数点后一位，格式化为字符串返回\n\n- **调用关系**：\n  - 被`RefreshData()`方法调用\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n    AddResourceInfo <|-- EditorWindow\n    AddResourceInfo --> ResourceInfo : 依赖\n    AddResourceInfo --> AssetDatabase : 依赖\n    AddResourceInfo --> EditorUtility : 依赖\n    AddResourceInfo --> Selection : 依赖\n```",
    "chunk_order_index": 3,
    "full_doc_id": "doc-d2ab28801302cab8f9d3123d6999b365"
  },
  "chunk-6622750a99ce419ddd60c4097309677f": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEngine;\nusing UnityEditor;\nusing System.Collections.Generic;\n\npublic class ResourceLoaderWindow : EditorWindow\n{\n    string prefabPaths = \"\"; // 存储多个预制体路径\n    Vector2 scrollPosition; // 用于滚动视图\n\n    // 添加菜单项用于打开窗口\n    [MenuItem(\"ZTResource/资源导入场景\", false, 3)]\n    public static void ShowWindow()\n    {\n        // 显示现有窗口实例。如果没有，就创建一个。\n        EditorWindow.GetWindow(typeof(ResourceLoaderWindow), true, \"资源加载\");\n    }\n\n    void OnGUI()\n    {\n        // 界面布局开始\n        GUILayout.Label(\"粘贴预制体路径 (每行一个):\", EditorStyles.boldLabel);\n\n        // 创建一个滚动视图\n        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(200));\n        // 使用TextArea接收多行输入\n        prefabPaths = EditorGUILayout.TextArea(prefabPaths, GUILayout.ExpandHeight(true));\n        EditorGUILayout.EndScrollView();\n\n        // 载入按钮\n        if (GUILayout.Button(\"加载资源\"))\n        {\n            LoadPrefabsIntoScene(prefabPaths);\n        }\n    }\n\n    // 加载多个预制体到场景中的函数\n    void LoadPrefabsIntoScene(string paths)\n    {\n        // 分割输入的多个路径\n        string[] allPaths = paths.Split('\\n');\n        List<GameObject> instantiatedPrefabs = new List<GameObject>();\n\n        foreach (string path in allPaths)\n        {\n            // 清除空白字符\n            string trimmedPath = path.Trim();\n            if (!string.IsNullOrEmpty(trimmedPath))\n            {\n                // 加载并实例化预制体\n                GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(trimmedPath);\n                if (prefab != null)\n                {\n                    GameObject instantiatedPrefab = (GameObject)PrefabUtility.InstantiatePrefab(prefab);\n                    instantiatedPrefabs.Add(instantiatedPrefab); // 添加到列表\n                    Debug.Log(\"预制体加载成功：\" + trimmedPath);\n                }\n                else\n                {\n                    Debug.LogError(\"无法加载预制体，检查路径是否正确：\" + trimmedPath);\n                }\n            }\n        }\n\n        // 选中所有实例化的预制体\n        if (instantiatedPrefabs.Count > 0)\n        {\n            Selection.objects = instantiatedPrefabs.ToArray();\n        }\n    }\n}\n#endif\n源代码内容解释如下：\n# 代码文件分析\n\n## 1. 功能概览\n\n### 功能定位\n该代码文件提供了一个Unity编辑器扩展窗口，用于将预制体资源加载到当前场景中。用户可以通过粘贴预制体路径到窗口中，点击按钮批量加载这些预制体。\n\n### 系统角色\n作为Unity编辑器脚本，该文件扩展了编辑器功能，提供了便捷的预制体加载工具，提升开发效率。它帮助开发者快速将多个预制体实例化到场景中，同时提供路径验证和加载状态反馈。\n\n### 主要特性\n- **批量加载**：支持通过多行输入一次性加载多个预制体\n- **路径验证**：自动处理路径分割和空白字符清理\n- **实例化管理**：使用PrefabUtility进行安全的预制体实例化\n- **用户反馈**：通过Unity调试日志提供加载状态反馈\n\n### 技术实现\n- **Unity编辑器扩展**：基于EditorWindow创建自定义编辑器窗口\n- **多行文本处理**：使用GUILayout和ScrollView处理多行输入\n- **预制体加载**：通过AssetDatabase和PrefabUtility实现安全的预制体加载和实例化\n\n## 2. 核心类解析\n\n### ResourceLoaderWindow\n\n#### 职责说明\n该类创建并管理一个编辑器窗口，提供用户界面用于粘贴预制体路径并执行加载操作。主要负责预制体路径的输入处理、加载逻辑以及用户界面的绘制。\n\n#### 关键方法清单\n- `ShowWindow()`：静态方法，用于显示编辑器窗口\n- `OnGUI()`：绘制用户界面并处理用户输入\n- `LoadPrefabsIntoScene(string paths)`：加载预制体到场景中的核心逻辑\n\n#### 继承关系\n```\nResourceLoaderWindow -> EditorWindow -> MonoBehaviour\n```\n\n#### 依赖模块\n- `UnityEngine`：Unity核心功能\n- `UnityEditor`：Unity编辑器扩展功能\n- `System.Collections.Generic`：使用List存储实例化的预制体\n\n## 3. 关键方法详解\n\n### 3.1 ShowWindow()\n\n#### 方法签名\n```csharp\n[MenuItem(\"ZTResource/资源导入场景\", false, 3)]\npublic static void ShowWindow()\n```\n\n#### 功能描述\n创建并显示ResourceLoaderWindow实例。如果已有实例存在，直接显示该实例。\n\n#### 算法说明\n直接调用EditorWindow.GetWindow方法创建或显示窗口实例。\n\n#### 调用关系\n- 被MenuItem属性触发，当用户在菜单中选择\"ZTResource/资源导入场景\"时调用\n\n### 3.2 OnGUI()\n\n#### 方法签名\n```csharp\nvoid OnGUI()\n```\n\n#### 功能描述\n绘制编辑器窗口的用户界面，包括滚动视图、文本输入区域和加载按钮。\n\n#### 功能步骤\n1. 绘制标签文本\n2. 创建滚动",
    "chunk_order_index": 0,
    "full_doc_id": "doc-4fe31fb4a97c2c6c9710002da4ccf739"
  },
  "chunk-7818c9de640f741a13b23a73fffadd0b": {
    "tokens": 642,
    "content": "。\n\n#### 调用关系\n- 被MenuItem属性触发，当用户在菜单中选择\"ZTResource/资源导入场景\"时调用\n\n### 3.2 OnGUI()\n\n#### 方法签名\n```csharp\nvoid OnGUI()\n```\n\n#### 功能描述\n绘制编辑器窗口的用户界面，包括滚动视图、文本输入区域和加载按钮。\n\n#### 功能步骤\n1. 绘制标签文本\n2. 创建滚动视图\n3. 添加文本输入区域，允许用户粘贴多行预制体路径\n4. 添加加载按钮，点击后调用LoadPrefabsIntoScene方法\n\n#### 调用关系\n- 由Unity编辑器框架自动调用，每帧绘制界面\n\n### 3.3 LoadPrefabsIntoScene(string paths)\n\n#### 方法签名\n```csharp\nvoid LoadPrefabsIntoScene(string paths)\n```\n\n#### 功能描述\n将输入的多行预制体路径转换为预制体实例，加载到当前场景中。\n\n#### 功能步骤\n1. 按换行符分割输入字符串为路径数组\n2. 遍历每个路径，清理空白字符\n3. 加载预制体，如果成功则实例化并记录日志\n4. 最终选中所有实例化的预制体\n\n#### 算法说明\n- 使用Split('\\n')分割路径字符串\n- 使用Trim()清理路径空白字符\n- 使用AssetDatabase.LoadAssetAtPath<GameObject>加载预制体\n- 使用PrefabUtility.InstantiatePrefab实例化预制体\n\n#### 调用关系\n- 由OnGUI中的加载按钮点击事件触发\n- 每次按钮点击时调用一次\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class EditorWindow {\n        +void OnGUI()\n        +static EditorWindow GetWindow(System.Type type, bool focus, string title)\n    }\n\n    class MonoBehaviour {\n        +void Awake()\n        +void Start()\n        +void Update()\n    }\n\n    class ResourceLoaderWindow <<Abstract>> {\n        +void OnGUI()\n        +void LoadPrefabsIntoScene(string paths)\n        +static void ShowWindow()\n    }\n\n    ResourceLoaderWindow --> EditorWindow : inheritance\n    EditorWindow --> MonoBehaviour : inheritance\n\n    ResourceLoaderWindow --> AssetDatabase : dependency\n    ResourceLoaderWindow --> PrefabUtility : dependency\n    ResourceLoaderWindow --> Debug : dependency\n    ResourceLoaderWindow --> GameObject : dependency\n```\n\n---\n\n## 总结\n\n该脚本文件提供了一个实用的预制体加载工具，通过Unity编辑器扩展实现。核心类ResourceLoaderWindow通过继承EditorWindow实现了自定义编辑器窗口，提供了用户友好的界面和批量加载功能。关键方法ShowWindow、OnGUI和LoadPrefabsIntoScene分别负责窗口显示、界面绘制和预制体加载。整体设计简洁高效，适合用于Unity开发中的预制体资源管理。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-4fe31fb4a97c2c6c9710002da4ccf739"
  },
  "chunk-12cf8b98f5d7bfc8e1c5a97e05277b19": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n﻿#if UNITY_EDITOR\nusing System.IO;\nusing UnityEditor;\nusing UnityEngine;\nusing System.Text;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class CombineCSFilesEditor : EditorWindow\n{\n    private List<string> filePaths = new List<string>();\n    private HashSet<string> directories = new HashSet<string>();\n    private string outputPath = \"Assets/GPT/ZTResource.txt\";\n    private int selectedEncodingIndex = 0;\n    private int maxCharsPerFile = 200000;\n    private Vector2 scrollPosition;\n\n    private static readonly Dictionary<string, Encoding> Encodings = new Dictionary<string, Encoding>\n    {\n        {\"UTF-8 (no BOM)\", new UTF8Encoding(false)},\n        {\"UTF-8 (with BOM)\", new UTF8Encoding(true)},\n        {\"ASCII\", Encoding.ASCII},\n        {\"Unicode\", Encoding.Unicode},\n        {\"BigEndianUnicode\", Encoding.BigEndianUnicode},\n        {\"UTF-32\", Encoding.UTF32},\n        {\"GB2312\", Encoding.GetEncoding(\"GB2312\")},\n        {\"Default\", Encoding.Default}\n    };\n\n    [MenuItem(\"ZTResource/Tools/其他/合并CS文件\")]\n    public static void ShowWindow()\n    {\n        GetWindow<CombineCSFilesEditor>(\"合并 CS 文件\");\n    }\n\n    private void OnGUI()\n    {\n        GUILayout.Label(\"合并 CS 文件\", EditorStyles.boldLabel);\n        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);\n\n        HandleDragAndDrop();\n\n        EditorGUILayout.Space();\n        GUILayout.Label(\"已添加内容:\");\n        DisplayPathsWithRemoveButton(directories.ToList(), directories, \"目录\");\n        DisplayPathsWithRemoveButton(filePaths, null, \"文件\");\n\n        EditorGUILayout.Space();\n        GUILayout.Label(\"输出设置:\", EditorStyles.boldLabel);\n        outputPath = EditorGUILayout.TextField(\"输出路径:\", outputPath).Replace('\\\\', '/');\n        selectedEncodingIndex = EditorGUILayout.Popup(\"文件编码:\", selectedEncodingIndex, Encodings.Keys.ToArray());\n        maxCharsPerFile = EditorGUILayout.IntField(\"单个文件最大字符数:\", maxCharsPerFile);\n\n        EditorGUILayout.Space();\n        if (GUILayout.Button(\"生成合并文件\", GUILayout.Height(30)))\n        {\n            CombineFiles(outputPath, Encodings.Keys.ToArray()[selectedEncodingIndex]);\n        }\n\n        EditorGUILayout.EndScrollView();\n    }\n\n    private void HandleDragAndDrop()\n    {\n        Event evt = Event.current;\n        Rect dropArea = GUILayoutUtility.GetRect(0.0f, 50.0f, GUILayout.ExpandWidth(true));\n        GUI.Box(dropArea, \"拖拽文件夹或文件到这里\", EditorStyles.helpBox);\n\n        switch (evt.type)\n        {\n            case EventType.DragUpdated:\n            case EventType.DragPerform:\n                if (!dropArea.Contains(evt.mousePosition)) return;\n\n                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;\n\n                if (evt.type == EventType.DragPerform)\n                {\n                    DragAndDrop.AcceptDrag();\n                    foreach (string path in DragAndDrop.paths)\n                    {\n                        string normalizedPath = path.Replace('\\\\', '/');\n                        if (Directory.Exists(normalizedPath))\n                        {\n                            directories.Add(normalizedPath);\n                        }\n                        else if (File.Exists(normalizedPath) && Path.GetExtension(normalizedPath).Equals(\".cs\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            filePaths.Add(normalizedPath);\n                        }\n                    }\n                }\n                Event.current.Use();\n                break;\n        }\n    }\n\n    private void CombineFiles(string output, string encodingName)\n    {\n        try\n        {\n            output = output.Replace('\\\\', '/');\n            List<string> allFiles = new List<string>(filePaths);\n\n            foreach (string directory in directories)\n            {\n                allFiles.AddRange(Directory.GetFiles(directory, \"*.cs\", SearchOption.AllDirectories)\n                    .Select(f => f.Replace('\\\\', '/'))\n                    .Where(f => !Path.GetFileName(f).StartsWith(\"._\")));\n            }\n\n            if (allFiles.Count == 0)\n            {\n                Debug.LogError(\"未选择任何文件\");\n                return;\n            }\n\n            Encoding encoding = Encodings[encodingName];\n            string directoryPath = Path.GetDirectoryName(output).Replace('\\\\', '/');\n            string fileName = Path.GetFileNameWithoutExtension(output);\n            string extension = Path.GetExtension(output);\n\n            int fileIndex = 1;\n            StringBuilder contentBuilder = new StringBuilder();\n            int totalProcessed = 0;\n\n            foreach (string file in allFiles)\n            {\n                string relativePath = GetRelativeProjectPath(file);\n                string content = $\"// ==========================\\n\" +\n                                $\"// Path: {relativePath}\\n\" +\n                                $\"// ==========================\\n\\n\" +\n                                $\"{ReadFileWithEncoding(file, encoding)}\\n\\n\";\n                content = NormalizeLineEndings(content, Environment.NewLine);\n\n                if (content.Length > maxCharsPerFile * 0.5f)\n                {\n                    if (contentBuilder.Length > 0)\n                    {\n                        WriteFile(directoryPath, fileName, extension, fileIndex++, contentBuilder.ToString(), encoding);\n                        contentBuilder.Clear();\n                    }\n                    WriteFile(directoryPath, fileName, extension, fileIndex++, content, encoding);\n                    continue;\n                }\n\n                if (contentBuilder.Length + content.Length > maxCharsPerFile)\n                {\n                    WriteFile(directoryPath, fileName, extension, fileIndex++, contentBuilder.ToString(), encoding);\n                    contentBuilder.Clear();\n                }\n\n                contentBuilder.Append(content);\n                totalProcessed++;\n\n                EditorUtility.DisplayProgressBar(\"合并进度\",\n                    $\"正在处理文件 ({totalProcessed}/{allFiles.Count})\",\n                    (float)totalProcessed / allFiles.Count);\n            }\n\n            if (contentBuilder.Length > 0)\n                WriteFile(directoryPath",
    "chunk_order_index": 0,
    "full_doc_id": "doc-fe99c774fb6835cf6842d7878aabedb2"
  },
  "chunk-8911c0cbb4e1a85a2373b81c39382a4d": {
    "tokens": 1200,
    "content": "> maxCharsPerFile)\n                {\n                    WriteFile(directoryPath, fileName, extension, fileIndex++, contentBuilder.ToString(), encoding);\n                    contentBuilder.Clear();\n                }\n\n                contentBuilder.Append(content);\n                totalProcessed++;\n\n                EditorUtility.DisplayProgressBar(\"合并进度\",\n                    $\"正在处理文件 ({totalProcessed}/{allFiles.Count})\",\n                    (float)totalProcessed / allFiles.Count);\n            }\n\n            if (contentBuilder.Length > 0)\n                WriteFile(directoryPath, fileName, extension, fileIndex, contentBuilder.ToString(), encoding);\n\n            AssetDatabase.Refresh();\n            EditorUtility.ClearProgressBar();\n            Debug.Log($\"合并完成！共生成 {fileIndex} 个文件\");\n        }\n        catch (Exception ex)\n        {\n            EditorUtility.ClearProgressBar();\n            Debug.LogError($\"合并失败: {ex.Message}\\n{ex.StackTrace}\");\n        }\n    }\n\n    private void WriteFile(string directory, string baseName, string extension, int index, string content, Encoding encoding)\n    {\n        string path = Path.Combine(directory, $\"{baseName}_{index}{extension}\").Replace('\\\\', '/');\n        File.WriteAllText(path, content, encoding);\n        Debug.Log($\"文件已生成：{GetRelativeProjectPath(path)} ({content.Length} 字符)\");\n    }\n\n    private string ReadFileWithEncoding(string path, Encoding encoding)\n    {\n        return File.ReadAllText(path, encoding);\n    }\n\n    private string NormalizeLineEndings(string text, string newLine)\n    {\n        return text.Replace(\"\\r\\n\", \"\\n\").Replace(\"\\r\", \"\\n\").Replace(\"\\n\", newLine);\n    }\n\n    private string GetRelativeProjectPath(string absolutePath)\n    {\n        string projectPath = Application.dataPath.Replace(\"/Assets\", \"\").Replace('\\\\', '/');\n        absolutePath = absolutePath.Replace('\\\\', '/');\n\n        if (absolutePath.StartsWith(projectPath))\n        {\n            return absolutePath.Substring(projectPath.Length + 1);\n        }\n        return absolutePath;\n    }\n\n    private void DisplayPathsWithRemoveButton(List<string> paths, HashSet<string> pathSet, string label)\n    {\n        EditorGUILayout.BeginVertical(GUI.skin.box);\n        GUILayout.Label($\"{label} ({paths.Count}):\");\n\n        for (int i = 0; i < paths.Count; i++)\n        {\n            EditorGUILayout.BeginHorizontal();\n            EditorGUILayout.LabelField(GetRelativeProjectPath(paths[i]), EditorStyles.wordWrappedLabel);\n            if (GUILayout.Button(\"×\", GUILayout.Width(20)))\n            {\n                if (pathSet != null) pathSet.Remove(paths[i]);\n                else filePaths.RemoveAt(i);\n            }\n            EditorGUILayout.EndHorizontal();\n        }\n        EditorGUILayout.EndVertical();\n    }\n}\n#endif\n源代码内容解释如下：\n```markdown\n# 代码文件分析报告\n\n## 1. 功能概览\n\n- **功能定位**：这是一个Unity编辑器工具，用于合并多个C#文件（.cs）到一个或多个目标文件中。它支持拖放文件或文件夹，提供编码选择和文件分割功能。\n- **角色与重要性**：在Unity项目中，当需要将多个脚本文件合并成一个或多个较大的文件时，此工具非常有用。它简化了手动合并文件的过程，减少了人为错误，并提高了开发效率。\n- **主要特性与技术实现**：\n  - **拖放功能**：支持将文件或文件夹拖放到编辑器窗口中。\n  - **编码选择**：提供多种编码格式（如UTF-8、Unicode等）供用户选择。\n  - **文件分割**：根据设置的最大字符数自动分割文件。\n  - **进度显示**：在合并过程中显示进度条，便于用户了解处理状态。\n\n## 2. 核心类解析\n\n### CombineCSFilesEditor\n\n- **职责说明**：该类是一个Unity编辑器窗口，主要用于处理文件合并逻辑，包括文件的拖放、选择、合并和输出设置。\n- **关键方法清单**：\n  - `OnGUI()`：绘制编辑器窗口的UI界面。\n  - `HandleDragAndDrop()`：处理文件或文件夹的拖放事件。\n  - `CombineFiles(string output, string encodingName)`：合并文件的核心逻辑。\n  - `WriteFile(string directory, string baseName, string extension, int index, string content, Encoding encoding)`：将合并后的内容写入文件。\n  - `ReadFileWithEncoding(string path, Encoding encoding)`：读取文件内容并指定编码。\n  - `NormalizeLineEndings(string text, string newLine)`：标准化文本中的换行符。\n  - `GetRelativeProjectPath(string absolutePath)`：获取文件的相对路径。\n  - `DisplayPathsWithRemoveButton(List<string> paths, HashSet<string> pathSet, string label)`：显示已添加的文件或文件夹，并提供删除功能。\n- **继承关系**：\n  ```mermaid\n  CombineCSFilesEditor --> EditorWindow\n  ```\n- **依赖模块**：\n  - `UnityEditor`：用于编辑器窗口和相关功能。\n  - `UnityEngine`：Unity核心功能。\n  - `System.IO`：文件操作。\n  - `System.Text`：编码处理。\n  - `System.Linq`：集合操作。\n  - `System.Collections.Generic`：泛型集合。\n  - `System`：基础功能。\n\n## 3. 关键方法详解\n\n### `OnGUI()`\n\n- **方法签名**：`private void OnGUI()`\n- **功能描述**：负责绘制编辑器窗口的用户界面，包括标题、",
    "chunk_order_index": 1,
    "full_doc_id": "doc-fe99c774fb6835cf6842d7878aabedb2"
  },
  "chunk-aa59f44ed884540cfac0c9e53813bb2b": {
    "tokens": 994,
    "content": "- `System.IO`：文件操作。\n  - `System.Text`：编码处理。\n  - `System.Linq`：集合操作。\n  - `System.Collections.Generic`：泛型集合。\n  - `System`：基础功能。\n\n## 3. 关键方法详解\n\n### `OnGUI()`\n\n- **方法签名**：`private void OnGUI()`\n- **功能描述**：负责绘制编辑器窗口的用户界面，包括标题、拖放区域、已添加文件列表、输出设置和生成按钮。\n- **调用关系**：此方法在Unity编辑器窗口生命周期中自动调用，频率为每次窗口更新。\n\n### `HandleDragAndDrop()`\n\n- **方法签名**：`private void HandleDragAndDrop()`\n- **功能描述**：处理文件或文件夹的拖放事件，更新文件路径列表。\n- **调用关系**：在`OnGUI()`中被调用，频率为每次拖放操作。\n\n### `CombineFiles(string output, string encodingName)`\n\n- **方法签名**：`private void CombineFiles(string output, string encodingName)`\n- **功能描述**：合并所有选定的C#文件到目标文件中。如果文件内容超过最大字符数，则自动分割成多个文件。\n- **算法说明**：遍历所有选定文件，读取内容并合并，根据字符数限制分割文件。\n- **调用关系**：在`OnGUI()`中被生成按钮调用，频率为用户点击生成按钮时。\n\n### `WriteFile(string directory, string baseName, string extension, int index, string content, Encoding encoding)`\n\n- **方法签名**：`private void WriteFile(string directory, string baseName, string extension, int index, string content, Encoding encoding)`\n- **功能描述**：将合并后的内容写入指定文件。\n- **调用关系**：在`CombineFiles()`中被调用，频率为每次需要写入新文件时。\n\n### `ReadFileWithEncoding(string path, Encoding encoding)`\n\n- **方法签名**：`private string ReadFileWithEncoding(string path, Encoding encoding)`\n- **功能描述**：读取指定路径的文件内容，并使用指定的编码。\n- **调用关系**：在`CombineFiles()`中被调用，频率为每次读取文件时。\n\n### `NormalizeLineEndings(string text, string newLine)`\n\n- **方法签名**：`private string NormalizeLineEndings(string text, string newLine)`\n- **功能描述**：将文本中的换行符统一为指定格式。\n- **调用关系**：在`CombineFiles()`中被调用，频率为每次处理文件内容时。\n\n### `GetRelativeProjectPath(string absolutePath)`\n\n- **方法签名**：`private string GetRelativeProjectPath(string absolutePath)`\n- **功能描述**：将绝对路径转换为相对于项目路径的相对路径。\n- **调用关系**：在`DisplayPathsWithRemoveButton()`和`WriteFile()`中被调用，频率为需要显示或记录路径时。\n\n### `DisplayPathsWithRemoveButton(List<string> paths, HashSet<string> pathSet, string label)`\n\n- **方法签名**：`private void DisplayPathsWithRemoveButton(List<string> paths, HashSet<string> pathSet, string label)`\n- **功能描述**：显示已添加的文件或文件夹，并提供删除功能。\n- **调用关系**：在`OnGUI()`中被调用，频率为每次窗口更新时。\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class CombineCSFilesEditor {\n        #filePathList: List<string>\n        #directories: HashSet<string>\n        #outputPath: string\n        #selectedEncodingIndex: int\n        #maxCharsPerFile: int\n        #scrollPosition: Vector2\n        #Encodings: Dictionary<string, Encoding>\n\n        +OnGUI()\n        +HandleDragAndDrop()\n        +CombineFiles(string, string)\n        +WriteFile(string, string, string, int, string, Encoding)\n        +ReadFileWithEncoding(string, Encoding)\n        +NormalizeLineEndings(string, string)\n        +GetRelativeProjectPath(string)\n        +DisplayPathsWithRemoveButton(List<string>, HashSet<string>, string)\n    }\n\n    CombineCSFilesEditor --> EditorWindow\n    CombineCSFilesEditor --> System.IO\n    CombineCSFilesEditor --> UnityEditor\n    CombineCSFilesEditor --> UnityEngine\n    CombineCSFilesEditor --> System.Text\n    CombineCSFilesEditor --> System.Linq\n    CombineCSFilesEditor --> System.Collections.Generic\n    CombineCSFilesEditor --> System\n```",
    "chunk_order_index": 2,
    "full_doc_id": "doc-fe99c774fb6835cf6842d7878aabedb2"
  },
  "chunk-2cae35a0d0cc0ac42430755a0f094106": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing UnityEditor;\nusing UnityEngine;\n\n/// <summary>\n/// 给所有携带ResourceInfo的物体，整体更新一次长宽高计算，并提供复制、粘贴、清除标签的功能\n/// </summary>\npublic class ResourceInfoUpdater : EditorWindow\n{\n    private HashSet<string> directories = new HashSet<string>(); // 存储拖拽的文件夹路径\n    private HashSet<string> specificPrefabPaths = new HashSet<string>(); // 存储直接粘贴的预制体路径\n    private string pastedPathsText = string.Empty; // 存储粘贴区域的文本\n    private Vector2 scrollPosition; // 滚动视图的位置\n    // 用于保存复制的标签\n    private Dictionary<string, List<string>> copiedTags = new Dictionary<string, List<string>>();\n\n    [MenuItem(\"ZTResource/Tools/更新-长宽高\", false, 9)]\n    public static void ShowWindow()\n    {\n        GetWindow<ResourceInfoUpdater>(\"ResourceInfo编辑工具\");\n    }\n\n    private void OnGUI()\n    {\n        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition); // 开始滚动视图\n\n        GUILayout.Label(\"更新所有预制体信息\", EditorStyles.boldLabel);\n\n        // 显示拖拽区域\n        GUILayout.Label(\"拖拽文件夹到这里:\");\n        HandleDragAndDrop();\n\n        // 显示当前已添加的文件夹\n        GUILayout.Label(\"已添加的文件夹:\");\n        DisplayPathsWithRemoveButton(directories.ToList(), directories);\n\n        GUILayout.Space(10);\n\n        // 新增的粘贴区域\n        GUILayout.Label(\"直接粘贴预制体路径:\");\n        pastedPathsText = EditorGUILayout.TextArea(pastedPathsText, GUILayout.Height(60));\n        if (GUILayout.Button(\"添加粘贴的路径\"))\n        {\n            AddPastedPaths();\n        }\n\n        // 显示已添加的直接粘贴的预制体路径\n        if (specificPrefabPaths.Count > 0)\n        {\n            GUILayout.Label(\"已添加的预制体路径:\");\n            DisplayPathsWithRemoveButton(specificPrefabPaths.ToList(), specificPrefabPaths);\n        }\n\n        GUILayout.Space(10);\n\n        if (GUILayout.Button(\"ALL更新信息\"))\n        {\n            UpdateAllResourceInfo();\n        }\n\n        GUILayout.Space(10);\n\n        if (GUILayout.Button(\"复制标签\"))\n        {\n            CopyTagsFromSelected();\n        }\n\n        if (GUILayout.Button(\"粘贴标签\"))\n        {\n            PasteTagsToSelected();\n        }\n\n        if (GUILayout.Button(\"清除所有标签\"))\n        {\n            ClearAllTagsFromSelected();\n        }\n\n        EditorGUILayout.EndScrollView(); // 结束滚动视图\n    }\n\n    private void HandleDragAndDrop()\n    {\n        Event evt = Event.current;\n        Rect dropArea = GUILayoutUtility.GetRect(0.0f, 50.0f, GUILayout.ExpandWidth(true));\n        GUI.Box(dropArea, \"拖拽文件夹或预制体到这里\");\n\n        switch (evt.type)\n        {\n            case EventType.DragUpdated:\n            case EventType.DragPerform:\n                if (!dropArea.Contains(evt.mousePosition))\n                    return;\n\n                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;\n\n                if (evt.type == EventType.DragPerform)\n                {\n                    DragAndDrop.AcceptDrag();\n\n                    foreach (string draggedObject in DragAndDrop.paths)\n                    {\n                        if (Directory.Exists(draggedObject))\n                        {\n                            // 如果是文件夹，添加文件夹路径\n                            directories.Add(draggedObject);\n                        }\n                        else if (draggedObject.EndsWith(\".prefab\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            // 如果是预制体，添加预制体路径\n                            specificPrefabPaths.Add(draggedObject);\n                        }\n                    }\n                }\n                Event.current.Use();\n                break;\n        }\n    }\n\n    private void AddPastedPaths()\n    {\n        if (string.IsNullOrWhiteSpace(pastedPathsText))\n        {\n            Debug.LogWarning(\"粘贴区域为空！\");\n            return;\n        }\n\n        string[] paths = pastedPathsText.Split(new[] { '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries);\n        int addedCount = 0;\n\n        foreach (string path in paths)\n        {\n            string trimmedPath = path.Trim();\n            if (trimmedPath.EndsWith(\".prefab\", StringComparison.OrdinalIgnoreCase))\n            {\n                if (AssetDatabase.LoadAssetAtPath<GameObject>(trimmedPath) != null)\n                {\n                    if (specificPrefabPaths.Add(trimmedPath))\n                    {\n                        addedCount++;\n                    }\n                }\n                else\n                {\n                    Debug.LogWarning($\"无效的预制体路径：{trimmedPath}\");\n                }\n            }\n            else\n            {\n                Debug.LogWarning($\"路径不是预制体文件：{trimmedPath}\");\n            }\n        }\n\n        pastedPathsText = string.Empty; // 清空粘贴区域\n        if (addedCount > 0)\n        {\n            Debug.Log($\"成功添加了 {addedCount} 个预制体路径！\");\n        }\n        else\n        {\n            Debug.LogWarning(\"没有有效的预制体路径被添加！\");\n        }\n    }\n\n    private void UpdateAllResourceInfoDimensions()\n    {\n        List<string> allFiles = GetAllPrefabPaths();\n        int updatedCount = 0;\n\n        foreach (string path in allFiles)\n        {\n            GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);\n            if (prefab == null)\n                continue;\n\n            ResourceInfo resourceInfo = prefab.GetComponent",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b1b084ee025ad45924da42c36ac080aa"
  },
  "chunk-b8c06faba0b3cb008bbf5505ada3d7e4": {
    "tokens": 1200,
    "content": "{\n            Debug.LogWarning(\"没有有效的预制体路径被添加！\");\n        }\n    }\n\n    private void UpdateAllResourceInfoDimensions()\n    {\n        List<string> allFiles = GetAllPrefabPaths();\n        int updatedCount = 0;\n\n        foreach (string path in allFiles)\n        {\n            GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);\n            if (prefab == null)\n                continue;\n\n            ResourceInfo resourceInfo = prefab.GetComponent<ResourceInfo>();\n            if (resourceInfo != null)\n            {\n                string dimensions = CalculatePrefabDimensions(prefab);\n                resourceInfo.itemHeight = dimensions;\n\n                EditorUtility.SetDirty(resourceInfo);\n                updatedCount++;\n            }\n        }\n\n        AssetDatabase.SaveAssets();\n        AssetDatabase.Refresh();\n        Debug.Log($\"更新了 {updatedCount} 个预制体的尺寸。\");\n    }\n\n    private void UpdateAllResourceInfo()\n    {\n        List<string> allFiles = GetAllPrefabPaths();\n        int updatedCount = 0;\n\n        foreach (string path in allFiles)\n        {\n            GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(path);\n            if (prefab == null)\n                continue;\n\n            ResourceInfo resourceInfo = prefab.GetComponent<ResourceInfo>();\n            if (resourceInfo != null)\n            {\n                RefreshThumbnail(resourceInfo);\n                RefreshData(resourceInfo);\n\n                EditorUtility.SetDirty(resourceInfo);\n                updatedCount++;\n            }\n        }\n\n        AssetDatabase.SaveAssets();\n        AssetDatabase.Refresh();\n        Debug.Log($\"更新了 {updatedCount} 个预制体的信息。\");\n    }\n\n\n    private List<string> GetAllPrefabPaths()\n    {\n        List<string> allFiles = new List<string>();\n        foreach (string directory in directories)\n        {\n            allFiles.AddRange(Directory.GetFiles(directory, \"*.prefab\", SearchOption.AllDirectories));\n        }\n\n        allFiles.AddRange(specificPrefabPaths);\n\n        // 去重\n        return allFiles.Distinct().ToList();\n    }\n\n    private void RefreshData(ResourceInfo resourceInfo)\n    {\n        if (resourceInfo != null && resourceInfo.gameObject != null)\n        {\n            // 获取预制体的路径并去除公共部分和文件后缀\n            string prefabPath = AssetDatabase.GetAssetPath(resourceInfo.gameObject);\n            string basePath = \"Assets/ArtResource/Scenes/Standard/\";\n\n            // 去掉公共部分路径\n            if (prefabPath.StartsWith(basePath))\n            {\n                prefabPath = prefabPath.Substring(basePath.Length);\n            }\n\n            // 去除文件后缀\n            string prefabPathWithoutExtension = Path.ChangeExtension(prefabPath, null);\n            resourceInfo.id = prefabPathWithoutExtension;\n\n            string facesCount = CalculateModelFaces(resourceInfo.gameObject);\n            resourceInfo.modelFaces = facesCount;\n\n            string dimensions = CalculatePrefabDimensions(resourceInfo.gameObject);\n            resourceInfo.itemHeight = dimensions;\n        }\n    }\n\n    private void RefreshThumbnail(ResourceInfo resourceInfo)\n    {\n        if (resourceInfo == null)\n        {\n            Debug.LogWarning(\"ResourceInfo 脚本未找到！\");\n            return;\n        }\n\n        // 获取预制体的路径\n        string prefabPath = AssetDatabase.GetAssetPath(resourceInfo.gameObject);\n        if (string.IsNullOrEmpty(prefabPath) || !prefabPath.EndsWith(\".prefab\"))\n        {\n            Debug.LogWarning(\"无法找到预制体的路径，或者选择的不是一个预制体！\");\n            return;\n        }\n\n        // 去除公共部分路径\n        string basePath = \"Assets/ArtResource/Scenes/Standard/\";\n        if (prefabPath.StartsWith(basePath))\n        {\n            prefabPath = prefabPath.Substring(basePath.Length);\n        }\n\n        // 删除路径中的“/”符号\n        string modifiedPrefabPath = prefabPath.Replace(\"/\", \"\");\n\n        // 去除文件后缀\n        string prefabName = Path.GetFileNameWithoutExtension(modifiedPrefabPath);\n\n        // 构建缩略图路径\n        string thumbnailPath = $\"Assets/ZTResource/Resources/ZT_IconTextures/{prefabName}.png\";\n        Texture2D newThumbnail = AssetDatabase.LoadAssetAtPath<Texture2D>(thumbnailPath);\n\n        if (newThumbnail)\n        {\n            resourceInfo.thumbnailPath = prefabName;\n            EditorUtility.SetDirty(resourceInfo);\n\n            Debug.Log(\"缩略图已更新！\");\n        }\n        else\n        {\n            Debug.LogWarning($\"未找到缩略图文件：{thumbnailPath}\");\n        }\n    }\n\n    private string CalculateModelFaces(GameObject prefab)\n    {\n        int totalFaces = 0;\n        MeshFilter[] meshFilters = prefab.GetComponentsInChildren<MeshFilter>();\n        foreach (MeshFilter meshFilter in meshFilters)\n        {\n            if (meshFilter.sharedMesh != null)\n            {\n                totalFaces += meshFilter.sharedMesh.triangles.Length / 3;\n            }\n        }\n        return totalFaces.ToString();\n    }\n\n    private string CalculatePrefabDimensions(GameObject prefab)\n    {\n        Renderer[] renderers = prefab.GetComponentsInChildren<Renderer>();\n\n        if (renderers.Length == 0)\n        {\n            Debug.Log(\"预制体中没有找到任何模型\");\n            return string.Empty;\n        }\n\n        Bounds overallBounds = renderers[0].bounds;\n\n        foreach (Renderer renderer in renderers)\n        {\n            overallBounds.Encapsulate(renderer.bounds);\n        }\n\n        float length = Mathf.Round(overallBounds.size.x * 10) / 10f;\n        float width = Mathf.Round(overallBounds.size.z * 10) / 10f;\n        float height = Mathf.Round(overallBounds.size.y * 10) / 10f;\n\n        return $\"{length}|{width}|{height}\";\n    }\n\n    private void DisplayPathsWithRemoveButton(List<string> paths,",
    "chunk_order_index": 1,
    "full_doc_id": "doc-b1b084ee025ad45924da42c36ac080aa"
  },
  "chunk-5b8555d34d1db2945810df79ad289bc6": {
    "tokens": 1200,
    "content": "{\n            overallBounds.Encapsulate(renderer.bounds);\n        }\n\n        float length = Mathf.Round(overallBounds.size.x * 10) / 10f;\n        float width = Mathf.Round(overallBounds.size.z * 10) / 10f;\n        float height = Mathf.Round(overallBounds.size.y * 10) / 10f;\n\n        return $\"{length}|{width}|{height}\";\n    }\n\n    private void DisplayPathsWithRemoveButton(List<string> paths, HashSet<string> pathSet)\n    {\n        for (int i = 0; i < paths.Count; i++)\n        {\n            GUILayout.BeginHorizontal();\n            GUILayout.Label(paths[i]);\n            if (GUILayout.Button(\"移除\", GUILayout.Width(60)))\n            {\n                pathSet.Remove(paths[i]);\n            }\n            GUILayout.EndHorizontal();\n        }\n    }\n\n    // 复制标签\n    private void CopyTagsFromSelected()\n    {\n        copiedTags.Clear();\n\n        GameObject[] selectedObjects = Selection.gameObjects;\n        if (selectedObjects.Length == 0)\n        {\n            Debug.LogWarning(\"没有选中的预制体！\");\n            return;\n        }\n\n        ResourceInfo resourceInfo = selectedObjects[0].GetComponent<ResourceInfo>();\n        if (resourceInfo == null)\n        {\n            Debug.LogWarning(\"选中的对象没有ResourceInfo组件！\");\n            return;\n        }\n\n        copiedTags[\"TypeTags\"] = new List<string>(resourceInfo.typeTags);\n        copiedTags[\"ThemeTags\"] = new List<string>(resourceInfo.themeTags);\n        copiedTags[\"DefinitionTags\"] = new List<string>(resourceInfo.definitionTags);\n        copiedTags[\"FunctionTags\"] = new List<string>(resourceInfo.functionTags);\n        copiedTags[\"BatchTags\"] = new List<string>(resourceInfo.batchTags);\n        copiedTags[\"PropertyTags\"] = new List<string>(resourceInfo.propertyTags);\n\n        Debug.Log(\"标签已复制！\");\n    }\n\n    // 粘贴标签\n    private void PasteTagsToSelected()\n    {\n        if (copiedTags.Count == 0)\n        {\n            Debug.LogWarning(\"没有复制的标签可粘贴！\");\n            return;\n        }\n\n        GameObject[] selectedObjects = Selection.gameObjects;\n        if (selectedObjects.Length == 0)\n        {\n            Debug.LogWarning(\"没有选中的预制体！\");\n            return;\n        }\n\n        foreach (GameObject selectedObject in selectedObjects)\n        {\n            ResourceInfo resourceInfo = selectedObject.GetComponent<ResourceInfo>();\n            if (resourceInfo == null)\n            {\n                Debug.LogWarning($\"选中的对象 {selectedObject.name} 没有ResourceInfo组件！\");\n                continue;\n            }\n\n            PasteTagsToList(ref resourceInfo.typeTags, \"TypeTags\");\n            PasteTagsToList(ref resourceInfo.themeTags, \"ThemeTags\");\n            PasteTagsToList(ref resourceInfo.definitionTags, \"DefinitionTags\");\n            PasteTagsToList(ref resourceInfo.functionTags, \"FunctionTags\");\n            PasteTagsToList(ref resourceInfo.batchTags, \"BatchTags\");\n            PasteTagsToList(ref resourceInfo.propertyTags, \"PropertyTags\");\n\n            EditorUtility.SetDirty(resourceInfo);\n        }\n\n        AssetDatabase.SaveAssets();\n        Debug.Log(\"标签已粘贴到选中的所有预制体！\");\n    }\n\n    // 清除所有标签\n    private void ClearAllTagsFromSelected()\n    {\n        GameObject[] selectedObjects = Selection.gameObjects;\n        if (selectedObjects.Length == 0)\n        {\n            Debug.LogWarning(\"没有选中的预制体！\");\n            return;\n        }\n\n        foreach (GameObject selectedObject in selectedObjects)\n        {\n            ResourceInfo resourceInfo = selectedObject.GetComponent<ResourceInfo>();\n            if (resourceInfo == null)\n            {\n                Debug.LogWarning($\"选中的对象 {selectedObject.name} 没有ResourceInfo组件！\");\n                continue;\n            }\n\n            ClearTagsList(ref resourceInfo.typeTags);\n            ClearTagsList(ref resourceInfo.themeTags);\n            ClearTagsList(ref resourceInfo.definitionTags);\n            ClearTagsList(ref resourceInfo.functionTags);\n            ClearTagsList(ref resourceInfo.batchTags);\n            ClearTagsList(ref resourceInfo.propertyTags);\n\n            EditorUtility.SetDirty(resourceInfo);\n        }\n\n        AssetDatabase.SaveAssets();\n        Debug.Log(\"已清除选中预制体的所有标签！\");\n    }\n\n    private void PasteTagsToList(ref List<string> tags, string tagType)\n    {\n        if (tags == null)\n        {\n            tags = new List<string>();\n        }\n\n        tags.Clear();\n        if (copiedTags.ContainsKey(tagType))\n        {\n            tags.AddRange(copiedTags[tagType]);\n        }\n    }\n\n    private void ClearTagsList(ref List<string> tags)\n    {\n        if (tags != null)\n        {\n            tags.Clear();\n        }\n    }\n}\n\n#endif\n\n源代码内容解释如下：\n### 1. 功能概览\n\n- **功能定位**：ResourceInfoUpdater 是一个 Unity 编辑器扩展工具，用于批量更新预制体（Prefab）的尺寸信息、标签以及缩略图。它允许用户通过拖放文件夹或直接粘贴路径来添加需要处理的预制体，并提供复制、粘贴和清除标签的功能。\n\n- **角色和重要性**：该工具在项目中扮演辅助开发的角色，帮助开发者高效地管理预制体的元数据，提升开发效率。它通过自动化处理预制体信息，减少了手动操作的错误率和时间成本。\n\n- **主要特性与技术实现**：\n  - **批量处理**：支持通过拖放文件夹或粘贴路径来批量处理多个预制体。\n  - **尺寸计算**：自动计算预制体的长宽高，并更新到 ResourceInfo 组件。\n  - **标签管理**：提供复制",
    "chunk_order_index": 2,
    "full_doc_id": "doc-b1b084ee025ad45924da42c36ac080aa"
  },
  "chunk-4e67e4735dd2bce0daa0a86c30a4eb6c": {
    "tokens": 1200,
    "content": "元数据，提升开发效率。它通过自动化处理预制体信息，减少了手动操作的错误率和时间成本。\n\n- **主要特性与技术实现**：\n  - **批量处理**：支持通过拖放文件夹或粘贴路径来批量处理多个预制体。\n  - **尺寸计算**：自动计算预制体的长宽高，并更新到 ResourceInfo 组件。\n  - **标签管理**：提供复制、粘贴和清除标签的功能，便于统一管理预制体的分类信息。\n  - **缩略图更新**：根据预制体路径自动更新缩略图路径。\n  - **技术实现**：使用 Unity 的 Editor API（如 AssetDatabase、EditorWindow）和文件处理技术实现功能。\n\n---\n\n### 2. 核心类解析\n\n#### `ResourceInfoUpdater`\n\n- **职责说明**：该类的主要职责是提供一个自定义编辑器窗口，允许用户拖放文件夹或粘贴预制体路径，批量更新预制体的尺寸信息、标签和缩略图。它通过与 Unity 编辑器的交互，实现对预制体资源的高效管理。\n\n- **关键方法清单**：\n  - `OnGUI()`：绘制编辑器窗口的界面。\n  - `HandleDragAndDrop()`：处理拖放事件，添加文件夹或预制体路径。\n  - `UpdateAllResourceInfo()`：更新所有预制体的尺寸信息、标签和缩略图。\n  - `CopyTagsFromSelected()`、`PasteTagsToSelected()`、`ClearAllTagsFromSelected()`：管理预制体标签的复制、粘贴和清除操作。\n  - `CalculatePrefabDimensions()`：计算预制体的尺寸。\n\n- **继承关系**：\n  ```\n  ResourceInfoUpdater -> EditorWindow -> Object\n  ```\n\n- **依赖模块**：\n  - `UnityEngine`：用于访问 Unity 引擎的核心功能。\n  - ` UnityEditor`：用于访问 Unity 编辑器的扩展 API。\n  - `ResourceInfo`：预制体上附带的自定义组件，用于存储元数据。\n\n---\n\n### 3. 关键方法详解\n\n#### `OnGUI()`\n\n- **方法签名**：`private void OnGUI()`\n- **功能描述**：绘制编辑器窗口的界面，包括拖放区域、路径显示、按钮操作（更新信息、复制/粘贴/清除标签）等。\n- **调用关系**：由 Unity 编辑器自动调用，作为编辑器窗口的核心绘制方法，频率为每帧一次。\n\n#### `HandleDragAndDrop()`\n\n- **方法签名**：`private void HandleDragAndDrop()`\n- **功能描述**：处理拖放事件，允许用户拖放文件夹或预制体路径到编辑器窗口中。根据拖放内容的类型（文件夹或预制体），将其路径存储到相应的集合中。\n- **调用关系**：在 `OnGUI()` 中被调用，当用户进行拖放操作时触发。\n\n#### `UpdateAllResourceInfo()`\n\n- **方法签名**：`private void UpdateAllResourceInfo()`\n- **功能描述**：遍历所有已添加的预制体路径，更新每个预制体的 ResourceInfo 组件，包括尺寸信息、标签和缩略图。\n- **调用关系**：由 `OnGUI()` 中的按钮点击事件触发，每次点击按钮时执行一次。\n\n#### `CopyTagsFromSelected()`\n\n- **方法签名**：`private void CopyTagsFromSelected()`\n- **功能描述**：复制选中预制体的标签信息到一个字典中，以便后续粘贴。\n- **调用关系**：由 `OnGUI()` 中的“复制标签”按钮点击事件触发。\n\n#### `PasteTagsToSelected()`\n\n- **方法签名**：`private void PasteTagsToSelected()`\n- **功能描述**：将之前复制的标签信息粘贴到选中的预制体的 ResourceInfo 组件中。\n- **调用关系**：由 `OnGUI()` 中的“粘贴标签”按钮点击事件触发。\n\n#### `ClearAllTagsFromSelected()`\n\n- **方法签名**：`private void ClearAllTagsFromSelected()`\n- **功能描述**：清除选中预制体的 ResourceInfo 组件中的所有标签信息。\n- **调用关系**：由 `OnGUI()` 中的“清除所有标签”按钮点击事件触发。\n\n#### `CalculatePrefabDimensions(GameObject prefab)`\n\n- **方法签名**：`private string CalculatePrefabDimensions(GameObject prefab)`\n- **功能描述**：计算预制体的包围盒尺寸，并将其格式化为“长度|宽度|高度”的字符串。\n- **算法说明**：遍历预制体的所有 Renderer 组件，计算它们的包围盒，最终得到整体包围盒的尺寸。\n- **调用关系**：在 `UpdateAllResourceInfo()` 和 `RefreshData()` 中被调用，频率取决于需要更新的预制体数量。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class ResourceInfoUpdater {\n        <<EditorWindow>>\n        +HashSet<string> directories\n        +HashSet<string> specificPrefabPaths\n        +Dictionary<string, List<string>> copiedTags\n        +OnGUI()\n        +HandleDragAndDrop()\n        +UpdateAllResourceInfo()\n        +CopyTagsFromSelected()",
    "chunk_order_index": 3,
    "full_doc_id": "doc-b1b084ee025ad45924da42c36ac080aa"
  },
  "chunk-202e09cd771087d14819062a9dbd487f": {
    "tokens": 279,
    "content": "被调用，频率取决于需要更新的预制体数量。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class ResourceInfoUpdater {\n        <<EditorWindow>>\n        +HashSet<string> directories\n        +HashSet<string> specificPrefabPaths\n        +Dictionary<string, List<string>> copiedTags\n        +OnGUI()\n        +HandleDragAndDrop()\n        +UpdateAllResourceInfo()\n        +CopyTagsFromSelected()\n        +PasteTagsToSelected()\n        +ClearAllTagsFromSelected()\n        +CalculatePrefabDimensions(GameObject)\n    }\n\n    class EditorWindow {\n        <<Abstract>>\n    }\n\n    class Object {\n        <<Abstract>>\n    }\n\n    ResourceInfoUpdater --> EditorWindow\n    EditorWindow --> Object\n\n    class AssetDatabase {\n        <<Static>>\n        +LoadAssetAtPath<T>(string)\n        +SaveAssets()\n        +Refresh()\n    }\n\n    class ResourceInfo {\n        +string id\n        +string itemHeight\n        +string thumbnailPath\n        +List<string> typeTags\n        +List<string> themeTags\n        +List<string> definitionTags\n        +List<string> functionTags\n        +List<string> batchTags\n        +List<string> propertyTags\n    }\n\n    ResourceInfoUpdater --> AssetDatabase\n    ResourceInfoUpdater --> ResourceInfo\n```",
    "chunk_order_index": 4,
    "full_doc_id": "doc-b1b084ee025ad45924da42c36ac080aa"
  },
  "chunk-ece43cd9d74ce7b452cae63d5ea7ad0b": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\n\nusing UnityEngine;\nusing UnityEditor;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Globalization;\nusing System.Linq;\n\npublic class ResourceUpdater : EditorWindow\n{\n    private string csvFilePath = \"Assets/ZTResource/Resources/ZT_TagLibrary/ResourceIndexLibrary.csv\";\n    private List<string> prefabPaths = new List<string>(); // List of user-specified prefab paths\n    private Vector2 scrollPosition; // For scroll view\n    private Dictionary<string, GameObject> prefabCache = new Dictionary<string, GameObject>(); // Prefab cache\n\n    [MenuItem(\"ZTResource/Tools/CSV给资源添加Resourcelnfo\", false, 7)]\n    public static void ShowWindow()\n    {\n        GetWindow<ResourceUpdater>(\"CSV给资源添加Resourcelnfo\");\n    }\n\n    void OnGUI()\n    {\n        GUILayout.Label(\"CSV文件路径\", EditorStyles.boldLabel);\n        EditorGUILayout.BeginHorizontal();\n        csvFilePath = EditorGUILayout.TextField(csvFilePath);\n        if (GUILayout.Button(\"浏览\", GUILayout.Width(60)))\n        {\n            string path = EditorUtility.OpenFilePanel(\"选择CSV文件\", \"\", \"csv\");\n            if (!string.IsNullOrEmpty(path))\n            {\n                csvFilePath = \"Assets\" + path.Substring(Application.dataPath.Length); // Convert to relative path\n            }\n        }\n        EditorGUILayout.EndHorizontal();\n\n        GUILayout.Label(\"预制体路径\", EditorStyles.boldLabel);\n        HandleDragAndDrop();\n\n        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(200));\n        if (prefabPaths.Count > 0)\n        {\n            GUILayout.Label(\"已选择的预制体或文件夹：\");\n            DisplayPathsWithRemoveButton(prefabPaths);\n        }\n        EditorGUILayout.EndScrollView();\n\n        if (GUILayout.Button(\"载入\"))\n        {\n            UpdateResourceInfo();\n        }\n    }\n\n    private TagLibrary LoadTagLibrary(string name)\n    {\n        return AssetDatabase.LoadAssetAtPath<TagLibrary>($\"Assets/ZTResource/Resources/ZT_TagLibrary/{name}.asset\");\n    }\n\n    private HashSet<string> LoadAllTags()\n    {\n        var tagLibraries = new List<TagLibrary>\n        {\n            LoadTagLibrary(\"TypeTagLibrary\"),\n            LoadTagLibrary(\"ThemeTagLibrary\"),\n            LoadTagLibrary(\"FunctionTagLibrary\"),\n            LoadTagLibrary(\"DefinitionTagLibrary\"),\n            LoadTagLibrary(\"BatchTagLibrary\"),\n            LoadTagLibrary(\"PropertyTagLibrary\")\n        };\n\n        var allTags = new HashSet<string>();\n\n        foreach (var library in tagLibraries)\n        {\n            if (library != null)\n            {\n                foreach (var tag in library.tags)\n                {\n                    allTags.Add(tag);\n                }\n            }\n        }\n\n        return allTags;\n    }\n\n    private void HandleDragAndDrop()\n    {\n        Event evt = Event.current;\n        Rect dropArea = GUILayoutUtility.GetRect(0.0f, 50.0f, GUILayout.ExpandWidth(true));\n        GUI.Box(dropArea, \"拖拽预制体或文件夹到这里\");\n\n        switch (evt.type)\n        {\n            case EventType.DragUpdated:\n            case EventType.DragPerform:\n                if (!dropArea.Contains(evt.mousePosition))\n                    return;\n\n                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;\n\n                if (evt.type == EventType.DragPerform)\n                {\n                    DragAndDrop.AcceptDrag();\n\n                    foreach (string draggedObject in DragAndDrop.paths)\n                    {\n                        if (Directory.Exists(draggedObject) || File.Exists(draggedObject))\n                        {\n                            prefabPaths.Add(draggedObject);\n                        }\n                    }\n                }\n                Event.current.Use();\n                break;\n        }\n    }\n\n    private void DisplayPathsWithRemoveButton(List<string> paths)\n    {\n        for (int i = 0; i < paths.Count; i++)\n        {\n            GUILayout.BeginHorizontal();\n            GUILayout.Label(paths[i]);\n            if (GUILayout.Button(\"移除\", GUILayout.Width(60)))\n            {\n                paths.RemoveAt(i);\n            }\n            GUILayout.EndHorizontal();\n        }\n    }\n\n    private GameObject GetPrefab(string prefabPath)\n    {\n        if (!prefabCache.TryGetValue(prefabPath, out var prefab))\n        {\n            prefab = AssetDatabase.LoadAssetAtPath<GameObject>(prefabPath);\n            if (prefab != null)\n            {\n                prefabCache[prefabPath] = prefab;\n            }\n        }\n        return prefab;\n    }\n\n    private void UpdateResourceInfo()\n    {\n        if (!File.Exists(csvFilePath))\n        {\n            Debug.LogError(\"CSV文件不存在: \" + csvFilePath);\n            return;\n        }\n\n        var resourceDataList = LoadResourceData();\n        List<string> processedPrefabs = new List<string>();\n\n        foreach (var data in resourceDataList)\n        {\n            // 构建新的Prefab路径\n            string prefabPath = \"Assets/ArtResource/Scenes/Standard/\" + data.Id + \".prefab\";\n\n            if (prefabPaths.Count == 0)\n            {\n                if (ProcessPrefab(data, prefabPath))\n                {\n                    processedPrefabs.Add(prefabPath);\n                }\n            }\n            else\n            {\n                bool underSpecifiedPaths = false;\n                foreach (string path in prefabPaths)\n                {\n                    if (prefabPath.StartsWith(path))\n                    {\n                        underSpecifiedPaths = true;\n                        break;\n                    }\n                }\n\n                if (underSpecifiedPaths)\n                {\n                    if (ProcessPrefab(data, prefabPath))\n                    {\n                        processedPrefabs.Add(prefabPath);\n                    }\n                }\n            }\n        }\n\n        AssetDatabase.SaveAssets(); // Save all changes after processing\n        AssetDatabase.Refresh(); // Refresh the database\n\n        if (processedPrefabs.Count > 0)\n        {\n            foreach (var",
    "chunk_order_index": 0,
    "full_doc_id": "doc-d9d8b10f08b9e1a471adf0ab5eb15e72"
  },
  "chunk-509b77202a8554268faacdf73f0cfaa9": {
    "tokens": 1200,
    "content": "abPath.StartsWith(path))\n                    {\n                        underSpecifiedPaths = true;\n                        break;\n                    }\n                }\n\n                if (underSpecifiedPaths)\n                {\n                    if (ProcessPrefab(data, prefabPath))\n                    {\n                        processedPrefabs.Add(prefabPath);\n                    }\n                }\n            }\n        }\n\n        AssetDatabase.SaveAssets(); // Save all changes after processing\n        AssetDatabase.Refresh(); // Refresh the database\n\n        if (processedPrefabs.Count > 0)\n        {\n            foreach (var prefab in processedPrefabs)\n            {\n                Debug.Log($\"成功给预制体 {prefab} 添加了 ResourceInfo\");\n            }\n        }\n        else\n        {\n            Debug.Log(\"没有预制体被处理\");\n        }\n\n        Debug.Log(\"资源信息更新完成\");\n    }\n\n    private bool ProcessPrefab(ResourceCardData data, string prefabPath)\n    {\n        try\n        {\n            GameObject prefab = GetPrefab(prefabPath);\n            if (prefab == null)\n            {\n                Debug.LogWarning(\"未找到预制体: \" + prefabPath);\n                return false;\n            }\n\n            ResourceInfo info = prefab.GetComponent<ResourceInfo>();\n            if (info == null)\n            {\n                info = prefab.AddComponent<ResourceInfo>();\n            }\n\n            var tagLibrary = LoadAllTags();\n\n            info.id = data.Id;\n            info.resourceName = data.Name;\n            info.resourceDescription = data.Description;\n            info.itemHeight = data.Height;\n            info.prefabPath = prefabPath; // Update to set the prefabPath\n            info.thumbnailPath = data.ThumbnailPath;\n            info.modelFaces = data.ModelFaces;\n            info.creationDate = data.CreationDate;\n            info.updatedDate = data.UpdatedDate;\n            info.version = data.Version;\n\n            // Filter tags that exist in the TagLibrary\n            info.typeTags = data.TypeTags.Where(tag => tagLibrary.Contains(tag)).ToList();\n            info.themeTags = data.ThemeTags.Where(tag => tagLibrary.Contains(tag)).ToList();\n            info.functionTags = data.FunctionTags.Where(tag => tagLibrary.Contains(tag)).ToList();\n            info.definitionTags = data.DefinitionTags.Where(tag => tagLibrary.Contains(tag)).ToList();\n            info.batchTags = data.BatchTags.Where(tag => tagLibrary.Contains(tag)).ToList();\n            info.propertyTags = data.PropertyTags.Where(tag => tagLibrary.Contains(tag)).ToList();\n\n            // Load and assign resourceThumbnail\n            if (!string.IsNullOrEmpty(info.thumbnailPath))\n            {\n                Texture2D thumbnailTexture = AssetDatabase.LoadAssetAtPath<Texture2D>(info.thumbnailPath);\n                if (thumbnailTexture != null)\n                {\n                    info.resourceThumbnail = thumbnailTexture;\n                    Debug.Log($\"成功加载缩略图: {info.thumbnailPath}\");\n                }\n                else\n                {\n                    Debug.LogWarning($\"未能加载缩略图: {info.thumbnailPath}\");\n                }\n            }\n\n            EditorUtility.SetDirty(prefab); // Mark prefab as dirty\n\n            return true;\n        }\n        catch (System.Exception ex)\n        {\n            Debug.LogError($\"处理预制体 {prefabPath} 时出错: {ex.Message}\");\n            return false;\n        }\n    }\n    private List<ResourceCardData> LoadResourceData()\n    {\n        var resourceDataList = new List<ResourceCardData>();\n        string[] lines = File.ReadAllLines(csvFilePath);\n        bool isFirstLine = true;\n\n        foreach (string line in lines)\n        {\n            if (isFirstLine)\n            {\n                isFirstLine = false;\n                continue;\n            }\n\n            if (string.IsNullOrWhiteSpace(line)) continue;\n\n            string[] fields = line.Split(',');\n            if (fields.Length < 16) // Ensure correct number of fields\n            {\n                Debug.LogWarning($\"行被跳过，因为字段数量不正确: {line}\");\n                continue;\n            }\n\n            var id = fields[0].Trim('\"');\n            var name = fields[1].Trim('\"');\n            var description = fields[2].Trim('\"');\n            var height = fields[3].Trim('\"');\n            // Skip fields[4], which is the unreliable prefabPath\n            var thumbnailPath = fields[5].Trim('\"');\n            var modelFaces = fields[6].Trim('\"');\n            var creationDate = fields[7].Trim('\"');\n            var updatedDate = fields[8].Trim('\"');\n            var version = fields[9].Trim('\"');\n            var typeTags = new List<string>(fields[10].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var themeTags = new List<string>(fields[11].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var functionTags = new List<string>(fields[12].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var definitionTags = new List<string>(fields[13].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var batchTags = new List<string>(fields[14].Trim('\"').Split(';').Select(tag => tag.Trim()));\n            var propertyTags = new List<string>(fields[15].Trim('\"').Split(';').Select(tag => tag.Trim()));\n\n            ResourceCardData data = new ResourceCardData(id, name, description, height, typeTags, themeTags, functionTags, definitionTags, batchTags, propertyTags, thumbnailPath, modelFaces, creationDate, updatedDate, version);\n            resourceDataList.Add(data);\n        }\n\n        return resourceDataList;\n    }\n\n    public class ResourceCardData\n    {\n        public string Id;\n        public string Name;\n        public string Description;\n        public string Height;\n        public string ThumbnailPath;\n        public string ModelFaces;\n        public string CreationDate;\n        public string UpdatedDate;\n        public string Version;\n        public List<string> TypeTags;\n        public List<string> ThemeTags;\n        public List<string> Function",
    "chunk_order_index": 1,
    "full_doc_id": "doc-d9d8b10f08b9e1a471adf0ab5eb15e72"
  },
  "chunk-d7ac437dab6d350fc46d3b970f68fe3b": {
    "tokens": 1200,
    "content": ", version);\n            resourceDataList.Add(data);\n        }\n\n        return resourceDataList;\n    }\n\n    public class ResourceCardData\n    {\n        public string Id;\n        public string Name;\n        public string Description;\n        public string Height;\n        public string ThumbnailPath;\n        public string ModelFaces;\n        public string CreationDate;\n        public string UpdatedDate;\n        public string Version;\n        public List<string> TypeTags;\n        public List<string> ThemeTags;\n        public List<string> FunctionTags;\n        public List<string> DefinitionTags;\n        public List<string> BatchTags;\n        public List<string> PropertyTags;\n\n        public ResourceCardData(string id, string name, string description, string height, List<string> typeTags, List<string> themeTags, List<string> functionTags, List<string> definitionTags, List<string> batchTags, List<string> propertyTags, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version)\n        {\n            Id = id;\n            Name = name;\n            Description = description;\n            Height = height;\n            ThumbnailPath = thumbnailPath;\n            ModelFaces = modelFaces;\n            CreationDate = creationDate;\n            UpdatedDate = updatedDate;\n            Version = version;\n            TypeTags = typeTags;\n            ThemeTags = themeTags;\n            FunctionTags = functionTags;\n            DefinitionTags = definitionTags;\n            BatchTags = batchTags;\n            PropertyTags = propertyTags;\n        }\n    }\n}\n\n#endif\n\n源代码内容解释如下：\n### 功能概览\n\n#### 功能定位\n此代码文件是一个Unity编辑器扩展工具，用于从CSV文件中读取资源数据，并将这些数据添加到指定的预制体（Prefab）中。其核心功能包括：\n\n1. **CSV文件导入**：允许用户指定CSV文件路径，并从中读取资源信息。\n2. **预制体管理**：支持通过拖放或手动指定预制体路径，管理需要更新的预制体。\n3. **资源信息更新**：为每个预制体自动创建或更新`ResourceInfo`组件，并填充从CSV文件中读取的数据。\n4. **标签过滤**：确保从CSV文件中读取的标签仅使用系统中定义的有效标签。\n\n#### 在系统/项目中的角色\n此工具在项目中扮演资源管理自动化的重要角色，通过减少手动操作，提高资源管理的效率和一致性。它特别适用于需要统一资源信息的大规模项目。\n\n#### 主要特性与技术实现\n- **拖放支持**：允许用户通过拖放方式添加预制体路径。\n- **CSV解析**：使用`File.ReadAllLines`和字符串操作解析CSV文件。\n- **预制体缓存**：通过字典缓存已加载的预制体以提高性能。\n- **标签验证**：确保所有标签都存在于预定义的标签库中。\n\n---\n\n### 核心类解析\n\n#### `ResourceUpdater` 类\n\n- **职责说明**：这是一个Unity编辑器窗口，用于管理资源信息的更新流程。它负责处理用户交互、数据加载和预制体更新。\n\n- **关键方法清单**：\n  - `OnGUI()`：绘制编辑器窗口的用户界面。\n  - `UpdateResourceInfo()`：执行资源信息的更新逻辑。\n  - `ProcessPrefab(ResourceCardData data, string prefabPath)`：处理单个预制体，更新其资源信息。\n  - `LoadResourceData()`：从CSV文件中加载资源数据。\n  - `HandleDragAndDrop()`：处理拖放事件，添加预制体路径。\n\n- **继承关系**：  \n  `ResourceUpdater -> EditorWindow`\n\n- **依赖模块**：\n  - `UnityEngine`：用于基本Unity功能。\n  - `UnityEditor`：用于编辑器扩展功能。\n  - `System.Collections.Generic`：用于集合操作。\n  - `System.IO`：用于文件操作。\n  - `System.Linq`：用于集合查询。\n\n#### `ResourceCardData` 类\n\n- **职责说明**：这是一个数据类，用于存储从CSV文件中读取的资源信息。\n\n- **关键方法清单**：\n  - 构造函数：初始化资源数据字段。\n\n- **继承关系**：无。\n\n- **依赖模块**：无。\n\n---\n\n### 关键方法详解\n\n#### 方法：`OnGUI()`\n\n- **方法签名**：`void OnGUI()`\n- **功能描述**：绘制编辑器窗口的界面，包括文件路径输入、拖放区域和处理按钮。\n- **调用关系**：由Unity编辑器框架自动调用，频率为每次窗口绘制。\n\n#### 方法：`UpdateResourceInfo()`\n\n- **方法签名**：`void UpdateResourceInfo()`\n- **功能描述**：从CSV文件加载资源数据，并为每个资源更新对应的预制体。\n- **调用关系**：由`OnGUI()`中的按钮点击事件调用，频率为用户点击按钮时。\n\n#### 方法：`ProcessPrefab(ResourceCardData data, string prefabPath)`\n\n- **方法签名**：`private bool ProcessPrefab(ResourceCardData data, string prefabPath)`\n- **功能描述**：为指定的预制体更新资源信息，包括添加或更新`ResourceInfo`组件，并填充数据。\n- **调用关系**：由`UpdateResourceInfo()`调用，频率为每个资源数据项处理一次。\n\n#### 方法：`LoadResourceData()`\n\n- **方法签名**：`private List<ResourceCardData> LoadResourceData()`\n- **功能描述**：从CSV文件中读取资源数据，并将其转换",
    "chunk_order_index": 2,
    "full_doc_id": "doc-d9d8b10f08b9e1a471adf0ab5eb15e72"
  },
  "chunk-f8d58c10e6ddaa33b1d0612816da1acb": {
    "tokens": 466,
    "content": ")`\n- **功能描述**：为指定的预制体更新资源信息，包括添加或更新`ResourceInfo`组件，并填充数据。\n- **调用关系**：由`UpdateResourceInfo()`调用，频率为每个资源数据项处理一次。\n\n#### 方法：`LoadResourceData()`\n\n- **方法签名**：`private List<ResourceCardData> LoadResourceData()`\n- **功能描述**：从CSV文件中读取资源数据，并将其转换为`ResourceCardData`对象列表。\n- **调用关系**：由`UpdateResourceInfo()`调用，频率为每次资源更新开始时。\n\n#### 方法：`HandleDragAndDrop()`\n\n- **方法签名**：`private void HandleDragAndDrop()`\n- **功能描述**：处理拖放事件，允许用户通过拖放方式添加预制体路径。\n- **调用关系**：由`OnGUI()`调用，频率为每次窗口绘制。\n\n---\n\n### 架构关系图\n\n```mermaid\nclassDiagram\n    class ResourceUpdater {\n        +void OnGUI()\n        +void UpdateResourceInfo()\n        +bool ProcessPrefab(ResourceCardData, string)\n        +List<ResourceCardData> LoadResourceData()\n        +void HandleDragAndDrop()\n        +List<string> prefabPaths\n        +Dictionary<string, GameObject> prefabCache\n    }\n\n    class ResourceCardData {\n        +string Id\n        +string Name\n        +string Description\n        +string Height\n        +string ThumbnailPath\n        +string ModelFaces\n        +string CreationDate\n        +string UpdatedDate\n        +string Version\n        +List<string> TypeTags\n        +List<string> ThemeTags\n        +List<string> FunctionTags\n        +List<string> DefinitionTags\n        +List<string> BatchTags\n        +List<string> PropertyTags\n        +ResourceCardData(string, string, string, string, List<string>, List<string>, List<string>, List<string>, List<string>, List<string>, string, string, string, string, string)\n    }\n\n    ResourceUpdater --> ResourceCardData\n    ResourceUpdater *-- AssetDatabase\n    ResourceUpdater *-- EditorUtility\n    ResourceUpdater *-- GUILayout\n```",
    "chunk_order_index": 3,
    "full_doc_id": "doc-d9d8b10f08b9e1a471adf0ab5eb15e72"
  },
  "chunk-b91496194d30d8f0965a866a149ff42c": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEditor;\n#endif\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.Linq;\n\npublic class HistoryCardUI : MonoBehaviour\n{\n    public TextMeshProUGUI idText;\n    public TextMeshProUGUI nameText;\n    public TextMeshProUGUI descriptionText;\n    public TextMeshProUGUI heightText;\n    public TextMeshProUGUI versionText;\n    public TextMeshProUGUI totalVersionText; // 新增总表版本号\n    public TextMeshProUGUI prefabPathText;\n    public Image thumbnailImage;\n    public TextMeshProUGUI typeTagsText;\n    public TextMeshProUGUI themeTagsText;\n    public TextMeshProUGUI functionTagsText;\n    public TextMeshProUGUI definitionTagsText;\n    public TextMeshProUGUI batchTagsText;\n    public TextMeshProUGUI propertyTagsText;\n    public TextMeshProUGUI modelFacesText;\n    public TextMeshProUGUI creationDateText;\n    public TextMeshProUGUI updatedDateText;\n    public Button deleteButton;\n    public Button addButton;\n\n    // 新增用于显示更新提示的UI实例\n    public GameObject updateNotification;\n\n    public GameObject targetParent;\n    public ItemDetailsDisplay itemDetailsDisplay;\n    public CSVParser cSVParser;\n    public ResourceManager resourceManager; // 需要引用 ResourceManager\n\n    private static HistoryCardUI currentSelectedCard;\n\n    private string thumbnailPath;\n    public string csvFilePath;\n\n    public void SetupCard(\n        string id,\n        string name,\n        string description,\n        string height,\n        string version,\n        string prefabPath,\n        string thumbnailPath,\n        string typeTags,\n        string themeTags,\n        string functionTags,\n        string definitionTags,\n        string batchTags,\n        string propertyTags,\n        string modelFaces,\n        string creationDate,\n        string updatedDate,\n        string csvFilePath\n    )\n    {\n        idText.text = id;\n        nameText.text = name;\n        descriptionText.text = description;\n        heightText.text = height;\n        versionText.text = version;\n        prefabPathText.text = prefabPath;\n        typeTagsText.text = typeTags;\n        themeTagsText.text = themeTags;\n        functionTagsText.text = functionTags;\n        definitionTagsText.text = definitionTags;\n        batchTagsText.text = batchTags;\n        propertyTagsText.text = propertyTags;\n        modelFacesText.text = modelFaces;\n        creationDateText.text = creationDate;\n        updatedDateText.text = updatedDate;\n\n        this.thumbnailPath = thumbnailPath;\n        this.csvFilePath = csvFilePath;\n\n#if UNITY_EDITOR\n        thumbnailImage.sprite = LoadSpriteFromPath(thumbnailPath);\n#endif\n\n        deleteButton.gameObject.SetActive(false);\n        addButton.gameObject.SetActive(false);\n\n        deleteButton.onClick.AddListener(OnDeleteButtonClicked);\n        addButton.onClick.AddListener(OnAddButtonClicked);\n\n        // 调用版本对比方法\n        CheckForUpdates(id, version);\n    }\n\n    private void CheckForUpdates(string id, string currentVersion)\n    {\n        if (resourceManager == null)\n        {\n            Debug.LogError(\"ResourceManager reference is missing.\");\n            return;\n        }\n\n        var resource = resourceManager.GetResourceById(id);\n        if (resource == null)\n        {\n            Debug.LogWarning($\"Resource with ID {id} not found in the total resource list.\");\n            return;\n        }\n\n        // 设置总表版本号\n        totalVersionText.text = resource.Version;\n\n        if (resource.Version != currentVersion)\n        {\n            // 版本不匹配，显示更新信息            \n            versionText.color = Color.red; // 设置文本颜色为红色以强调\n            updateNotification.SetActive(true); // 显示更新提示UI实例\n        }\n        else\n        {\n            updateNotification.SetActive(false); // 隐藏更新提示UI实例\n        }\n    }\n\n#if UNITY_EDITOR\n    private Sprite LoadSpriteFromPath(string thumbnailPath)\n    {\n        // 使用新路径并直接使用传递的图片名称\n        string pathForLoading = \"Assets/ZTResource/Resources/ZT_IconTextures/\" + thumbnailPath + \".png\"; // 确保包括文件扩展名\n        Texture2D texture = AssetDatabase.LoadAssetAtPath<Texture2D>(pathForLoading);\n        if (texture == null)\n        {\n            Debug.LogError(\"Failed to load texture at path: \" + pathForLoading);\n            return null;\n        }\n        return Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f));\n    }\n#endif\n\n    public void OnCardClicked()\n    {\n        itemDetailsDisplay.DisplayItemDetails(\n            idText.text,\n            nameText.text,\n            descriptionText.text,\n            heightText.text,\n            modelFacesText.text,\n            creationDateText.text,\n            updatedDateText.text,\n            versionText.text,\n            propertyTagsText.text\n        );\n\n#if UNITY_EDITOR\n        if (prefabPathText != null && !string.IsNullOrEmpty(prefabPathText.text))\n        {\n            string assetPath = prefabPathText.text;\n            var asset = AssetDatabase.LoadAssetAtPath<GameObject>(assetPath);\n            if (asset != null)\n            {\n                Selection.activeObject = asset;\n                EditorGUIUtility.PingObject(asset);\n            }\n            else\n            {\n                Debug.LogError(\"Cannot find asset at path: \" + assetPath);\n            }\n        }\n#endif\n\n        if (targetParent == null)\n        {\n            return;\n        }\n\n        bool isAlreadyAdded = false;\n        foreach (Transform child in targetParent.transform)\n        {\n            if (child.name == prefabPathText",
    "chunk_order_index": 0,
    "full_doc_id": "doc-6d2d7fc0a1bcf31c67cb6a14226f67cd"
  },
  "chunk-4c466beee956065a232750633372f294": {
    "tokens": 1200,
    "content": "Path);\n            if (asset != null)\n            {\n                Selection.activeObject = asset;\n                EditorGUIUtility.PingObject(asset);\n            }\n            else\n            {\n                Debug.LogError(\"Cannot find asset at path: \" + assetPath);\n            }\n        }\n#endif\n\n        if (targetParent == null)\n        {\n            return;\n        }\n\n        bool isAlreadyAdded = false;\n        foreach (Transform child in targetParent.transform)\n        {\n            if (child.name == prefabPathText.text)\n            {\n                isAlreadyAdded = true;\n                break;\n            }\n        }\n\n        if (isAlreadyAdded)\n        {\n            return;\n        }\n\n        foreach (Transform child in targetParent.transform)\n        {\n            Destroy(child.gameObject);\n        }\n\n#if UNITY_EDITOR\n        string resourcePath = prefabPathText.text;\n        GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(resourcePath);\n        if (prefab != null)\n        {\n            GameObject instantiatedPrefab = Instantiate(prefab, targetParent.transform.position, Quaternion.identity, targetParent.transform);\n            instantiatedPrefab.name = nameText.text;\n        }\n#endif\n\n        if (currentSelectedCard != null)\n        {\n            currentSelectedCard.deleteButton.gameObject.SetActive(false);\n            currentSelectedCard.addButton.gameObject.SetActive(false);\n        }\n\n        currentSelectedCard = this;\n        deleteButton.gameObject.SetActive(true);\n        addButton.gameObject.SetActive(true);\n    }\n\n    private void OnDeleteButtonClicked()\n    {\n        string cardId = idText.text;\n        CSVParser.DeleteResource(csvFilePath, cardId);\n\n        CardInfo cardToRemove = SelectedCardSpawner.Instance.ExistingCards.FirstOrDefault(card => card.ID == cardId);\n        if (cardToRemove != null)\n        {\n            SelectedCardSpawner.Instance.RemoveCardInfo(cardToRemove);\n        }\n\n        Destroy(gameObject);\n        currentSelectedCard = null;\n    }\n\n    public void OnAddButtonClicked()\n    {\n        SelectedCardSpawner.Instance.SpawnSelectedCard(\n            idText.text,\n            nameText.text,\n            descriptionText.text,\n            heightText.text,\n            versionText.text,\n            prefabPathText.text,\n            thumbnailPath,\n            typeTagsText.text,\n            themeTagsText.text,\n            functionTagsText.text,\n            definitionTagsText.text,\n            batchTagsText.text,\n            propertyTagsText.text,\n            modelFacesText.text,\n            creationDateText.text,\n            updatedDateText.text\n        );\n    }\n}\n\n源代码内容解释如下：\n### 功能概览\n\n**功能定位**  \n`HistoryCardUI` 是一个用于展示资源卡片信息的 Unity 脚本组件。它主要负责显示资源的详细信息（如 ID、名称、描述、版本等），并提供用户交互功能（如删除、添加资源）。\n\n**系统角色**  \n该组件在资源管理系统中扮演重要角色，用于可视化资源卡片信息，并与其他模块（如 `ItemDetailsDisplay`、`CSVParser`、`ResourceManager`）协同工作，实现资源管理的核心功能。\n\n**主要特性与技术实现**  \n1. **资源信息展示**：通过字段绑定显示资源的详细信息（如 ID、名称、描述、版本、标签等）。\n2. **版本对比**：通过 `ResourceManager` 对比资源版本，显示更新提示。\n3. **用户交互**：提供删除和添加按钮，支持用户对资源进行操作。\n4. **依赖管理**：依赖 `ItemDetailsDisplay`、`CSVParser`、`ResourceManager` 等模块。\n5. **Unity 编辑器支持**：在 Unity 编辑器环境下，支持资源路径加载和Prefab实例化。\n\n---\n\n### 核心类解析\n\n**类名称**：`HistoryCardUI`  \n**职责说明**：  \n- 管理资源卡片的 UI 显示\n- 处理用户交互（如点击卡片、删除/添加资源）\n- 与 `ItemDetailsDisplay`、`CSVParser`、`ResourceManager` 等模块协同工作\n\n**关键方法清单**：  \n- `public void SetupCard(...)`：初始化卡片数据\n- `public void OnCardClicked()`：处理卡片点击事件\n- `public void OnDeleteButtonClicked()`：处理删除按钮点击事件\n- `public void OnAddButtonClicked()`：处理添加按钮点击事件\n- `private void CheckForUpdates(string id, string currentVersion)`：检查资源版本更新\n\n**继承关系**：  \n`HistoryCardUI` -> `MonoBehaviour`\n\n**依赖模块**：  \n- `ItemDetailsDisplay`\n- `CSVParser`\n- `ResourceManager`\n\n---\n\n### 关键方法详解\n\n#### 1. `public void SetupCard(...)`\n**方法签名**：  \n```csharp\npublic void SetupCard(\n    string id,\n    string name,\n    string description,\n    string height,\n    string version,\n    string prefabPath,\n    string thumbnailPath,\n    string typeTags,\n    string themeTags,\n    string functionTags,\n    string definitionTags,\n    string batchTags,\n    string propertyTags,\n    string modelFaces,\n    string creationDate,\n    string updatedDate,\n    string csvFilePath\n)\n```\n\n**功能描述**：  \n- 初始化卡片数据，设置文本显示内容（如 ID、名称、描述等）。\n- 加载缩略图（仅在 Unity 编辑器环境下支持）。\n- 初始化删除和添加按钮的点击事件监听器。\n- 调用 `CheckForUpdates` 方法，检查资源版本更新。\n\n**调用关系**：  \n- 由外部（如 `CardSpawner`）调用，用于创建和初始化卡片。\n\n---\n\n#### 2. `public void OnCardClicked()`\n**方法签名",
    "chunk_order_index": 1,
    "full_doc_id": "doc-6d2d7fc0a1bcf31c67cb6a14226f67cd"
  },
  "chunk-7f407e6daef4eb1124f38891cebeed57": {
    "tokens": 666,
    "content": "设置文本显示内容（如 ID、名称、描述等）。\n- 加载缩略图（仅在 Unity 编辑器环境下支持）。\n- 初始化删除和添加按钮的点击事件监听器。\n- 调用 `CheckForUpdates` 方法，检查资源版本更新。\n\n**调用关系**：  \n- 由外部（如 `CardSpawner`）调用，用于创建和初始化卡片。\n\n---\n\n#### 2. `public void OnCardClicked()`\n**方法签名**：  \n```csharp\npublic void OnCardClicked()\n```\n\n**功能描述**：  \n- 显示资源的详细信息（通过 `ItemDetailsDisplay` 组件）。\n- 在 Unity 编辑器环境下，跳转到资源的Prefab路径。\n- 管理删除和添加按钮的显示状态（仅当前选中的卡片显示）。\n\n**调用关系**：  \n- 由 Unity UI 系统调用（当用户点击卡片时触发）。\n\n---\n\n#### 3. `public void OnDeleteButtonClicked()`\n**方法签名**：  \n```csharp\npublic void OnDeleteButtonClicked()\n```\n\n**功能描述**：  \n- 从 CSV 文件中删除资源记录。\n- 从内存中移除对应的卡片信息。\n- 销毁当前卡片的 GameObject 实例。\n\n**调用关系**：  \n- 由删除按钮的点击事件触发。\n\n---\n\n#### 4. `public void OnAddButtonClicked()`\n**方法签名**：  \n```csharp\npublic void OnAddButtonClicked()\n```\n\n**功能描述**：  \n- 将当前卡片信息传递给 `SelectedCardSpawner`，用于生成预制体实例。\n\n**调用关系**：  \n- 由添加按钮的点击事件触发。\n\n---\n\n#### 5. `private void CheckForUpdates(string id, string currentVersion)`\n**方法签名**：  \n```csharp\nprivate void CheckForUpdates(string id, string currentVersion)\n```\n\n**功能描述**：  \n- 通过 `ResourceManager` 获取资源的最新版本信息。\n- 比较当前版本和最新版本，显示更新提示（文本变红并显示 `updateNotification`）。\n\n**调用关系**：  \n- 由 `SetupCard` 方法调用，用于版本对比。\n\n---\n\n### 架构关系图\n\n```mermaid\nclassDiagram\n    class HistoryCardUI {\n        +MonoBehaviour\n        +SetupCard(...)\n        +OnCardClicked()\n        +OnDeleteButtonClicked()\n        +OnAddButtonClicked()\n        +CheckForUpdates(...)\n        +ItemDetailsDisplay itemDetailsDisplay\n        +CSVParser cSVParser\n        +ResourceManager resourceManager\n    }\n    \n    HistoryCardUI --> ItemDetailsDisplay : 使用\n    HistoryCardUI --> CSVParser : 使用\n    HistoryCardUI --> ResourceManager : 使用\n```\n\n---\n\n### 总结\n\n`HistoryCardUI` 是一个功能全面的资源卡片管理组件，通过字段绑定和事件处理实现资源信息的可视化展示和用户交互。其核心功能包括资源信息展示、版本对比、删除/添加操作等，通过与其他模块的协同合作，实现了资源管理系统的完整功能。",
    "chunk_order_index": 2,
    "full_doc_id": "doc-6d2d7fc0a1bcf31c67cb6a14226f67cd"
  },
  "chunk-d3ec4fb47b4eb46509efb849c7a2dc78": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MainUIController : MonoBehaviour\n{\n    public UserInfoUI userInfoUI;\n    public Transform batchParent;\n    public GameObject batchPrefab;\n\n    private string csvFilePath; // 新增存储CSV文件路径的变量\n\n    public void SetupPurchaseRecords(string userName, string userAvatar, List<(string batchName, string batchTime, List<CardInfo> cardInfos)> batches, string csvFilePath)\n    {\n        this.csvFilePath = csvFilePath; // 设置CSV文件路径\n\n        // 清空现有的批次UI\n        foreach (Transform child in batchParent)\n        {\n            Destroy(child.gameObject);\n        }\n\n        // 设置用户信息\n        userInfoUI.SetupUserInfo(userName, userAvatar);\n\n        // 创建新的批次UI\n        foreach (var batch in batches)\n        {\n            GameObject batchObject = Instantiate(batchPrefab, batchParent);\n            BatchUI batchUI = batchObject.GetComponent<BatchUI>();\n\n            batchUI.SetupBatch(batch.batchName, batch.batchTime, batch.cardInfos, csvFilePath); // 传递CSV文件路径\n\n        }\n    }\n}\n\n源代码内容解释如下：\n### 功能概览\n\n**功能定位：**  \nMainUIController是一个用于管理用户界面显示的控制类，主要负责展示用户的购买记录和相关信息。它通过接收用户数据和购买批次数据，动态生成并更新UI元素，为用户提供清晰的购买历史视图。\n\n**系统角色：**  \n在系统中，MainUIController扮演着用户界面管理的核心角色，是连接后端数据处理与前端显示的重要桥梁。它确保用户能够直观地查看自己的购买记录，并通过CSV文件路径支持数据的导出功能。\n\n**主要特性与技术实现：**  \n- **动态UI生成：** 根据传入的批次数据动态生成对应的UI元素。\n- **用户信息展示：** 通过UserInfoUI组件显示用户的基本信息。\n- **数据更新机制：** 支持清空和重新生成UI元素，以响应最新的数据变化。\n- **CSV文件路径管理：** 存储CSV文件路径以便后续处理。\n\n---\n\n### 核心类解析\n\n**类名称：MainUIController**\n\n- **职责说明：**  \n  MainUIController的主要职责是管理用户界面的显示，包括用户信息的呈现和购买记录的动态生成。它通过调用相关组件的方法，确保UI内容能够根据输入数据实时更新。\n\n- **关键方法清单：**\n  - `public void SetupPurchaseRecords(string userName, string userAvatar, List<(string batchName, string batchTime, List<CardInfo> cardInfos)> batches, string csvFilePath)`\n  \n- **继承关系：**  \n  MainUIController -> MonoBehaviour\n\n- **依赖模块：**  \n  - `UserInfoUI`\n  - `BatchUI`\n  - `Transform` (UnityEngine)\n  - `GameObject` (UnityEngine)\n  - `CardInfo` (假设为项目内自定义结构)\n\n---\n\n### 关键方法详解\n\n**方法名称：SetupPurchaseRecords**\n\n**方法签名：**  \n```csharp\npublic void SetupPurchaseRecords(string userName, string userAvatar, List<(string batchName, string batchTime, List<CardInfo> cardInfos)> batches, string csvFilePath)\n```\n\n**功能描述：**  \nSetupPurchaseRecords方法负责初始化和更新用户的购买记录UI。它接收用户信息、购买批次数据和CSV文件路径作为输入参数，执行以下操作：\n1. **存储CSV文件路径：** 将CSV文件路径存储为类的私有变量，以供后续使用。\n2. **清空现有UI元素：** 遍历并销毁batchParent下所有子对象，确保旧的UI元素被移除。\n3. **设置用户信息：** 调用UserInfoUI组件的SetupUserInfo方法，显示用户名和用户头像。\n4. **生成新批次UI：** 对于每个批次数据， Instantiate一个预制体并附加BatchUI组件，然后调用BatchUI的SetupBatch方法，传入批次信息和CSV文件路径。\n\n**算法说明：**  \n该方法采用简单的线性遍历算法，逐个处理每个批次数据，生成对应的UI元素。整体复杂度为O(N)，其中N为批次的数量。\n\n**调用关系：**  \n- **被调用者：**  \n  - `Destroy(child.gameObject)`：用于销毁旧的UI元素。\n  - `Instantiate(batchPrefab, batchParent)`：用于生成新的UI预制体。\n  - `GetComponent<BatchUI>()`：获取BatchUI组件实例。\n  - `SetupUserInfo(userName, userAvatar)`：设置用户信息。\n  - `SetupBatch(batch.batchName, batch.batchTime, batch.cardInfos, csvFilePath)`：设置批次信息。\n- **调用频率：**  \n  该方法通常在需要更新购买记录UI时被调用，频率取决于数据更新的频率，可能是每次应用启动或数据变更后调用一次。\n\n---\n\n### 架构关系图\n\n```mermaid\nclassDiagram\n    class MainUIController {\n        +UserInfoUI userInfoUI\n        +Transform batchParent\n        +GameObject batchPrefab\n        -string csvFilePath\n        +void SetupPurchaseRecords(string, string, List<(string, string, List<CardInfo>)>, string)\n    }\n    class MonoBehaviour {\n        // 基类，包含Unity组件的",
    "chunk_order_index": 0,
    "full_doc_id": "doc-23082aceab0a37ea4784859f639789a4"
  },
  "chunk-449a0977fcc01bfaa757abf698dd8797": {
    "tokens": 298,
    "content": "次应用启动或数据变更后调用一次。\n\n---\n\n### 架构关系图\n\n```mermaid\nclassDiagram\n    class MainUIController {\n        +UserInfoUI userInfoUI\n        +Transform batchParent\n        +GameObject batchPrefab\n        -string csvFilePath\n        +void SetupPurchaseRecords(string, string, List<(string, string, List<CardInfo>)>, string)\n    }\n    class MonoBehaviour {\n        // 基类，包含Unity组件的基本功能\n    }\n    class UserInfoUI {\n        +void SetupUserInfo(string, string)\n        // 其他方法和属性\n    }\n    class BatchUI {\n        +void SetupBatch(string, string, List<CardInfo>, string)\n        // 其他方法和属性\n    }\n    MainUIController --> UserInfoUI : 依赖\n    MainUIController --> BatchUI : 依赖\n    MainUIController --> MonoBehaviour : 继承\n```\n\n---\n\n### 总结\n\nMainUIController是一个负责管理用户界面显示的核心类，通过动态生成和更新UI元素，确保用户能够清晰地查看自己的购买记录。它在系统中起着重要的桥梁作用，连接了数据处理层和展示层，为用户提供直观的数据视图。其设计简洁高效，能够灵活应对数据的动态变化，为系统的扩展性和维护性提供了良好的基础。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-23082aceab0a37ea4784859f639789a4"
  },
  "chunk-3ea705c1de486372f131332ba2d656cc": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.IO;\nusing System.Globalization;\nusing System.Linq;\n\n// 负责从CSV文件加载用户购买数据，并在游戏开始时初始化用户信息。\npublic class UserPurchaseManager : MonoBehaviour\n{\n    private List<UserPurchaseData> allUserPurchases = new List<UserPurchaseData>();\n\n    void Awake()\n    {\n        LoadUserPurchaseData();\n    }\n\n    void Start()\n    {\n        PrintAllUserPurchases();\n    }\n\n    private void LoadUserPurchaseData()\n    {\n        string path = \"Assets/ZTResource/UserInfo/UserPurchaseRecordLibrary.csv\";\n        Debug.Log($\"Loading data from: {path}\");\n        if (!File.Exists(path))\n        {\n            Debug.LogError($\"File not found: {path}\");\n            return;\n        }\n\n        string[] lines = File.ReadAllLines(path, System.Text.Encoding.UTF8);\n        Debug.Log($\"Total lines read: {lines.Length}\");\n        bool isFirstLine = true; // 增加一个变量来跟踪是否是第一行\n        bool isNewBatch = false;\n        string currentBatchName = \"\";\n\n        foreach (string line in lines)\n        {\n            Debug.Log($\"Processing line: {line}\");\n\n            if (isFirstLine || line.StartsWith(\"资源ID\"))\n            {\n                isFirstLine = false; // 如果是第一行或标题行，就将其标记为false，并继续下一行\n                continue;\n            }\n            if (string.IsNullOrWhiteSpace(line)) continue; // 跳过空行\n\n            if (line.StartsWith(\"批次名\"))\n            {\n                currentBatchName = line.Split(',')[0];\n                isNewBatch = true;\n                Debug.Log($\"New batch found: {currentBatchName}\");\n                continue;\n            }\n\n            string[] fields = line.Split(',');\n\n            if (isNewBatch)\n            {\n                isNewBatch = false;\n                continue;\n            }\n\n            // 检查字段数量是否足够\n            if (fields.Length < 18)\n            {\n                Debug.LogWarning($\"Line skipped due to insufficient fields: {line}\");\n                continue;\n            }\n\n            try\n            {\n                var userId = fields[0].Trim('\"');\n                var resourceId = fields[1].Trim('\"');\n                var userName = fields[2].Trim('\"');\n                var resourceName = fields[3].Trim('\"');\n                var resourceDescription = fields[4].Trim('\"');\n                var resourceHeight = fields[5].Trim('\"');              \n                var prefabPath = fields[6].Trim('\"');\n                var thumbnailPath = fields[7].Trim('\"');\n                var modelFaces = fields[8].Trim('\"');\n                var creationDate = fields[9].Trim('\"');\n                var updatedDate = fields[10].Trim('\"');\n                var version = fields[11].Trim('\"');\n                var typeTags = new List<string>(fields[12].Trim('\"').Split(';').Select(tag => tag.Trim()));\n                var themeTags = new List<string>(fields[13].Trim('\"').Split(';').Select(tag => tag.Trim()));\n                var functionTags = new List<string>(fields[14].Trim('\"').Split(';').Select(tag => tag.Trim()));\n                var definitionTags = new List<string>(fields[15].Trim('\"').Split(';').Select(tag => tag.Trim()));\n                var batchTags = new List<string>(fields[16].Trim('\"').Split(';').Select(tag => tag.Trim()));\n                var propertyTags = new List<string>(fields[17].Trim('\"').Split(';').Select(tag => tag.Trim()));\n\n                UserPurchaseData data = new UserPurchaseData(userId, resourceId, userName, resourceName, resourceDescription, resourceHeight, typeTags, themeTags, functionTags, definitionTags, batchTags, propertyTags, prefabPath, thumbnailPath, modelFaces, creationDate, updatedDate, version);\n                allUserPurchases.Add(data);\n            }\n            catch (System.Exception ex)\n            {\n                Debug.LogError($\"Error processing line: {line}\\nException: {ex.Message}\");\n            }\n        }\n\n        Debug.Log($\"Total purchases loaded: {allUserPurchases.Count}\");\n    }\n\n    public List<UserPurchaseData> GetAllUserPurchases()\n    {\n        return allUserPurchases;\n    }\n\n    private void PrintAllUserPurchases()\n    {\n        Debug.Log(\"Printing all user purchases...\");\n        foreach (var purchase in allUserPurchases)\n        {\n            Debug.Log($\"Name: {purchase.ResourceName}, Description: {purchase.ResourceDescription}, Height: {purchase.ResourceHeight}, \" +\n                      $\"Type Tags: {string.Join(\", \", purchase.TypeTags)}, Theme Tags: {string.Join(\", \", purchase.ThemeTags)}, \" +\n                      $\"Function Tags: {string.Join(\", \", purchase.FunctionTags)}, Definition Tags: {string.Join(\", \", purchase.DefinitionTags)}, \" +\n                      $\"Batch Tags: {string.Join(\", \", purchase.BatchTags)}, Property Tags: {string.Join(\", \", purchase.PropertyTags)}, \" +\n                      $\"Prefab Path: {purchase.PrefabPath}, Thumbnail Path: {purchase.ThumbnailPath}, Model Faces: {purchase.ModelFaces}, \" +\n                      $\"Creation Date: {purchase.CreationDate}, Updated Date: {purchase.UpdatedDate}, Version: {purchase.Version}, ID: {purchase.ResourceID}, User: {purchase.UserName}\");\n        }\n    }\n}\n\npublic class UserPurchaseData\n{\n    public string UserID { get; private set; }\n    public string ResourceID { get; private set; }\n    public string UserName { get; private set; }\n    public string ResourceName { get; private set; }\n    public string ResourceDescription { get; private set; }\n    public string ResourceHeight { get; private set; }\n    public List<string> TypeTags { get",
    "chunk_order_index": 0,
    "full_doc_id": "doc-3f2ef5a0b9e12d439cbfae4d2fe3bd19"
  },
  "chunk-07636a0ba07aac10809ce7ee020bda51": {
    "tokens": 1200,
    "content": "User: {purchase.UserName}\");\n        }\n    }\n}\n\npublic class UserPurchaseData\n{\n    public string UserID { get; private set; }\n    public string ResourceID { get; private set; }\n    public string UserName { get; private set; }\n    public string ResourceName { get; private set; }\n    public string ResourceDescription { get; private set; }\n    public string ResourceHeight { get; private set; }\n    public List<string> TypeTags { get; private set; }\n    public List<string> ThemeTags { get; private set; }\n    public List<string> FunctionTags { get; private set; }\n    public List<string> DefinitionTags { get; private set; }\n    public List<string> BatchTags { get; private set; }\n    public List<string> PropertyTags { get; private set; }\n    public string PrefabPath { get; private set; }\n    public string ThumbnailPath { get; private set; }\n    public string ModelFaces { get; private set; }\n    public string CreationDate { get; private set; }\n    public string UpdatedDate { get; private set; }\n    public string Version { get; private set; }\n\n    public UserPurchaseData(string userId, string resourceId, string userName, string resourceName, string resourceDescription, string resourceHeight,\n                            List<string> typeTags, List<string> themeTags, List<string> functionTags, List<string> definitionTags, List<string> batchTags,\n                            List<string> propertyTags, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version)\n    {\n        UserID = userId;\n        ResourceID = resourceId;\n        UserName = userName;\n        ResourceName = resourceName;\n        ResourceDescription = resourceDescription;\n        ResourceHeight = resourceHeight;\n        TypeTags = typeTags;\n        ThemeTags = themeTags;\n        FunctionTags = functionTags;\n        DefinitionTags = definitionTags;\n        BatchTags = batchTags;\n        PropertyTags = propertyTags;\n        PrefabPath = prefabPath;\n        ThumbnailPath = thumbnailPath;\n        ModelFaces = modelFaces;\n        CreationDate = creationDate;\n        UpdatedDate = updatedDate;\n        Version = version;\n    }\n}\n#endif\n源代码内容解释如下：\n```markdown\n# 代码文件分析\n\n## 1. 功能概览\n\n### 功能定位\n该代码文件实现了从CSV文件加载用户购买数据的功能，并在游戏启动时初始化用户信息。它主要负责读取CSV文件，解析数据，并将其存储为可访问的数据结构。\n\n### 系统角色\n在Unity项目中，该脚本作为用户购买数据管理器，起到数据加载和初始化的作用。它确保游戏在启动时能够获取到用户购买记录，为后续功能提供数据支持。\n\n### 主要特性与技术实现\n- **CSV文件读取与解析**：使用C#的File类读取CSV文件，并逐行解析数据。\n- **数据存储**：将解析后的数据存储在List<UserPurchaseData>中，便于后续访问。\n- **错误处理**：处理文件不存在、字段不足等情况，并提供调试日志。\n- **数据输出**：在启动时打印所有用户购买数据，便于调试和确认数据加载结果。\n\n## 2. 核心类解析\n\n### UserPurchaseManager\n\n#### 职责说明\n该类负责从CSV文件加载用户购买数据，并在游戏启动时初始化这些数据。它处理文件读取、数据解析、存储和输出。\n\n#### 关键方法清单\n- `void Awake()`：在脚本初始化时调用，触发数据加载。\n- `void Start()`：在脚本启动时调用，打印所有用户购买数据。\n- `private void LoadUserPurchaseData()`：读取并解析CSV文件，加载用户购买数据。\n- `public List<UserPurchaseData> GetAllUserPurchases()`：返回所有用户购买数据。\n- `private void PrintAllUserPurchases()`：打印所有用户购买数据。\n\n#### 继承关系\n```mermaid\nclassDiagram\n    class MonoBehavior\n    class UserPurchaseManager {\n        +void Awake()\n        +void Start()\n        +void LoadUserPurchaseData()\n        +List<UserPurchaseData> GetAllUserPurchases()\n        +void PrintAllUserPurchases()\n    }\n    UserPurchaseManager --> MonoBehavior\n```\n\n#### 依赖模块\n- System.Collections.Generic (List<T>)\n- UnityEngine (MonoBehaviour, Debug, GameObject)\n- System.IO (File)\n- System.Linq (LINQ方法)\n- System.Globalization (文化信息)\n\n### UserPurchaseData\n\n#### 职责说明\n该类作为数据容器，存储用户购买数据的各个字段，如用户ID、资源ID、用户名、资源名称、描述、高度、标签信息等。\n\n#### 关键方法清单\n- `public UserPurchaseData(string userId, string resourceId, string userName, string resourceName, string resourceDescription, string resourceHeight, List<string> typeTags, List<string> themeTags, List<string> functionTags, List<string> definitionTags, List<string> batchTags, List<string> propertyTags, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version)`：构造函数，初始化所有字段。\n\n#### 继承关系\n```mermaid\nclassDiagram\n    class UserPurchaseData\n```\n\n## 3. 关键方法详解\n\n### LoadUserPurchaseData\n\n#### 方法签名\n```csharp\nprivate void LoadUserPurchaseData()\n```\n\n#### 功能描述\n该方法从指定路径的CSV文件中读取用户购买数据，解析",
    "chunk_order_index": 1,
    "full_doc_id": "doc-3f2ef5a0b9e12d439cbfae4d2fe3bd19"
  },
  "chunk-b9fc1ac7fd18fdae55651a2dfe926110": {
    "tokens": 715,
    "content": ", string modelFaces, string creationDate, string updatedDate, string version)`：构造函数，初始化所有字段。\n\n#### 继承关系\n```mermaid\nclassDiagram\n    class UserPurchaseData\n```\n\n## 3. 关键方法详解\n\n### LoadUserPurchaseData\n\n#### 方法签名\n```csharp\nprivate void LoadUserPurchaseData()\n```\n\n#### 功能描述\n该方法从指定路径的CSV文件中读取用户购买数据，解析每一行数据，并将其存储在`allUserPurchases`列表中。\n\n#### 处理逻辑\n1. **文件路径检查**：检查CSV文件是否存在，若不存在则输出错误日志并返回。\n2. **读取文件内容**：使用`File.ReadAllLines`读取文件内容。\n3. **逐行解析**：\n   - 跳过标题行和空行。\n   - 处理批次名，更新当前批次名称。\n   - 解析每行数据，将字段分割并处理。\n   - 检查字段数量是否足够，不足则跳过该行。\n   - 创建`UserPurchaseData`对象，并添加到`allUserPurchases`列表中。\n4. **异常处理**：捕获解析过程中的异常，输出错误信息。\n\n### PrintAllUserPurchases\n\n#### 方法签名\n```csharp\nprivate void PrintAllUserPurchases()\n```\n\n#### 功能描述\n该方法遍历`allUserPurchases`列表，打印每个用户的购买数据到调试控制台。\n\n#### 处理逻辑\n- 遍历`allUserPurchases`列表。\n- 对于每个`UserPurchaseData`对象，输出其所有字段信息。\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class MonoBehavior\n    class UserPurchaseManager {\n        +void Awake()\n        +void Start()\n        +void LoadUserPurchaseData()\n        +List<UserPurchaseData> GetAllUserPurchases()\n        +void PrintAllUserPurchases()\n    }\n    class UserPurchaseData {\n        +string UserID\n        +string ResourceID\n        +string UserName\n        +string ResourceName\n        +string ResourceDescription\n        +string ResourceHeight\n        +List<string> TypeTags\n        +List<string> ThemeTags\n        +List<string> FunctionTags\n        +List<string> DefinitionTags\n        +List<string> BatchTags\n        +List<string> PropertyTags\n        +string PrefabPath\n        +string ThumbnailPath\n        +string ModelFaces\n        +string CreationDate\n        +string UpdatedDate\n        +string Version\n        +UserPurchaseData(string userId, string resourceId, string userName, string resourceName, string resourceDescription, string resourceHeight, List<string> typeTags, List<string> themeTags, List<string> functionTags, List<string> definitionTags, List<string> batchTags, List<string> propertyTags, string prefabPath, string thumbnailPath, string modelFaces, string creationDate, string updatedDate, string version)\n    }\n    UserPurchaseManager --> MonoBehavior\n    UserPurchaseManager --> UserPurchaseData\n```\n\n该架构图展示了类之间的继承关系和依赖关系。`UserPurchaseManager`继承自`MonoBehavior`，并依赖于`UserPurchaseData`类来存储用户购买数据。",
    "chunk_order_index": 2,
    "full_doc_id": "doc-3f2ef5a0b9e12d439cbfae4d2fe3bd19"
  },
  "chunk-f8fe5c58f3d4ef6c0232de044c45a600": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing System.Collections.Generic;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class BatchUI : MonoBehaviour\n{\n    public TextMeshProUGUI batchNameText;\n    public TextMeshProUGUI batchTimeText;\n    public Transform contentParent;\n    public GameObject cardPrefab;\n    public float cardHeightIncrement;  // 这个高度值由你来设定\n    public float defaultHeight; // 默认高度\n    public TMP_InputField batchNameInputField; // 用于修改批次名称的输入字段\n    public Button saveBatchNameButton;  // 用于保存批次名称的按钮\n    public Button deleteBatchButton; // 用于删除批次的按钮\n    public Button addAllToCartButton; // 新增按钮用于将所有资源添加到购物车\n    public GameObject slotObject; // 新增的插槽对象\n    public Button collapseButton; // 折叠/展开按钮\n    private bool isCollapsed = false; // 用于标记当前批次是否折叠\n\n    private string csvFilePath; // 新增存储CSV文件路径的字段\n\n    private List<CardInfo> savedCardInfos = new List<CardInfo>(); // 保存卡片数据的列表\n\n\n    public RectTransform rectTransform;\n\n    private void OnEnable()\n    {\n        UpdateHeight(contentParent.childCount - 1); // 减去一个BatchRecord\n\n        // 初始化时隐藏插槽中的对象\n        slotObject.SetActive(false);\n\n        // 订阅InputField的事件\n        batchNameInputField.onValueChanged.AddListener(OnInputFieldValueChanged);\n        batchNameInputField.onEndEdit.AddListener(OnInputFieldEndEdit);\n\n        // 添加新的按钮事件监听器\n        addAllToCartButton.onClick.AddListener(OnAddAllToCartButtonClicked);\n        collapseButton.onClick.AddListener(ToggleCollapse); // 添加折叠按钮事件\n    }\n\n    // 切换折叠状态的方法\n    private void ToggleCollapse()\n    {\n        isCollapsed = !isCollapsed;\n\n        if (isCollapsed)\n        {\n            // 折叠时，仅隐藏所有CardPrefab对象\n            foreach (Transform child in contentParent)\n            {\n                if (child.gameObject.CompareTag(\"CardPrefab\"))\n                {\n                    child.gameObject.SetActive(false); // 隐藏卡片\n                }\n            }\n            // 更新高度为默认高度\n            rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, defaultHeight);\n        }\n        else\n        {\n            // 展开时，仅显示所有隐藏的CardPrefab对象\n            foreach (Transform child in contentParent)\n            {\n                if (child.gameObject.CompareTag(\"CardPrefab\"))\n                {\n                    child.gameObject.SetActive(true); // 显示卡片\n                }\n            }\n            // 更新高度为重新显示的Card数量的高度\n            UpdateHeight(contentParent.childCount - 1); // 恢复高度\n        }\n\n        // 通过旋转按钮来表示折叠/展开状态\n        collapseButton.GetComponent<RectTransform>().localRotation = isCollapsed\n            ? Quaternion.Euler(0, 0, 0) // 折叠时旋转到0度\n            : Quaternion.Euler(0, 0, -90);  // 展开时旋转到-90度\n    }\n\n\n\n\n    private void OnTransformChildrenChanged()\n    {\n        UpdateHeight(contentParent.childCount - 1); // 减去一个BatchRecord\n    }\n\n\n    public void SetupBatch(string batchName, string batchTime, List<CardInfo> cardInfos, string csvFilePath)\n    {\n        this.csvFilePath = csvFilePath;\n\n        // 允许 batchName 为空\n        batchNameText.text = string.IsNullOrEmpty(batchName) ? \"可输入批次名\" : batchName;\n        batchTimeText.text = batchTime;\n\n        // 保存CardInfo数据\n        savedCardInfos = cardInfos;\n\n        // 创建新的Card\n        foreach (var cardInfo in cardInfos)\n        {\n            GameObject cardObject = Instantiate(cardPrefab, contentParent);\n            cardObject.tag = \"CardPrefab\"; // 给cardPrefab加上Tag方便管理\n            HistoryCardUI cardUI = cardObject.GetComponent<HistoryCardUI>();\n            cardUI.SetupCard(\n                cardInfo.ID,\n                cardInfo.Name,\n                cardInfo.Description,\n                cardInfo.Height,\n                cardInfo.Version,\n                cardInfo.PrefabPath,\n                cardInfo.ThumbnailPath,\n                cardInfo.TypeTags,\n                cardInfo.ThemeTags,\n                cardInfo.FunctionTags,\n                cardInfo.DefinitionTags,\n                cardInfo.BatchTags,\n                cardInfo.PropertyTags,\n                cardInfo.ModelFaces,\n                cardInfo.CreationDate,\n                cardInfo.UpdatedDate,\n                csvFilePath // 传递CSV文件路径\n            );\n        }\n\n        // 添加按钮事件监听\n        saveBatchNameButton.onClick.AddListener(SaveBatchName);\n        deleteBatchButton.onClick.AddListener(DeleteBatch);\n    }\n\n\n    // 动态更新高度的方法\n    public void UpdateHeight(int cardCount)\n    {\n        if (rectTransform != null)\n        {\n            float newHeight = defaultHeight + (cardCount * cardHeightIncrement);\n            rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, newHeight);\n        }\n    }\n\n    // 保存批次名称的方法\n    public void SaveBatchName()\n    {\n        string newBatchName = batchNameInputField.text;\n        string oldBatchTime = batchTimeText.text;\n        CSVParser.RenameBatch(csvFilePath, oldBatchTime, newBatchName);\n        batchNameText.text = newBatchName; // 更新UI显示的批次名称",
    "chunk_order_index": 0,
    "full_doc_id": "doc-ab28674192433e0023803fb8df205d84"
  },
  "chunk-a05082d5bba1f1cf10ac20b4f8f13578": {
    "tokens": 1200,
    "content": "rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, newHeight);\n        }\n    }\n\n    // 保存批次名称的方法\n    public void SaveBatchName()\n    {\n        string newBatchName = batchNameInputField.text;\n        string oldBatchTime = batchTimeText.text;\n        CSVParser.RenameBatch(csvFilePath, oldBatchTime, newBatchName);\n        batchNameText.text = newBatchName; // 更新UI显示的批次名称\n    }\n\n    // 删除批次的方法\n    public void DeleteBatch()\n    {\n        string batchTime = batchTimeText.text;\n        CSVParser.DeleteBatch(csvFilePath, batchTime);\n        Destroy(gameObject); // 删除自身实例\n    }\n\n    // 移除Card并更新高度的方法\n    public void RemoveCard(GameObject cardObject)\n    {\n        Destroy(cardObject);\n        UpdateHeight(contentParent.childCount - 2); // 减去一个BatchRecord和将要移除的Card\n    }\n\n    // 增加Card并更新高度的方法\n    public void AddCard(CardInfo cardInfo)\n    {\n\n        GameObject cardObject = Instantiate(cardPrefab, contentParent);\n        HistoryCardUI cardUI = cardObject.GetComponent<HistoryCardUI>();\n        cardUI.SetupCard(\n            cardInfo.ID,\n            cardInfo.Name,\n            cardInfo.Description,\n            cardInfo.Height,\n            cardInfo.Version,\n            cardInfo.PrefabPath,\n            cardInfo.ThumbnailPath,\n            cardInfo.TypeTags,\n            cardInfo.ThemeTags,\n            cardInfo.FunctionTags,\n            cardInfo.DefinitionTags,\n            cardInfo.BatchTags,\n            cardInfo.PropertyTags,\n            cardInfo.ModelFaces,\n            cardInfo.CreationDate,\n            cardInfo.UpdatedDate,\n            csvFilePath // 传递CSV文件路径\n        );\n\n        UpdateHeight(contentParent.childCount - 1); // 减去一个BatchRecord\n\n    }\n\n    // 输入框内容改变时显示插槽中的对象\n    private void OnInputFieldValueChanged(string value)\n    {\n        if (!slotObject.activeSelf)\n        {\n            slotObject.SetActive(true);\n        }\n    }\n\n    // 输入框失去焦点时隐藏插槽中的对象\n    private void OnInputFieldEndEdit(string value)\n    {\n        if (string.IsNullOrEmpty(value))\n        {\n            slotObject.SetActive(false);\n        }\n    }\n\n    // 将所有资源添加到购物车的方法\n    private void OnAddAllToCartButtonClicked()\n    {\n        foreach (Transform child in contentParent)\n        {\n            HistoryCardUI cardUI = child.GetComponent<HistoryCardUI>();\n            if (cardUI != null)\n            {\n                cardUI.OnAddButtonClicked();\n            }\n        }\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\nBatchUI 是一个用于管理批次信息的用户界面组件，主要负责显示和操作批次数据，包括批次名称、时间、资源卡片以及其他相关功能。它在系统中扮演着重要的角色，作为用户与批次数据交互的前端界面，支持的主要特性包括：\n\n- **批次信息显示**：展示批次名称、时间以及包含的资源卡片\n- **动态布局调整**：根据卡片数量自动调整UI高度\n- **交互功能**：支持保存批次名称、删除批次、添加/移除资源卡片\n- **折叠/展开功能**：允许用户隐藏或显示批次内容以优化界面\n- **批量操作**：提供将所有资源一次性添加到购物车的功能\n\nBatchUI 使用 Unity 的 MonoBehaviour 作为基类，通过事件订阅和委托实现交互逻辑，依赖 TMP_InputField、Button 等 UI 组件以及 CSVParser 进行数据持久化处理。\n\n---\n\n### 2. 核心类解析\n\n#### BatchUI 类\n\n- **职责说明**：BatchUI 是一个 MonoBehaviour 组件，负责管理批次的 UI 显示和交互逻辑，包括批次信息的展示、卡片的动态增删、高度调整以及用户操作的响应。\n\n- **关键方法清单**：\n  - `void SetupBatch(string batchName, string batchTime, List<CardInfo> cardInfos, string csvFilePath)`\n  - `void UpdateHeight(int cardCount)`\n  - `void SaveBatchName()`\n  - `void DeleteBatch()`\n  - `void RemoveCard(GameObject cardObject)`\n  - `void AddCard(CardInfo cardInfo)`\n  - `void ToggleCollapse()`\n\n- **继承关系**：BatchUI -> MonoBehaviour -> Component -> Object\n\n- **依赖模块**：\n  - 内部类：CardInfo\n  - 其他类：CSVParser（用于 CSV 文件操作）、HistoryCardUI（用于管理单个卡片的 UI）\n\n---\n\n### 3. 关键方法详解\n\n#### 3.1 `void SetupBatch(string batchName, string batchTime, List<CardInfo> cardInfos, string csvFilePath)`\n\n- **方法签名**：`public void SetupBatch(string batchName, string batchTime, List<CardInfo> cardInfos, string csvFilePath)`\n\n- **功能描述**：初始化批次 UI，设置批次名称、时间，并根据传入的 `cardInfos` 创建对应的卡片预制体（CardPrefab）。该方法还会为按钮添加事件监听器。\n\n- **算法说明**：该方法通过遍历 `cardInfos` 列表，使用 `Instantiate` 创建每个卡片的预制体，并调用 `HistoryCardUI` 的 `SetupCard` 方法初始化每个卡片的数据。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-ab28674192433e0023803fb8df205d84"
  },
  "chunk-9d80fd849a2de9e7690c4dac05a6982e": {
    "tokens": 1157,
    "content": "**功能描述**：初始化批次 UI，设置批次名称、时间，并根据传入的 `cardInfos` 创建对应的卡片预制体（CardPrefab）。该方法还会为按钮添加事件监听器。\n\n- **算法说明**：该方法通过遍历 `cardInfos` 列表，使用 `Instantiate` 创建每个卡片的预制体，并调用 `HistoryCardUI` 的 `SetupCard` 方法初始化每个卡片的数据。\n\n- **调用关系**：通常在外部（如父容器或管理类）调用此方法来初始化批次数据。被 `OnEnable` 和外部管理类调用。\n\n---\n\n#### 3.2 `void UpdateHeight(int cardCount)`\n\n- **方法签名**：`public void UpdateHeight(int cardCount)`\n\n- **功能描述**：根据传入的卡片数量 `cardCount` 动态调整批次容器的高度，公式为 `defaultHeight + (cardCount * cardHeightIncrement)`。\n\n- **算法说明**：通过计算新的高度值，更新 `RectTransform` 的 `sizeDelta` 属性以调整 UI 容器的高度。\n\n- **调用关系**：在 `OnTransformChildrenChanged`、`ToggleCollapse`、`AddCard`、`RemoveCard` 等方法中被频繁调用，以确保 UI 高度始终与当前显示的卡片数量一致。\n\n---\n\n#### 3.3 `void SaveBatchName()`\n\n- **方法签名**：`public void SaveBatchName()`\n\n- **功能描述**：将用户输入的批次名称保存到 CSV 文件中，并更新 UI 显示。\n\n- **算法说明**：读取 `TMP_InputField` 的当前值，调用 `CSVParser.RenameBatch` 方法更新 CSV 文件中的批次名称，并更新 `batchNameText` 的显示。\n\n- **调用关系**：在 `saveBatchNameButton` 的点击事件中被调用。\n\n---\n\n#### 3.4 `void DeleteBatch()`\n\n- **方法签名**：`public void DeleteBatch()`\n\n- **功能描述**：删除当前批次的所有数据，并从 UI 中移除该批次组件。\n\n- **算法说明**：调用 `CSVParser.DeleteBatch` 方法删除 CSV 文件中的批次记录，然后调用 `Destroy(gameObject)` 销毁当前批次的 UI 组件。\n\n- **调用关系**：在 `deleteBatchButton` 的点击事件中被调用。\n\n---\n\n#### 3.5 `void AddCard(CardInfo cardInfo)`\n\n- **方法签名**：`public void AddCard(CardInfo cardInfo)`\n\n- **功能描述**：向批次中添加一个新的资源卡片，并更新 UI 显示。\n\n- **算法说明**：通过 `Instantiate` 创建一个新的卡片预制体，并调用 `HistoryCardUI` 的 `SetupCard` 方法初始化卡片数据，最后调用 `UpdateHeight` 更新批次容器的高度。\n\n- **调用关系**：在需要添加资源卡片的场景中被调用，例如用户点击“添加卡片”按钮时。\n\n---\n\n#### 3.6 `void ToggleCollapse()`\n\n- **方法签名**：`private void ToggleCollapse()`\n\n- **功能描述**：切换批次的折叠/展开状态，控制卡片的显示和隐藏，并调整 UI 高度。\n\n- **算法说明**：通过遍历 `contentParent` 的子节点，隐藏或显示所有标记为 \"CardPrefab\" 的卡片。在折叠状态下，UI 高度恢复为 `defaultHeight`；在展开状态下，UI 高度根据当前卡片数量重新计算。\n\n- **调用关系**：在 `collapseButton` 的点击事件中被调用。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class BatchUI {\n        +MonoBehaviour\n        +TextMeshProUGUI batchNameText\n        +TextMeshProUGUI batchTimeText\n        +Transform contentParent\n        +GameObject cardPrefab\n        +float cardHeightIncrement\n        +float defaultHeight\n        +TMP_InputField batchNameInputField\n        +Button saveBatchNameButton\n        +Button deleteBatchButton\n        +Button addAllToCartButton\n        +GameObject slotObject\n        +Button collapseButton\n        +bool isCollapsed\n        +string csvFilePath\n        +List<CardInfo> savedCardInfos\n        +RectTransform rectTransform\n        +void SetupBatch(string, string, List<CardInfo>, string)\n        +void UpdateHeight(int)\n        +void SaveBatchName()\n        +void DeleteBatch()\n        +void RemoveCard(GameObject)\n        +void AddCard(CardInfo)\n        +void ToggleCollapse()\n    }\n\n    class MonoBehaviour {\n        +Component\n    }\n\n    class Component {\n        +Object\n    }\n\n    class Object {\n    }\n\n    class CSVParser {\n        +void RenameBatch(string, string, string)\n        +void DeleteBatch(string, string)\n    }\n\n    class HistoryCardUI {\n        +void SetupCard(string, string, string, float, string, string, string, List<string>, List<string>, List<string>, List<string>, List<string>, List<string>, int, string, string, string)\n        +void OnAddButtonClicked()\n    }\n\n    BatchUI --> CSVParser : 依赖\n    BatchUI --> HistoryCardUI : 依赖\n    BatchUI --> MonoBehaviour : 继承\n```",
    "chunk_order_index": 2,
    "full_doc_id": "doc-ab28674192433e0023803fb8df205d84"
  },
  "chunk-bb32cbf368c380c1b5abfde440b3ed38": {
    "tokens": 57,
    "content": ">, List<string>, int, string, string, string)\n        +void OnAddButtonClicked()\n    }\n\n    BatchUI --> CSVParser : 依赖\n    BatchUI --> HistoryCardUI : 依赖\n    BatchUI --> MonoBehaviour : 继承\n```",
    "chunk_order_index": 3,
    "full_doc_id": "doc-ab28674192433e0023803fb8df205d84"
  },
  "chunk-2dbbd4cc5e59eb27593fbfc92885b373": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing UnityEngine;\n\npublic class CSVParser : MonoBehaviour\n{\n    public static (string userName, string userAvatar, List<(string batchName, string batchTime, List<CardInfo> cardInfos)> batches) ParseCSV(string filePath)\n    {\n        List<(string batchName, string batchTime, List<CardInfo> cardInfos)> batchList = new List<(string batchName, string batchTime, List<CardInfo> cardInfos)>();\n        string userName = string.Empty;\n        string userAvatar = string.Empty;\n\n        if (!File.Exists(filePath))\n        {\n            Debug.LogError(\"CSV file not found: \" + filePath);\n            return (userName, userAvatar, batchList);\n        }\n\n        string[] lines = File.ReadAllLines(filePath, Encoding.UTF8);\n\n        // 解析用户名称和用户头像\n        if (lines.Length > 1)\n        {\n            string[] userInfo = lines[1].Split(',');\n            if (userInfo.Length >= 2)\n            {\n                userName = userInfo[0];\n                userAvatar = userInfo[1];\n            }\n        }\n\n        string currentBatchName = string.Empty;\n        string currentBatchTime = string.Empty;\n        List<CardInfo> currentBatchCards = new List<CardInfo>();\n\n        for (int i = 3; i < lines.Length; i++)\n        {\n            string[] data = lines[i].Split(',');\n\n            if (data[0].StartsWith(\"批次\"))\n            {\n                // 如果已有当前批次信息，添加到列表中\n                if (!string.IsNullOrEmpty(currentBatchName) || !string.IsNullOrEmpty(currentBatchTime) || currentBatchCards.Count > 0)\n                {\n                    batchList.Add((currentBatchName, currentBatchTime, currentBatchCards));\n                }\n\n                if (data.Length > 2)\n                {\n                    currentBatchName = data[1]; // 批次名称在\"批次\"后面一格，允许为空\n                    currentBatchTime = data[2]; // 批次时间在第三格\n                }\n                currentBatchCards = new List<CardInfo>();\n            }\n            else if (data.Length >= 16)\n            {\n                CardInfo card = new CardInfo(\n                    data[0], // ID\n                    data[1], // Name\n                    data[2], // Description\n                    data[3], // Height\n                    data[4], // PrefabPath\n                    data[5], // ThumbnailPath\n                    data[6], // ModelFaces\n                    data[7], // CreationDate\n                    data[8], // UpdatedDate\n                    data[9], // Version\n                    data[10], // TypeTags\n                    data[11], // ThemeTags\n                    data[12], // FunctionTags\n                    data[13], // DefinitionTags\n                    data[14], // BatchTags\n                    data[15]  // PropertyTags\n                );\n\n                currentBatchCards.Add(card);\n            }\n            else\n            {\n                Debug.LogWarning(\"Incorrect data format in line: \" + i);\n            }\n        }\n\n        // 处理最后一个批次\n        if (!string.IsNullOrEmpty(currentBatchName) || !string.IsNullOrEmpty(currentBatchTime) || currentBatchCards.Count > 0)\n        {\n            batchList.Add((currentBatchName, currentBatchTime, currentBatchCards));\n        }\n\n        return (userName, userAvatar, batchList);\n    }\n\n\n\n    public static void DeleteResource(string filePath, string resourceId)\n    {\n        List<string> lines = new List<string>(File.ReadAllLines(filePath, Encoding.UTF8));\n        lines.RemoveAll(line => line.Contains(resourceId));\n        File.WriteAllLines(filePath, lines, Encoding.UTF8);\n    }\n\n    public static void DeleteBatch(string filePath, string batchTime)\n    {\n        List<string> lines = new List<string>(File.ReadAllLines(filePath, Encoding.UTF8));\n        bool inBatch = false;\n        bool batchFound = false;\n\n        for (int i = 0; i < lines.Count; i++)\n        {\n            if (lines[i].StartsWith(\"批次\") && lines[i].Contains(batchTime))\n            {\n                inBatch = true;\n                batchFound = true;\n            }\n\n            if (inBatch)\n            {\n                lines.RemoveAt(i);\n                i--; // 调整索引以便正确删除连续的行\n\n                // 检查是否是下一个批次的开始，如果是则停止删除\n                if (i + 1 < lines.Count && lines[i + 1].StartsWith(\"批次\"))\n                {\n                    inBatch = false;\n                }\n            }\n        }\n\n        if (batchFound)\n        {\n            File.WriteAllLines(filePath, lines, Encoding.UTF8);\n        }\n        else\n        {\n            Debug.LogWarning(\"Batch not found: \" + batchTime);\n        }\n    }\n\n\n    public static void RenameBatch(string filePath, string oldBatchTime, string newBatchName)\n    {\n        List<string> lines = new List<string>(File.ReadAllLines(filePath, Encoding.UTF8));\n\n        for (int i = 0; i < lines.Count; i++)\n        {\n            if (lines[i].StartsWith(\"批次\") && lines[i].Contains(oldBatchTime))\n            {\n                string[] parts = lines[i].Split(',');\n                if (parts.Length > 2 && parts[2] == oldBatchTime)\n                {\n                    parts[1] = newBatchName;\n                    lines[i] = string.Join(\",\", parts);\n                }\n            }\n        }\n\n        File.WriteAllLines(filePath, lines, Encoding.UTF8);\n    }\n    public static bool ResourceExistsIn",
    "chunk_order_index": 0,
    "full_doc_id": "doc-4634888f80a9068398d3b0bebecbfbdb"
  },
  "chunk-b083dc992700eb8306507e48d1aa2a8d": {
    "tokens": 1200,
    "content": "(lines[i].StartsWith(\"批次\") && lines[i].Contains(oldBatchTime))\n            {\n                string[] parts = lines[i].Split(',');\n                if (parts.Length > 2 && parts[2] == oldBatchTime)\n                {\n                    parts[1] = newBatchName;\n                    lines[i] = string.Join(\",\", parts);\n                }\n            }\n        }\n\n        File.WriteAllLines(filePath, lines, Encoding.UTF8);\n    }\n    public static bool ResourceExistsInBatch(string filePath, string resourceId, string targetBatchTime)\n    {\n        List<string> lines = new List<string>(File.ReadAllLines(filePath, Encoding.UTF8));\n        bool inTargetBatch = false;\n\n        foreach (string line in lines)\n        {\n            if (line.StartsWith(\"批次\") && line.Contains(targetBatchTime))\n            {\n                inTargetBatch = true;\n            }\n            else if (line.StartsWith(\"批次\"))\n            {\n                inTargetBatch = false;\n            }\n\n            if (inTargetBatch && line.Contains(resourceId))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    public static void DeleteResourceInBatch(string filePath, string resourceId, string batchTime)\n    {\n        List<string> lines = new List<string>(File.ReadAllLines(filePath, Encoding.UTF8));\n        bool inTargetBatch = false;\n\n        for (int i = 0; i < lines.Count; i++)\n        {\n            if (lines[i].StartsWith(\"批次\") && lines[i].Contains(batchTime))\n            {\n                inTargetBatch = true;\n            }\n            else if (lines[i].StartsWith(\"批次\"))\n            {\n                inTargetBatch = false;\n            }\n\n            if (inTargetBatch && lines[i].Contains(resourceId))\n            {\n                lines.RemoveAt(i);\n                break;\n            }\n        }\n\n        File.WriteAllLines(filePath, lines, Encoding.UTF8);\n    }\n    public static void MoveResourceToBatch(string filePath, string resourceId, string targetBatchTime)\n    {\n        List<string> lines = new List<string>(File.ReadAllLines(filePath, Encoding.UTF8));\n        string resourceLine = lines.Find(line => line.Contains(resourceId) && !line.StartsWith(\"批次\"));\n        lines.Remove(resourceLine);\n\n        int targetBatchIndex = lines.FindIndex(line => line.StartsWith(\"批次\") && line.Contains(targetBatchTime));\n        if (targetBatchIndex != -1)\n        {\n            int insertIndex = targetBatchIndex + 1;\n            while (insertIndex < lines.Count && !lines[insertIndex].StartsWith(\"批次\"))\n            {\n                insertIndex++;\n            }\n            lines.Insert(insertIndex, resourceLine);\n        }\n\n        File.WriteAllLines(filePath, lines, Encoding.UTF8);\n    }\n\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n- **功能定位**：`CSVParser` 类主要用于解析和操作 CSV 文件中的用户信息和批次数据。它能够读取 CSV 文件，提取用户名称、用户头像以及多个批次的信息，每个批次包含卡片信息。此外，该类还支持删除资源、删除批次、重命名批次、检查资源是否存在、删除特定批次中的资源以及将资源移动到其他批次。\n\n- **在系统中的角色和重要性**：在 Unity 项目中，该类作为数据处理的核心组件，负责 CSV 文件的解析和操作，为其他模块提供数据支持。它通过解析 CSV 文件，提取结构化数据，便于其他模块进行处理和展示。\n\n- **主要特性与技术实现方案**：\n  - **CSV 解析**：使用 `File.ReadAllLines` 读取 CSV 文件，并通过 `Split` 方法解析每一行的数据。\n  - **数据结构**：使用元组和自定义类 `CardInfo` 来存储用户和卡片信息。\n  - **文件操作**：通过 `File.WriteAllLines` 方法实现对 CSV 文件的写入操作。\n  - **异常处理**：使用 `Debug.LogError` 和 `Debug.LogWarning` 提供错误和警告信息。\n\n### 2. 核心类解析\n\n#### `CSVParser`\n\n- **职责说明**：该类主要用于解析 CSV 文件，提取用户信息和批次数据，并提供对 CSV 文件的增删改查操作。\n\n- **关键方法清单**：\n  - `public static (string userName, string userAvatar, List<(string batchName, string batchTime, List<CardInfo> cardInfos)> batches) ParseCSV(string filePath)`\n  - `public static void DeleteResource(string filePath, string resourceId)`\n  - `public static void DeleteBatch(string filePath, string batchTime)`\n  - `public static void RenameBatch(string filePath, string oldBatchTime, string newBatchName)`\n  - `public static bool ResourceExistsInBatch(string filePath, string resourceId, string targetBatchTime)`\n  - `public static void DeleteResourceInBatch(string filePath, string resourceId, string batchTime)`\n  - `public static void MoveResourceToBatch(string filePath, string resourceId, string targetBatchTime)`\n\n- **继承关系**：\n  ```\n  CSVParser -> MonoBehaviour\n  ```\n\n- **依赖模块**：\n  - `UnityEngine` 命名空间中的类。\n  - `System.Collections.Generic` 命名空间中的 `List<T>` 和 `Tuple`。\n  - `System.IO` 命名空间中的文件操作类。\n  - `System.Text` 命名空间中的 `Encoding`。\n  - 项目内的 `CardInfo` 类。\n\n### 3. 关键方法详解\n\n#### `",
    "chunk_order_index": 1,
    "full_doc_id": "doc-4634888f80a9068398d3b0bebecbfbdb"
  },
  "chunk-e3726bb5f102892d071ae98cbb7db4a3": {
    "tokens": 1200,
    "content": "Behaviour\n  ```\n\n- **依赖模块**：\n  - `UnityEngine` 命名空间中的类。\n  - `System.Collections.Generic` 命名空间中的 `List<T>` 和 `Tuple`。\n  - `System.IO` 命名空间中的文件操作类。\n  - `System.Text` 命名空间中的 `Encoding`。\n  - 项目内的 `CardInfo` 类。\n\n### 3. 关键方法详解\n\n#### `ParseCSV` 方法\n\n- **方法签名**：\n  ```csharp\n  public static (string userName, string userAvatar, List<(string batchName, string batchTime, List<CardInfo> cardInfos)> batches) ParseCSV(string filePath)\n  ```\n\n- **功能描述**：该方法读取指定路径的 CSV 文件，解析其中的用户信息和批次数据，并返回一个包含用户名、用户头像和批次列表的元组。\n\n- **算法说明**：\n  1. 检查文件是否存在，如果不存在则返回空值。\n  2. 读取文件的所有行。\n  3. 解析用户信息（用户名和用户头像）。\n  4. 逐行解析文件内容，识别批次信息和卡片信息。\n  5. 将解析的批次信息和卡片信息存储在列表中，并最终返回。\n\n- **调用关系**：该方法可能被其他需要解析 CSV 文件的模块调用，频率较高。\n\n#### `DeleteResource` 方法\n\n- **方法签名**：\n  ```csharp\n  public static void DeleteResource(string filePath, string resourceId)\n  ```\n\n- **功能描述**：该方法通过移除包含指定资源 ID 的行来删除 CSV 文件中的资源。\n\n- **算法说明**：\n  1. 读取文件的所有行。\n  2. 移除包含指定资源 ID 的行。\n  3. 将修改后的内容写回文件。\n\n- **调用关系**：可能在需要删除资源的场景中被调用，频率适中。\n\n#### `DeleteBatch` 方法\n\n- **方法签名**：\n  ```csharp\n  public static void DeleteBatch(string filePath, string batchTime)\n  ```\n\n- **功能描述**：该方法删除 CSV 文件中指定批次及其相关资源。\n\n- **算法说明**：\n  1. 读取文件的所有行。\n  2. 逐行检查，识别出指定批次及其资源，并移除这些行。\n  3. 将修改后的内容写回文件。\n\n- **调用关系**：可能在需要删除批次的场景中被调用，频率适中。\n\n#### `RenameBatch` 方法\n\n- **方法签名**：\n  ```csharp\n  public static void RenameBatch(string filePath, string oldBatchTime, string newBatchName)\n  ```\n\n- **功能描述**：该方法将 CSV 文件中指定批次的名称修改为新的名称。\n\n- **算法说明**：\n  1. 读取文件的所有行。\n  2. 找到指定批次的行，修改其名称。\n  3. 将修改后的内容写回文件。\n\n- **调用关系**：可能在需要重命名批次的场景中被调用，频率较低。\n\n#### `ResourceExistsInBatch` 方法\n\n- **方法签名**：\n  ```csharp\n  public static bool ResourceExistsInBatch(string filePath, string resourceId, string targetBatchTime)\n  ```\n\n- **功能描述**：该方法检查指定资源是否存在于指定批次中。\n\n- **算法说明**：\n  1. 读取文件的所有行。\n  2. 逐行检查，判断资源是否存在于目标批次中。\n\n- **调用关系**：可能在需要验证资源存在性的场景中被调用，频率较高。\n\n#### `DeleteResourceInBatch` 方法\n\n- **方法签名**：\n  ```csharp\n  public static void DeleteResourceInBatch(string filePath, string resourceId, string batchTime)\n  ```\n\n- **功能描述**：该方法删除指定批次中的指定资源。\n\n- **算法说明**：\n  1. 读取文件的所有行。\n  2. 在目标批次中找到指定资源并移除。\n  3. 将修改后的内容写回文件。\n\n- **调用关系**：可能在需要删除批次中资源的场景中被调用，频率适中。\n\n#### `MoveResourceToBatch` 方法\n\n- **方法签名**：\n  ```csharp\n  public static void MoveResourceToBatch(string filePath, string resourceId, string targetBatchTime)\n  ```\n\n- **功能描述**：该方法将指定资源移动到指定批次中。\n\n- **算法说明**：\n  1. 读取文件的所有行。\n  2. 找到指定资源并将其从当前批次移除。\n  3. 将资源添加到目标批次中。\n  4. 将修改后的内容写回文件。\n\n- **调用关系**：可能在需要移动资源的场景中被调用，频率适中。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class CSVParser {\n        +public static ParseCSV(filePath: string): (userName: string, userAvatar: string, batches: List<(batchName: string, batchTime: string, cardInfos: List<CardInfo>)>)\n        +public static DeleteResource(filePath: string, resourceId: string)\n        +public static DeleteBatch(filePath: string",
    "chunk_order_index": 2,
    "full_doc_id": "doc-4634888f80a9068398d3b0bebecbfbdb"
  },
  "chunk-99ba25d5e1ea99b882f847ea45ca057a": {
    "tokens": 313,
    "content": "被调用，频率适中。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class CSVParser {\n        +public static ParseCSV(filePath: string): (userName: string, userAvatar: string, batches: List<(batchName: string, batchTime: string, cardInfos: List<CardInfo>)>)\n        +public static DeleteResource(filePath: string, resourceId: string)\n        +public static DeleteBatch(filePath: string, batchTime: string)\n        +public static RenameBatch(filePath: string, oldBatchTime: string, newBatchName: string)\n        +public static ResourceExistsInBatch(filePath: string, resourceId: string, targetBatchTime: string): bool\n        +public static DeleteResourceInBatch(filePath: string, resourceId: string, batchTime: string)\n        +public static MoveResourceToBatch(filePath: string, resourceId: string, targetBatchTime: string)\n    }\n\n    class CardInfo {\n        +string ID\n        +string Name\n        +string Description\n        +string Height\n        +string PrefabPath\n        +string ThumbnailPath\n        +string ModelFaces\n        +string CreationDate\n        +string UpdatedDate\n        +string Version\n        +string TypeTags\n        +string ThemeTags\n        +string FunctionTags\n        +string DefinitionTags\n        +string BatchTags\n        +string PropertyTags\n    }\n\n    CSVParser --> CardInfo: 使用\n```",
    "chunk_order_index": 3,
    "full_doc_id": "doc-4634888f80a9068398d3b0bebecbfbdb"
  },
  "chunk-655f4491e6f91d030deaa7e6afad0bfd": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing TMPro;\nusing System.Text;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\n#if UNITY_EDITOR\nusing UnityEditor;\nusing PartyIP.AssetExport;\n#endif\nusing System;\nusing System.Reflection;\n\npublic class PurchaseRecordWriter : MonoBehaviour\n{\n    public Button savePurchaseRecordButton; // 插槽：用于保存购买记录的按钮\n    public Transform contentParent; // 插槽：用于获取Content Parent中的资源卡\n    public GameObject title; // 插槽：用于显示标题\n    public GameObject purchaseFailedUI; // 插槽：用于显示购买失败消息的UI\n    public GameObject pathAddFailedUI; // 插槽：用于显示路径添加失败消息的UI\n\n    private const string CsvHeader = \"资源ID,资源名称,资源描述,物品高度,预制体路径,缩略图路径,面数,创建时间,更新时间,版本,类型标签,主题标签,功能标签,区域标签,批次标签,属性标签\";\n\n    private void Start()\n    {\n        if (savePurchaseRecordButton != null)\n        {\n            savePurchaseRecordButton.onClick.AddListener(SavePurchaseRecord);\n        }\n\n        if (title != null)\n        {\n            title.SetActive(false); // 确保初始状态是隐藏的\n        }\n\n        if (purchaseFailedUI != null)\n        {\n            purchaseFailedUI.SetActive(false); // 确保初始状态是隐藏的\n        }\n\n        if (pathAddFailedUI != null)\n        {\n            pathAddFailedUI.SetActive(false); // 确保初始状态是隐藏的\n        }\n\n#if UNITY_EDITOR\n        // 初始化时打开AssetExportWindow\n        OpenAssetExportWindow();\n        AssetExportCallbackRegistery.RegisterOnExportFinished(OnAssetExportFinished);\n        AssetExportCallbackRegistery.RegisterOnExportFailed(OnAssetExportFailed);\n#endif\n    }\n\n#if UNITY_EDITOR\n    //导出工具返回值\n    private void OnAssetExportFailed(string message)\n    {\n        Debug.Log(\"FAILED:\" + message);\n    }\n    private void OnAssetExportFinished()\n    {\n        Debug.Log(\"FINISHED\");\n    }\n\n    private Type GetExportWindowType()\n    {\n        if (m_ExportWindowType != null)\n        {\n            return m_ExportWindowType;\n        }\n\n        Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();\n        Assembly target = null;\n        foreach (var assembly in assemblies)\n        {\n            string name = assembly.FullName.ToLower().Replace(\"-\", \"\").Replace(\".\", \"\");\n            if (assembly.FullName.ToLower().Contains(\"assetexport\"))\n            {\n                target = assembly;\n                break;\n            }\n        }\n\n        if (target != null)\n        {\n            m_ExportWindowType = target.GetType(\"PartyIP.AssetExport.AssetExportWindow\");\n        }\n\n        return m_ExportWindowType;\n    }\n\n    private bool AddPathToExportWindow(string path)\n    {\n        if (m_ExportWindow == null)\n        {\n            Debug.LogError(\"导出窗口没打开\");\n            return false;\n        }\n\n        var IAddPathFunc = m_ExportWindowType.GetMethod(\"AddPath\");\n        try\n        {\n            string error = (string)IAddPathFunc.Invoke((object)m_ExportWindow, new object[] { path, true, true });\n            if (string.IsNullOrEmpty(error))\n            {\n                Debug.Log(\"路径添加成功\");\n                return true;\n            }\n            else\n            {\n                Debug.LogError($\"路径添加失败: {error}\");\n                ShowPathAddFailed(path); // 显示路径添加失败消息的UI\n                return false;\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"报错: {e.InnerException.Message}\");\n            ShowPathAddFailed(path); // 显示路径添加失败消息的UI\n            return false;\n        }\n    }\n\n    private void ShowPathAddFailed(string failedPath)\n    {\n        foreach (Transform child in contentParent)\n        {\n            SelectedCardUI cardUI = child.GetComponent<SelectedCardUI>();\n            if (cardUI != null && cardUI.prefabPathText.text == failedPath)\n            {\n                cardUI.SetPathErrorUIVisibility(true); // 显示路径错误UI\n            }\n        }\n\n        if (pathAddFailedUI != null)\n        {\n            pathAddFailedUI.SetActive(true); // 显示路径添加失败消息的UI\n        }\n    }\n\n    private EditorWindow m_ExportWindow = null;\n    private Type m_ExportWindowType = null;\n\n    private void OpenAssetExportWindow()\n    {\n        EditorApplication.delayCall += () =>\n        {\n            m_ExportWindow = EditorWindow.GetWindow(GetExportWindowType());\n        };\n    }\n#endif\n\n    private void SavePurchaseRecord()\n    {\n        List<CardInfo> cardInfos = new List<CardInfo>();\n        bool hasDuplicate = false;\n\n        foreach (Transform child in contentParent)\n        {\n            SelectedCardUI cardUI = child.GetComponent<SelectedCardUI>();\n            if (cardUI != null)\n            {\n                // 获取缩略图名称\n                string thumbnailName = string.Empty;\n                if (cardUI.thumbnailImage.sprite != null)\n                {\n#if UNITY_EDITOR\n                    // 假设缩略图路径存储在sprite.name中\n                    string thumbnailPath = AssetDatabase.GetAssetPath(cardUI.thumbnailImage.sprite.texture);\n                    thumbnailName = Path.GetFileNameWithoutExtension(thumbnailPath); // 获取文件名，不包含路径和扩展名\n#endif\n                }\n\n                CardInfo card = new CardInfo(\n                    cardUI.idText.text,\n                    cardUI.nameText.text,\n                    cardUI.descriptionText.text,\n                    cardUI.heightText.text,\n                    cardUI.pref",
    "chunk_order_index": 0,
    "full_doc_id": "doc-af2e328d1aba11df0974408e382c7f16"
  },
  "chunk-7723cbe94a281434203e34791d31667c": {
    "tokens": 1200,
    "content": "设缩略图路径存储在sprite.name中\n                    string thumbnailPath = AssetDatabase.GetAssetPath(cardUI.thumbnailImage.sprite.texture);\n                    thumbnailName = Path.GetFileNameWithoutExtension(thumbnailPath); // 获取文件名，不包含路径和扩展名\n#endif\n                }\n\n                CardInfo card = new CardInfo(\n                    cardUI.idText.text,\n                    cardUI.nameText.text,\n                    cardUI.descriptionText.text,\n                    cardUI.heightText.text,\n                    cardUI.prefabPathText.text,\n                    thumbnailName,\n                    cardUI.modelFacesText.text,\n                    cardUI.creationDateText.text,\n                    cardUI.updatedDateText.text,\n                    cardUI.versionText.text,\n                    cardUI.typeTagsText.text,\n                    cardUI.themeTagsText.text,\n                    cardUI.functionTagsText.text,\n                    cardUI.definitionTagsText.text,\n                    cardUI.batchTagsText.text,\n                    cardUI.propertyTagsText.text\n                );\n                cardInfos.Add(card);\n            }\n        }\n\n#if UNITY_EDITOR\n        string userKey = PlayerPrefs.GetString(\"currentUserKey\", string.Empty);\n        if (!string.IsNullOrEmpty(userKey))\n        {\n            string folderPath = Path.Combine(Application.dataPath, \"ZTResource/UserInfo\");\n            string fileName = userKey + \".csv\";\n            string filePath = Path.Combine(folderPath, fileName);\n\n            List<string> existingIds = new List<string>();\n\n            if (File.Exists(filePath))\n            {\n                existingIds = GetExistingIds(filePath);\n\n                foreach (var card in cardInfos)\n                {\n                    if (existingIds.Contains(card.ID))\n                    {\n                        hasDuplicate = true;\n                        HighlightExistingCard(card.ID);\n                    }\n                }\n            }\n\n            if (hasDuplicate)\n            {\n                ShowPurchaseFailed();\n                return;\n            }\n\n            // 尝试写入记录\n            try\n            {\n                WritePurchaseRecord(cardInfos, filePath);\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"写入记录失败: {e.Message}\");\n                ShowPurchaseFailed(); // 显示购买失败消息的UI\n                return;\n            }\n\n            // 强制刷新Unity的资源数据库\n            UnityEditor.AssetDatabase.Refresh();\n\n            // 购买成功，调用CustomEventSystem.RaiseAddPrefabPath\n            foreach (var card in cardInfos)\n            {\n                if (!AddPathToExportWindow(card.PrefabPath))\n                {\n                    ShowPathAddFailed(card.PrefabPath); // 显示路径添加失败消息的UI\n                    return;\n                }\n            }\n        }\n#endif\n\n        // 不论编辑器还是打包后的版本，都执行路径复制和显示UI\n        CopyAllPrefabPathsToClipboard(); // 复制路径到剪贴板\n\n        if (title != null)\n        {\n            title.SetActive(true); // 显示标题\n            StartCoroutine(HideTitleAfterSeconds(3)); // 3秒后隐藏标题\n        }\n    }\n\n\n\n\n    private List<string> GetExistingIds(string filePath)\n    {\n        List<string> ids = new List<string>();\n        string[] lines = File.ReadAllLines(filePath, Encoding.UTF8);\n\n        for (int i = 3; i < lines.Length; i++) // 从第四行开始读取数据\n        {\n            string[] values = lines[i].Split(',');\n            if (values.Length > 0)\n            {\n                ids.Add(values[0]);\n            }\n        }\n\n        return ids;\n    }\n\n    private void ShowPurchaseFailed()\n    {\n        if (purchaseFailedUI != null)\n        {\n            purchaseFailedUI.SetActive(true); // 显示购买失败消息的UI\n        }\n    }\n\n    private void HighlightExistingCard(string id)\n    {\n        foreach (Transform child in contentParent)\n        {\n            SelectedCardUI cardUI = child.GetComponent<SelectedCardUI>();\n            if (cardUI != null && cardUI.idText.text == id)\n            {\n                cardUI.SetDistinctionUIVisibility(true); // 显示区分UI\n            }\n        }\n    }\n\n    public static void WritePurchaseRecord(List<CardInfo> cardInfos, string filePath)\n    {\n        if (cardInfos == null || cardInfos.Count == 0) return;\n\n        List<string> lines = new List<string>(File.ReadAllLines(filePath, Encoding.UTF8));\n\n        // 确保第三行是CsvHeader\n        if (lines.Count < 3 || lines[2] != CsvHeader)\n        {\n            if (lines.Count < 3)\n            {\n                while (lines.Count < 3)\n                {\n                    lines.Add(string.Empty);\n                }\n            }\n            lines[2] = CsvHeader;\n        }\n\n        // 修改时间格式为精确到秒\n        string batchTitle = $\"批次,,{System.DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\")}\";\n        lines.Add(batchTitle);\n\n        foreach (var card in cardInfos)\n        {\n            string line = $\"{card.ID},{card.Name},{card.Description},{card.Height},{card.PrefabPath},{card.ThumbnailPath},{card.ModelFaces},{card.CreationDate},{card.UpdatedDate},{card.Version},{card.TypeTags},{card.ThemeTags},{card.FunctionTags},{card.DefinitionTags},{card.BatchTags},{card.PropertyTags}\";\n            lines.Add(line);\n        }\n\n        File.WriteAllLines(filePath, lines, Encoding.UTF8);\n    }\n\n\n    private void CopyAllPrefabPathsToClipboard()\n    {\n        StringBuilder paths = new StringBuilder();\n        // 遍历contentParent下的所有子物体\n        foreach (Transform child in contentParent)\n        {\n            // 获取SelectedCardUI组件\n            SelectedCardUI cardUI = child.GetComponent<SelectedCardUI>();\n            if (cardUI != null && cardUI.prefabPathText != null) // 确",
    "chunk_order_index": 1,
    "full_doc_id": "doc-af2e328d1aba11df0974408e382c7f16"
  },
  "chunk-7ddae808e100387bab1beed242f3bef6": {
    "tokens": 1200,
    "content": "Path, lines, Encoding.UTF8);\n    }\n\n\n    private void CopyAllPrefabPathsToClipboard()\n    {\n        StringBuilder paths = new StringBuilder();\n        // 遍历contentParent下的所有子物体\n        foreach (Transform child in contentParent)\n        {\n            // 获取SelectedCardUI组件\n            SelectedCardUI cardUI = child.GetComponent<SelectedCardUI>();\n            if (cardUI != null && cardUI.prefabPathText != null) // 确保Prefab Path Text对象存在\n            {\n                TextMeshProUGUI tmpText = cardUI.prefabPathText.GetComponent<TextMeshProUGUI>();\n                if (tmpText != null)\n                {\n                    paths.AppendLine(tmpText.text); // 添加到StringBuilder\n                }\n            }\n        }\n\n        // 将路径字符串复制到剪贴板\n        GUIUtility.systemCopyBuffer = paths.ToString();\n    }\n\n    IEnumerator HideTitleAfterSeconds(float seconds)\n    {\n        yield return new WaitForSeconds(seconds);\n        if (title != null)\n        {\n            title.SetActive(false);\n        }\n    }\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n**功能定位**  \n`PurchaseRecordWriter` 是一个用于管理购买记录的脚本，主要负责将用户购买的资源信息保存为 CSV 文件，并提供与 Unity 编辑器集成的功能，例如导出资源路径和处理导出过程中的错误。\n\n**在系统/项目中的角色和重要性**  \n该脚本在资源管理系统中扮演关键角色，用于记录和管理用户购买的资源信息。它确保数据的持久化存储，并在 Unity 编辑器环境中提供资源导出功能。其重要性体现在以下几个方面：\n- 数据持久化：将购买记录保存为 CSV 文件，便于后续处理和分析。\n- 用户反馈：通过 UI 提供购买成功/失败的反馈。\n- 资源管理：与 Unity 导出工具集成，确保资源路径的正确性和完整性。\n\n**支持的主要特性与技术实现方案**  \n- **数据持久化**：使用 CSV 格式存储购买记录。\n- **UI 反馈**：通过 Unity UI 组件显示购买状态和错误信息。\n- **资源管理**：与 Unity 编辑器的导出工具集成，动态添加资源路径。\n- **反射机制**：使用 `Reflection` 访问和调用导出窗口的方法。\n- **错误处理**：捕获和显示导出过程中可能发生的错误。\n\n---\n\n### 2. 核心类解析\n\n#### `PurchaseRecordWriter`\n\n- **职责说明**  \n  该类负责管理购买记录的保存、UI 状态控制以及与 Unity 编辑器的导出工具集成。其核心职责包括：\n  - 收集购买记录数据。\n  - 保存为 CSV 文件。\n  - 处理导出过程中的错误和反馈。\n  - 管理 UI 状态（如显示/隐藏提示信息）。\n\n- **关键方法清单**  \n  - `void Start()`：初始化 UI 组件和导出工具。\n  - `void SavePurchaseRecord()`：保存购买记录并处理导出。\n  - `void OnAssetExportFailed(string message)`：处理导出失败事件。\n  - `void OnAssetExportFinished()`：处理导出完成事件。\n  - `void WritePurchaseRecord(List<CardInfo> cardInfos, string filePath)`：写入购买记录到 CSV 文件。\n  - `void AddPathToExportWindow(string path)`：向导出窗口添加资源路径。\n\n- **继承关系**  \n  `PurchaseRecordWriter` -> `MonoBehaviour` -> `Behaviour` -> `UnityEngine.Object`\n\n- **依赖模块**  \n  - `UnityEngine.UI`：用于管理 UI 组件。\n  - `UnityEngine.AssetDatabase`：用于获取资源路径。\n  - `PartyIP.AssetExport`：用于与 Unity 编辑器导出工具集成。\n  - `System.IO`：用于文件操作。\n  - `System.Text`：用于字符串处理。\n\n---\n\n### 3. 关键方法详解\n\n#### `void Start()`\n\n- **方法签名**  \n  `private void Start()`\n\n- **功能描述**  \n  初始化脚本，绑定按钮点击事件，设置初始 UI 状态，并在 Unity 编辑器环境中打开导出窗口。\n\n- **调用关系**  \n  - 被 Unity 引擎调用（MonoBehaviour 生命周期）。\n  - 调用 `SavePurchaseRecord`（通过按钮点击事件）。\n  - 调用 `OpenAssetExportWindow` 和 `AssetExportCallbackRegistery` 的方法。\n\n#### `void SavePurchaseRecord()`\n\n- **方法签名**  \n  `private void SavePurchaseRecord()`\n\n- **功能描述**  \n  收集所有选中的资源卡片信息，检查是否有重复记录，保存为 CSV 文件，并处理导出窗口中的资源路径添加。\n\n- **调用关系**  \n  - 被 `savePurchaseRecordButton` 的点击事件调用。\n  - 调用 `WritePurchaseRecord`、`GetExistingIds`、`HighlightExistingCard`、`ShowPurchaseFailed` 和 `AddPathToExportWindow`。\n\n#### `void WritePurchaseRecord(List<CardInfo> cardInfos, string filePath)`\n\n- **方法签名**  \n  `public static void WritePurchaseRecord(List<CardInfo> cardInfos, string filePath)`\n\n- **功能描述**  \n  将购买记录写入 CSV 文件。确保文件格式正确，并添加批次信息和资源数据行。\n\n- **调用关系**  \n  - 被 `SavePurchaseRecord` 调用。\n  - 调用 `File.ReadAllLines` 和 `File.WriteAllLines",
    "chunk_order_index": 2,
    "full_doc_id": "doc-af2e328d1aba11df0974408e382c7f16"
  },
  "chunk-c076df6e060948df92518444117db63f": {
    "tokens": 410,
    "content": "<CardInfo> cardInfos, string filePath)`\n\n- **方法签名**  \n  `public static void WritePurchaseRecord(List<CardInfo> cardInfos, string filePath)`\n\n- **功能描述**  \n  将购买记录写入 CSV 文件。确保文件格式正确，并添加批次信息和资源数据行。\n\n- **调用关系**  \n  - 被 `SavePurchaseRecord` 调用。\n  - 调用 `File.ReadAllLines` 和 `File.WriteAllLines`。\n\n#### `void AddPathToExportWindow(string path)`\n\n- **方法签名**  \n  `private bool AddPathToExportWindow(string path)`\n\n- **功能描述**  \n  使用反射调用导出窗口的 `AddPath` 方法，将资源路径添加到导出列表中。\n\n- **调用关系**  \n  - 被 `SavePurchaseRecord` 调用。\n  - 调用 `EditorWindow.GetWindow` 和 `Type.GetMethod`。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class PurchaseRecordWriter {\n        +void Start()\n        +void SavePurchaseRecord()\n        +void OnAssetExportFailed(string message)\n        +void OnAssetExportFinished()\n        +void WritePurchaseRecord(List<CardInfo> cardInfos, string filePath)\n        +bool AddPathToExportWindow(string path)\n        +void ShowPathAddFailed(string failedPath)\n        +void HighlightExistingCard(string id)\n        +void ShowPurchaseFailed()\n        +List<string> GetExistingIds(string filePath)\n        +void CopyAllPrefabPathsToClipboard()\n        +IEnumerator HideTitleAfterSeconds(float seconds)\n    }\n\n    PurchaseRecordWriter --> MonoBehaviour : Inheritance\n    PurchaseRecordWriter --> EditorWindow : Dependency\n    PurchaseRecordWriter --> AssetExportCallbackRegistery : Dependency\n    PurchaseRecordWriter --> SelectedCardUI : Dependency\n    PurchaseRecordWriter --> TextMeshProUGUI : Dependency\n    PurchaseRecordWriter --> AssetDatabase : Dependency\n```",
    "chunk_order_index": 3,
    "full_doc_id": "doc-af2e328d1aba11df0974408e382c7f16"
  },
  "chunk-c70a260ab7bac5f7d6ffc5c9c2ea144e": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEditor;\n\nusing UnityEngine;\nusing TMPro;\nusing System.Text;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System;\nusing System.Reflection;\nusing PartyIP.AssetExport;\n\n/// <summary>\n/// 购买记录里的更新逻辑，完成二次导出用的。放在了购物记录的导出按钮上\n/// </summary>\npublic class PurchaseRecordUpdater : MonoBehaviour\n{\n    public Button savePurchaseRecordButton; // 插槽：用于保存购买记录的按钮\n    public Transform contentParent; // 插槽：用于获取Content Parent中的资源卡\n    public GameObject title; // 插槽：用于显示标题\n    public ResourceManager resourceManager; // 插槽：用于获取ResourceManager实例\n\n    private const string CsvHeader = \"资源ID,资源名称,资源描述,物品高度,预制体路径,缩略图路径,面数,创建时间,更新时间,版本,类型标签,主题标签,功能标签,区域标签,批次标签,属性标签\";\n    private EditorWindow m_ExportWindow = null;\n    private Type m_ExportWindowType = null;\n    public GameObject pathAddFailedUI; // 插槽：用于显示路径添加失败消息的UI\n\n    private void Start()\n    {\n        if (savePurchaseRecordButton != null)\n        {\n            savePurchaseRecordButton.onClick.AddListener(UpdatePurchaseRecord);\n        }\n\n        if (title != null)\n        {\n            title.SetActive(false); // 确保初始状态是隐藏的\n        }\n\n        // 初始化时打开AssetExportWindow（仅在编辑器中）\n#if UNITY_EDITOR\n        OpenAssetExportWindow();\n#endif\n    }\n\n#if UNITY_EDITOR\n    private void OpenAssetExportWindow()\n    {\n        EditorApplication.delayCall += () =>\n        {\n            m_ExportWindow = EditorWindow.GetWindow(GetExportWindowType());\n        };\n    }\n\n    private Type GetExportWindowType()\n    {\n        if (m_ExportWindowType != null)\n        {\n            return m_ExportWindowType;\n        }\n\n        Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();\n        Assembly target = null;\n        foreach (var assembly in assemblies)\n        {\n            string name = assembly.FullName.ToLower().Replace(\"-\", \"\").Replace(\".\", \"\");\n            if (name.Contains(\"assetexport\"))\n            {\n                target = assembly;\n                break;\n            }\n        }\n\n        if (target != null)\n        {\n            m_ExportWindowType = target.GetType(\"PartyIP.AssetExport.AssetExportWindow\");\n        }\n\n        return m_ExportWindowType;\n    }\n\n    private bool AddPathToExportWindow(string path)\n    {\n        if (m_ExportWindow == null)\n        {\n            Debug.LogError(\"导出窗口没打开\");\n            return false;\n        }\n\n        var IAddPathFunc = m_ExportWindowType.GetMethod(\"AddPath\");\n        try\n        {\n            string error = (string)IAddPathFunc.Invoke((object)m_ExportWindow, new object[] { path, true, true });\n            if (string.IsNullOrEmpty(error))\n            {\n                Debug.Log(\"路径添加成功\");\n                return true;\n            }\n            else\n            {\n                Debug.LogError($\"路径添加失败: {error}\");\n                ShowPathAddFailed(path); // 显示路径添加失败消息的UI\n                return false;\n            }\n        }\n        catch (Exception e)\n        {\n            Debug.LogError($\"报错: {e.InnerException.Message}\");\n            ShowPathAddFailed(path); // 显示路径添加失败消息的UI\n            return false;\n        }\n    }\n#endif\n\n    private void UpdatePurchaseRecord()\n    {\n        List<CardInfo> cardInfos = new List<CardInfo>();\n\n        foreach (Transform child in contentParent)\n        {\n            SelectedCardUI cardUI = child.GetComponent<SelectedCardUI>();\n            if (cardUI != null)\n            {\n                // 获取资源信息\n                ResourceCardData resourceData = resourceManager.GetResourceById(cardUI.idText.text);\n                if (resourceData != null)\n                {\n                    CardInfo card = new CardInfo(\n                        resourceData.ID,\n                        resourceData.Name,\n                        resourceData.Description,\n                        resourceData.Height,\n                        resourceData.PrefabPath,\n                        resourceData.ThumbnailPath,\n                        resourceData.ModelFaces,\n                        resourceData.CreationDate,\n                        resourceData.UpdatedDate,\n                        resourceData.Version,\n                        string.Join(\";\", resourceData.TypeTags),\n                        string.Join(\";\", resourceData.ThemeTags),\n                        string.Join(\";\", resourceData.FunctionTags),\n                        string.Join(\";\", resourceData.DefinitionTags),\n                        string.Join(\";\", resourceData.BatchTags),\n                        string.Join(\";\", resourceData.PropertyTags)\n                    );\n                    cardInfos.Add(card);\n                }\n            }\n        }\n\n        string userKey = PlayerPrefs.GetString(\"currentUserKey\", string.Empty);\n        if (!string.IsNullOrEmpty(userKey))\n        {\n            string folderPath = Path.Combine(Application.dataPath, \"ZTResource/UserInfo\");\n            string fileName = userKey + \".csv\";\n            string filePath = Path.Combine(folderPath, fileName);\n\n            UpdatePurchaseRecordFile(cardInfos, filePath);\n\n            if (title != null)\n            {\n                title.SetActive(true); // 显示标题\n                StartCoroutine(HideTitleAfterSeconds(3)); // 3秒后隐藏标题\n            }\n\n            // 强制刷新Unity的资源数据库（仅在编辑器中）\n#if UNITY_EDITOR\n            UnityEditor.AssetDatabase.Refresh();\n#endif\n\n            // 购买成功，调用CustomEventSystem.RaiseAddPrefabPath（仅在编辑器中）\n#if UNITY_EDITOR\n            foreach (var card in cardInfos)\n            {\n                if (!AddPathToExport",
    "chunk_order_index": 0,
    "full_doc_id": "doc-ef52fe3156a620bfd271275996374900"
  },
  "chunk-44765d2e7bd891a8bd598af77c20cd3e": {
    "tokens": 1200,
    "content": "// 显示标题\n                StartCoroutine(HideTitleAfterSeconds(3)); // 3秒后隐藏标题\n            }\n\n            // 强制刷新Unity的资源数据库（仅在编辑器中）\n#if UNITY_EDITOR\n            UnityEditor.AssetDatabase.Refresh();\n#endif\n\n            // 购买成功，调用CustomEventSystem.RaiseAddPrefabPath（仅在编辑器中）\n#if UNITY_EDITOR\n            foreach (var card in cardInfos)\n            {\n                if (!AddPathToExportWindow(card.PrefabPath))\n                {\n                    ShowPathAddFailed(card.PrefabPath); // 显示路径添加失败消息的UI\n                    return;\n                }\n            }\n#endif\n\n            CopyAllPrefabPathsToClipboard(); // 复制路径到剪贴板\n        }\n    }\n\n    private void UpdatePurchaseRecordFile(List<CardInfo> cardInfos, string filePath)\n    {\n        if (cardInfos == null || cardInfos.Count == 0) return;\n\n        List<string> lines = new List<string>(File.ReadAllLines(filePath, Encoding.UTF8));\n        Dictionary<string, string> updatedRecords = new Dictionary<string, string>();\n\n        foreach (var card in cardInfos)\n        {\n            string line = $\"{card.ID},{card.Name},{card.Description},{card.Height},{card.PrefabPath},{card.ThumbnailPath},{card.ModelFaces},{card.CreationDate},{card.UpdatedDate},{card.Version},{card.TypeTags},{card.ThemeTags},{card.FunctionTags},{card.DefinitionTags},{card.BatchTags},{card.PropertyTags}\";\n            updatedRecords[card.ID] = line;\n        }\n\n        for (int i = 3; i < lines.Count; i++) // 从第四行开始读取数据\n        {\n            string[] values = lines[i].Split(',');\n            if (values.Length > 0 && updatedRecords.ContainsKey(values[0]))\n            {\n                lines[i] = updatedRecords[values[0]];\n                updatedRecords.Remove(values[0]);\n            }\n        }\n\n        // 添加新的记录\n        foreach (var record in updatedRecords.Values)\n        {\n            lines.Add(record);\n        }\n\n        File.WriteAllLines(filePath, lines, Encoding.UTF8);\n    }\n\n    private void CopyAllPrefabPathsToClipboard()\n    {\n        StringBuilder paths = new StringBuilder();\n        foreach (Transform child in contentParent)\n        {\n            SelectedCardUI cardUI = child.GetComponent<SelectedCardUI>();\n            if (cardUI != null && cardUI.prefabPathText != null)\n            {\n                TextMeshProUGUI tmpText = cardUI.prefabPathText.GetComponent<TextMeshProUGUI>();\n                if (tmpText != null)\n                {\n                    paths.AppendLine(tmpText.text);\n                }\n            }\n        }\n        GUIUtility.systemCopyBuffer = paths.ToString();\n    }\n\n    IEnumerator HideTitleAfterSeconds(float seconds)\n    {\n        yield return new WaitForSeconds(seconds);\n        if (title != null)\n        {\n            title.SetActive(false);\n        }\n    }\n\n    private void ShowPathAddFailed(string failedPath)\n    {\n        foreach (Transform child in contentParent)\n        {\n            SelectedCardUI cardUI = child.GetComponent<SelectedCardUI>();\n            if (cardUI != null && cardUI.prefabPathText.text == failedPath)\n            {\n                cardUI.SetPathErrorUIVisibility(true); // 显示路径错误UI\n            }\n        }\n\n        if (pathAddFailedUI != null)\n        {\n            pathAddFailedUI.SetActive(true); // 显示路径添加失败消息的UI\n        }\n    }\n}\n#endif\n源代码内容解释如下：\n```markdown\n# 代码文件分析报告\n\n## 1. 功能概览\n\n### 功能定位\n该代码文件定义了一个名为 `PurchaseRecordUpdater` 的类，主要用于处理购买记录的更新逻辑。它通过按钮点击事件触发更新操作，收集并存储资源信息到 CSV 文件中，并与 Unity 编辑器中的资产导出窗口进行交互。\n\n### 系统角色\n`PurchaseRecordUpdater` 在系统中主要承担以下角色：\n- **数据收集与存储**：收集资源信息并存储到 CSV 文件，便于后续处理。\n- **编辑器扩展**：与 Unity 编辑器的资产导出功能集成，自动添加资源路径到导出窗口。\n- **用户反馈**：通过 UI 提供操作反馈，如显示成功或失败消息。\n\n### 主要特性与技术实现\n- **CSV 文件操作**：读写 CSV 文件以存储和更新购买记录。\n- **反射机制**：通过反射访问和调用 `AssetExportWindow` 的方法。\n- **UI 交互**：控制按钮点击事件、标题显示和错误提示 UI 的显示。\n- **资源管理**：通过 `ResourceManager` 获取资源数据，并处理资源路径的复制和导出。\n\n## 2. 核心类解析\n\n### 类名称：`PurchaseRecordUpdater`\n\n#### 职责说明\n`PurchaseRecordUpdater` 的主要职责包括：\n- 处理购买记录的更新逻辑。\n- 管理与资产导出窗口的交互。\n- 提供用户操作反馈。\n\n#### 关键方法清单\n- `void Start()`：初始化按钮点击事件和导出窗口。\n- `void UpdatePurchaseRecord()`：收集资源信息并更新购买记录。\n- `void UpdatePurchaseRecordFile(List<CardInfo> cardInfos, string filePath)`：更新 CSV 文件。\n- `void CopyAllPrefabPathsToClipboard()`：复制资源路径到剪贴板。\n- `void ShowPathAddFailed(string failedPath)`：显示路径添加失败的提示。\n\n#### 继承关系\n```\nPurchaseRecordUpdater -> MonoBehaviour\n```\n\n#### 依赖模块",
    "chunk_order_index": 1,
    "full_doc_id": "doc-ef52fe3156a620bfd271275996374900"
  },
  "chunk-03cfbac4c7160737f26a9598189e0bad": {
    "tokens": 1200,
    "content": "`void UpdatePurchaseRecord()`：收集资源信息并更新购买记录。\n- `void UpdatePurchaseRecordFile(List<CardInfo> cardInfos, string filePath)`：更新 CSV 文件。\n- `void CopyAllPrefabPathsToClipboard()`：复制资源路径到剪贴板。\n- `void ShowPathAddFailed(string failedPath)`：显示路径添加失败的提示。\n\n#### 继承关系\n```\nPurchaseRecordUpdater -> MonoBehaviour\n```\n\n#### 依赖模块\n- `UnityEngine.UI.Button`\n- `UnityEngine.Transform`\n- `UnityEngine.GameObject`\n- `PartyIP.AssetExport.ResourceManager`\n- `PartyIP.AssetExport.AssetExportWindow`（通过反射访问）\n\n## 3. 关键方法详解\n\n### 方法：`void Start()`\n\n#### 方法签名\n```csharp\nprivate void Start()\n```\n\n#### 功能描述\n初始化按钮点击事件，设置标题初始状态为隐藏，并在 Unity 编辑器环境中打开资产导出窗口。\n\n#### 算法说明\n- 检查按钮是否有效，若有效则添加点击事件监听器。\n- 检查标题是否有效，若有效则设置为隐藏。\n- 在 Unity 编辑器环境中调用 `OpenAssetExportWindow()` 方法打开导出窗口。\n\n#### 调用关系\n- 由 Unity 引擎在脚本实例化时自动调用。\n- 调用 `UpdatePurchaseRecord()` 方法处理点击事件。\n\n### 方法：`void UpdatePurchaseRecord()`\n\n#### 方法签名\n```csharp\nprivate void UpdatePurchaseRecord()\n```\n\n#### 功能描述\n收集当前显示的资源信息，更新购买记录 CSV 文件，并与资产导出窗口交互。\n\n#### 算法说明\n1. 遍历 `contentParent` 下的所有子节点，获取每个资源的 `SelectedCardUI` 组件。\n2. 使用 `ResourceManager` 获取资源数据，并构建 `CardInfo` 对象。\n3. 将所有 `CardInfo` 对象传递给 `UpdatePurchaseRecordFile` 方法，更新 CSV 文件。\n4. 显示标题 3 秒后隐藏。\n5. 在 Unity 编辑器环境中，尝试将每个资源的Prefab路径添加到导出窗口。\n6. 复制所有Prefab路径到剪贴板。\n\n#### 调用关系\n- 由 `savePurchaseRecordButton` 的点击事件调用。\n- 调用 `UpdatePurchaseRecordFile()`、`HideTitleAfterSeconds()` 和 `AddPathToExportWindow()` 方法。\n\n### 方法：`void UpdatePurchaseRecordFile(List<CardInfo> cardInfos, string filePath)`\n\n#### 方法签名\n```csharp\nprivate void UpdatePurchaseRecordFile(List<CardInfo> cardInfos, string filePath)\n```\n\n#### 功能描述\n更新指定路径的 CSV 文件，将新的资源记录与现有记录进行合并。\n\n#### 算法说明\n1. 读取现有 CSV 文件内容到 `lines` 列表中。\n2. 遍历 `cardInfos`，构建新的资源记录并存储在 `updatedRecords` 字典中。\n3. 从第四行开始，逐行检查现有记录，若存在对应资源ID则更新记录。\n4. 将未更新的记录添加到文件末尾。\n5. 将更新后的内容写回 CSV 文件。\n\n#### 调用关系\n- 由 `UpdatePurchaseRecord()` 方法调用。\n\n### 方法：`void CopyAllPrefabPathsToClipboard()`\n\n#### 方法签名\n```csharp\nprivate void CopyAllPrefabPathsToClipboard()\n```\n\n#### 功能描述\n复制所有资源的Prefab路径到剪贴板，便于后续粘贴使用。\n\n#### 算法说明\n1. 遍历 `contentParent` 下的所有子节点，获取每个资源的 `SelectedCardUI` 组件。\n2. 提取 `prefabPathText` 的文本内容，构建多行字符串。\n3. 使用 `GUIUtility.systemCopyBuffer` 将字符串复制到剪贴板。\n\n#### 调用关系\n- 由 `UpdatePurchaseRecord()` 方法调用。\n\n### 方法：`void ShowPathAddFailed(string failedPath)`\n\n#### 方法签名\n```csharp\nprivate void ShowPathAddFailed(string failedPath)\n```\n\n#### 功能描述\n显示指定路径添加失败的提示信息。\n\n#### 算法说明\n1. 遍历 `contentParent` 下的所有子节点，查找对应 `failedPath` 的 `SelectedCardUI` 组件。\n2. 显示该资源的路径错误 UI。\n3. 显示全局的路径添加失败提示 UI。\n\n#### 调用关系\n- 由 `AddPathToExportWindow()` 方法在路径添加失败时调用。\n\n## 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class PurchaseRecordUpdater {\n        +Button savePurchaseRecordButton\n        +Transform contentParent\n        +GameObject title\n        +ResourceManager resourceManager\n        +GameObject pathAddFailedUI\n        +void Start()\n        +void UpdatePurchaseRecord()\n        +void UpdatePurchaseRecordFile(List<CardInfo> cardInfos, string filePath)\n        +void CopyAllPrefabPathsToClipboard()\n        +void ShowPathAddFailed(string failedPath)\n        +IEnumerator HideTitleAfterSeconds(float seconds)\n    }\n\n    class MonoBehaviour {\n        +void Start()\n        +void Update()\n    }\n\n    class Button {\n        +Button.onClick\n    }\n\n    class Transform {}\n\n    class GameObject {}\n\n    class ResourceManager {\n        +ResourceData GetResourceById(string id)\n    }\n\n    class AssetExportWindow {\n        +void AddPath(string path, bool includeChildren, bool recursive)\n    }\n\n    PurchaseRecordUpdater --> Mono",
    "chunk_order_index": 2,
    "full_doc_id": "doc-ef52fe3156a620bfd271275996374900"
  },
  "chunk-ecb4e8128b7b99b0ca05ec6eb7437938": {
    "tokens": 229,
    "content": "failedPath)\n        +IEnumerator HideTitleAfterSeconds(float seconds)\n    }\n\n    class MonoBehaviour {\n        +void Start()\n        +void Update()\n    }\n\n    class Button {\n        +Button.onClick\n    }\n\n    class Transform {}\n\n    class GameObject {}\n\n    class ResourceManager {\n        +ResourceData GetResourceById(string id)\n    }\n\n    class AssetExportWindow {\n        +void AddPath(string path, bool includeChildren, bool recursive)\n    }\n\n    PurchaseRecordUpdater --> MonoBehaviour : inherits from\n    PurchaseRecordUpdater --> Button : uses\n    PurchaseRecordUpdater --> Transform : uses\n    PurchaseRecordUpdater --> GameObject : uses\n    PurchaseRecordUpdater --> ResourceManager : uses\n    PurchaseRecordUpdater --> AssetExportWindow : uses via reflection\n```\n\n## 5. 总结\n\n`PurchaseRecordUpdater` 类通过与 Unity 编辑器的交互，实现了购买记录的更新、CSV 文件的管理以及用户反馈功能。其核心在于反射机制的使用和对资源数据的高效处理，确保了与现有资产导出系统的无缝集成。",
    "chunk_order_index": 3,
    "full_doc_id": "doc-ef52fe3156a620bfd271275996374900"
  },
  "chunk-219913cdb4ddaf9af91d33b0f197c94d": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.IO;\n\npublic class UserInfoUI : MonoBehaviour\n{\n    public Image userAvatarImage;\n    public TextMeshProUGUI userNameText;\n\n    public void SetupUserInfo(string userName, string userAvatarFileName)\n    {\n        userNameText.text = userName;\n\n        // Ê¹ÓÃResources.Load´Ó×ÊÔ´ÎÄ¼þ¼ÐÖÐ¼ÓÔØÍ¼Ïñ\n        string avatarResourcePath = \"ZT_Sprites/ZT_User_Icon/\" + Path.GetFileNameWithoutExtension(userAvatarFileName);\n        userAvatarImage.sprite = Resources.Load<Sprite>(avatarResourcePath);\n\n        if (userAvatarImage.sprite == null)\n        {\n            Debug.LogError(\"Failed to load avatar sprite from Resources at path: \" + avatarResourcePath);\n        }\n    }\n\n#if UNITY_EDITOR\n    private Sprite LoadSpriteFromFile(string filePath)\n    {\n        if (!System.IO.File.Exists(filePath))\n        {\n            Debug.LogError(\"File not found at path: \" + filePath);\n            return null;\n        }\n\n        byte[] fileData = System.IO.File.ReadAllBytes(filePath);\n        Texture2D tex = new Texture2D(2, 2);\n        if (tex.LoadImage(fileData))\n        {\n            return Sprite.Create(tex, new Rect(0, 0, tex.width, tex.height), new Vector2(0.5f, 0.5f));\n        }\n        else\n        {\n            Debug.LogError(\"Failed to load texture from file: \" + filePath);\n            return null;\n        }\n    }\n#endif\n}\n\n源代码内容解释如下：\n### 功能概览\n\n#### 功能定位\n该代码文件`UserInfoUI.cs`是一个Unity脚本，用于在用户界面上显示用户信息，包括用户名和用户头像。它通过绑定UI元素（如`Image`和`TextMeshProUGUI`）来实现用户信息的展示。\n\n#### 系统角色\n该脚本属于用户界面（UI）模块，负责将用户数据（如用户名和头像）呈现给用户。在项目中，它是一个重要的展示层组件，用于增强用户体验。\n\n#### 主要特性与技术实现\n- **用户信息展示**：通过绑定UI元素展示用户名和用户头像。\n- **资源加载**：使用`Resources.Load`从`Resources`文件夹加载头像Sprite。\n- **开发环境支持**：在Unity编辑器环境下，支持从文件系统加载头像文件并转换为Sprite（通过`LoadSpriteFromFile`方法实现）。\n\n### 核心类解析\n\n#### `UserInfoUI` 类\n- **职责说明**\n  - 管理用户信息的显示，包括用户名和用户头像。\n  - 提供从`Resources`文件夹加载用户头像的功能。\n  - 在Unity编辑器环境下，提供从文件系统加载头像文件的功能。\n\n- **关键方法清单**\n  - `public void SetupUserInfo(string userName, string userAvatarFileName)`\n  - `private Sprite LoadSpriteFromFile(string filePath)`（仅在Unity编辑器环境下有效）\n\n- **继承关系**\n  ```\n UserInfoUI -> MonoBehaviour -> Component -> Object\n  ```\n\n- **依赖模块**\n  - `UnityEngine.UI.Image`\n  - `TextMeshProUGUI`\n  - `UnityEngine.Resources`\n\n### 关键方法详解\n\n#### `public void SetupUserInfo(string userName, string userAvatarFileName)`\n- **方法签名**\n  ```csharp\n  public void SetupUserInfo(string userName, string userAvatarFileName)\n  ```\n\n- **功能描述**\n  - 设置用户信息，包括用户名和用户头像。\n  - 从`Resources`文件夹加载用户头像Sprite，并验证加载是否成功。\n\n- **算法说明**\n  - 从`Resources`文件夹加载头像Sprite，路径基于`userAvatarFileName`生成。\n  - 如果加载失败，记录错误信息。\n\n- **调用关系**\n  - 通常由其他组件（如用户管理系统）调用，用于更新用户界面。\n  - 在开发环境中，可能由测试脚本调用来测试不同头像。\n\n#### `private Sprite LoadSpriteFromFile(string filePath)`\n- **方法签名**\n  ```csharp\n  private Sprite LoadSpriteFromFile(string filePath)\n  ```\n\n- **功能描述**\n  - 从指定文件路径加载图片文件，并将其转换为Sprite。\n  - 仅在Unity编辑器环境下有效。\n\n- **算法说明**\n  - 读取文件内容并转换为`Texture2D`。\n  - 使用`Texture2D`创建Sprite对象。\n\n- **调用关系**\n  - 仅在`SetupUserInfo`中调用，用于从文件系统加载头像。\n  - 仅在Unity编辑器环境下有效。\n\n### 架构关系图\n\n```mermaid\nclassDiagram\n    class MonoBehaviour {\n        +string name\n    }\n    class Component {\n        +Transform transform\n    }\n    class Object {\n        +intGetInstanceID()\n    }\n    class Image {\n        +Sprite sprite\n    }\n    class TextMeshProUGUI {\n        +string text\n    }\n    class Sprite {\n        +Texture2D texture\n    }\n    class Texture2D {\n        +int width\n        +int height\n    }\n    class UserInfoUI {\n        +Image userAvatarImage\n        +TextMeshProUGUI userNameText\n        +void SetupUserInfo(string userName, string userAvatarFileName)\n        +Sprite LoadSpriteFromFile(string filePath) #if UNITY_EDITOR\n    }\n    Object <",
    "chunk_order_index": 0,
    "full_doc_id": "doc-5554ff86d68294c6d4977f313f765117"
  },
  "chunk-f004447e39ee8a4315a5f322f56ea528": {
    "tokens": 151,
    "content": "{\n        +string text\n    }\n    class Sprite {\n        +Texture2D texture\n    }\n    class Texture2D {\n        +int width\n        +int height\n    }\n    class UserInfoUI {\n        +Image userAvatarImage\n        +TextMeshProUGUI userNameText\n        +void SetupUserInfo(string userName, string userAvatarFileName)\n        +Sprite LoadSpriteFromFile(string filePath) #if UNITY_EDITOR\n    }\n    Object <|-- Component\n    Component <|-- MonoBehaviour\n    MonoBehaviour <|--UserInfoUI\n    UserInfoUI *-- Image : userAvatarImage\n    UserInfoUI *-- TextMeshProUGUI : userNameText\n```",
    "chunk_order_index": 1,
    "full_doc_id": "doc-5554ff86d68294c6d4977f313f765117"
  },
  "chunk-80f2d1e97cfeb24e00611fe97dba73de": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing UnityEngine.SceneManagement;\nusing System.IO;\nusing System.Collections.Generic;\n\npublic class SceneController : MonoBehaviour\n{\n    public GameObject searchPanel; // 插槽：搜索页面\n    public GameObject purchaseRecordPanel; // 插槽：购买记录页面\n    public Image userAvatar; // 插槽：用户头像\n    public TMP_Text userName; // 插槽：用户名称\n    public Button searchPageButton; // 插槽：搜索页面按钮\n    public Button returnToHomePageButton; // 插槽：退回首页按钮\n    public Button enterPurchaseRecordButton; // 插槽：进入购买记录页面按钮\n\n    private string currentUserFilePath;\n\n    private void Start()\n    {\n        LoadUserInfo();\n        ShowSearchPanel();\n\n        searchPageButton.onClick.AddListener(ShowSearchPanel);\n        returnToHomePageButton.onClick.AddListener(ReturnToHomePage);\n        enterPurchaseRecordButton.onClick.AddListener(ShowPurchaseRecordPanel);\n    }\n    // 这个脚本的目的是加载用户信息，包括用户名和用户头像\n    private void LoadUserInfo()\n    {\n        string userKey = PlayerPrefs.GetString(\"currentUserKey\", string.Empty);\n        if (!string.IsNullOrEmpty(userKey))\n        {\n            string folderPath = Path.Combine(Application.dataPath, \"ZTResource/UserInfo\");\n            string fileName = userKey + \".csv\";\n            currentUserFilePath = Path.Combine(folderPath, fileName);\n\n            if (File.Exists(currentUserFilePath))\n            {\n                string[] lines = File.ReadAllLines(currentUserFilePath);\n                if (lines.Length > 1)\n                {\n                    string[] data = lines[1].Split(',');\n                    string username = data[0];\n                    string avatarName = Path.GetFileNameWithoutExtension(data[1]);\n\n                    userName.text = username;\n                    string avatarPath = Path.Combine(Application.dataPath, \"ZTResource/Resources/ZT_Sprites/ZT_User_Icon\", avatarName + \".png\");\n                    if (File.Exists(avatarPath))\n                    {\n                        byte[] fileData = File.ReadAllBytes(avatarPath);\n                        Texture2D texture = new Texture2D(2, 2);\n                        texture.LoadImage(fileData);\n                        Sprite avatarSprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f));\n                        userAvatar.sprite = avatarSprite;\n                    }\n                    else\n                    {\n                        Debug.LogError(\"Avatar sprite not found at path: \" + avatarPath);\n                    }\n                }\n                else\n                {\n                    Debug.LogError(\"CSV file format is incorrect or empty.\");\n                }\n            }\n            else\n            {\n                Debug.LogError(\"User CSV file not found: \" + currentUserFilePath);\n            }\n        }\n    }\n\n\n    private void ShowSearchPanel()\n    {\n        searchPanel.SetActive(true);\n        purchaseRecordPanel.SetActive(false);\n    }\n\n    private void ShowPurchaseRecordPanel()\n    {\n        LoadPurchaseRecords(); // 新增方法调用\n        searchPanel.SetActive(false);\n        purchaseRecordPanel.SetActive(true);\n    }\n\n    private void LoadPurchaseRecords()\n    {\n        var (userName, userAvatar, batches) = CSVParser.ParseCSV(currentUserFilePath);\n\n        // 更新UI逻辑\n        // 例如，假设有一个 `MainUIController` 来管理购买记录的UI\n        MainUIController mainUIController = purchaseRecordPanel.GetComponent<MainUIController>();\n        if (mainUIController != null)\n        {\n            mainUIController.SetupPurchaseRecords(userName, userAvatar, batches, currentUserFilePath); // 传递CSV文件路径\n        }\n    }\n\n    private void ReturnToHomePage()\n    {\n        SceneManager.LoadScene(\"Assets/ZTResource/ZTResource_Home.unity\");\n    }\n}\n\n源代码内容解释如下：\n### 1. 功能概览\n\n**功能定位：**  \n`SceneController` 类主要用于管理场景中的用户界面（UI）交互和用户信息的加载与显示。它负责控制不同面板（如搜索页面、购买记录页面）的显示状态，并处理用户头像和名称的加载。\n\n**在系统中的角色和重要性：**  \n该类是用户界面管理的核心组件，负责协调用户信息的展示和场景切换。它是用户与系统交互的主要入口，确保用户能够顺利访问不同功能模块。\n\n**主要特性与技术实现方案：**  \n- **用户信息加载：** 通过读取CSV文件加载用户名和头像。\n- **UI面板控制：** 使用 `SetActive` 方法管理面板的显示状态。\n- **场景切换：** 使用 `SceneManager.LoadScene` 实现场景跳转。\n- **文件操作：** 利用 `File` 类和 `PlayerPrefs` 进行文件读取和用户数据存储。\n- **图像处理：** 将文件中的图像数据转换为 `Sprite` 用于UI显示。\n\n---\n\n### 2. 核心类解析\n\n#### `SceneController`\n\n**职责说明：**  \n`SceneController` 的主要职责是管理场景中的UI交互和用户信息的加载与显示。它协调不同面板的显示状态，并处理用户头像和名称的加载。\n\n**关键方法清单：**  \n- `private void Start()`: 初始化脚本，加载用户信息并设置初始面板。\n- `private void LoadUserInfo()`: 加载并显示用户信息（用户名和头像）。\n- `private void ShowSearchPanel()`: 显示搜索页面并隐藏购买记录页面。\n- `private void",
    "chunk_order_index": 0,
    "full_doc_id": "doc-7caa28cf649b766b85bafc6f42c90d2b"
  },
  "chunk-b01ccac2445b7bc581e99f84ca2c43d2": {
    "tokens": 1200,
    "content": "交互和用户信息的加载与显示。它协调不同面板的显示状态，并处理用户头像和名称的加载。\n\n**关键方法清单：**  \n- `private void Start()`: 初始化脚本，加载用户信息并设置初始面板。\n- `private void LoadUserInfo()`: 加载并显示用户信息（用户名和头像）。\n- `private void ShowSearchPanel()`: 显示搜索页面并隐藏购买记录页面。\n- `private void ShowPurchaseRecordPanel()`: 显示购买记录页面并隐藏搜索页面。\n- `private void LoadPurchaseRecords()`: 加载购买记录数据并更新UI。\n- `private void ReturnToHomePage()`: 切换回首页场景。\n\n**继承关系：**  \n```\nSceneController -> MonoBehaviour\n```\n\n**依赖模块：**  \n- `UnityEngine`、`UnityEngine.UI`、`TextMeshPro`、`UnityEngine.SceneManagement`、`System.IO`：Unity内置模块。\n- `CSVParser`：用于解析CSV文件的类。\n- `MainUIController`：用于管理购买记录UI的类。\n\n---\n\n### 3. 关键方法详解\n\n#### `private void Start()`\n\n**方法签名：**  \n```csharp\nprivate void Start()\n```\n\n**功能描述：**  \n在场景加载时初始化脚本，执行以下操作：  \n1. 加载用户信息（用户名和头像）。  \n2. 显示搜索页面。  \n3. 为按钮添加点击事件监听器，分别绑定到 `ShowSearchPanel`、`ReturnToHomePage` 和 `ShowPurchaseRecordPanel` 方法。\n\n**算法说明：**  \n该方法通过调用其他方法完成初始化，逻辑简单但功能集中。\n\n**调用关系：**  \n- 被Unity引擎自动调用（生命周期方法）。\n\n---\n\n#### `private void LoadUserInfo()`\n\n**方法签名：**  \n```csharp\nprivate void LoadUserInfo()\n```\n\n**功能描述：**  \n从本地存储中读取用户信息并显示在UI上。具体步骤如下：  \n1. 从 `PlayerPrefs` 中获取当前用户的标识符（`userKey`）。  \n2. 根据 `userKey` 构建用户信息文件路径。  \n3. 读取CSV文件中的用户名和头像名称。  \n4. 加载并显示用户名和头像。\n\n**算法说明：**  \n- 使用 `File.ReadAllLines` 读取CSV文件内容。  \n- 解析第二行数据（假设CSV文件格式为 `用户名,头像文件名`）。  \n- 将头像文件路径转换为 `Sprite` 对象，并将其赋值给 `userAvatar`。\n\n**调用关系：**  \n- 被 `Start()` 方法调用。\n\n---\n\n#### `private void ShowSearchPanel()`\n\n**方法签名：**  \n```csharp\nprivate void ShowSearchPanel()\n```\n\n**功能描述：**  \n显示搜索页面并隐藏购买记录页面。  \n- `searchPanel.SetActive(true)`：显示搜索页面。  \n- `purchaseRecordPanel.SetActive(false)`：隐藏购买记录页面。\n\n**算法说明：**  \n简单地通过 `SetActive` 方法控制面板的显示状态。\n\n**调用关系：**  \n- 被 `Start()` 方法调用。  \n- 被 `searchPageButton` 按钮的点击事件调用。\n\n---\n\n#### `private void ShowPurchaseRecordPanel()`\n\n**方法签名：**  \n```csharp\nprivate void ShowPurchaseRecordPanel()\n```\n\n**功能描述：**  \n显示购买记录页面并隐藏搜索页面。  \n- `LoadPurchaseRecords()`：加载购买记录数据。  \n- `searchPanel.SetActive(false)`：隐藏搜索页面。  \n- `purchaseRecordPanel.SetActive(true)`：显示购买记录页面。\n\n**算法说明：**  \n调用 `LoadPurchaseRecords()` 方法加载并解析购买记录数据，然后切换面板显示状态。\n\n**调用关系：**  \n- 被 `enterPurchaseRecordButton` 按钮的点击事件调用。\n\n---\n\n#### `private void LoadPurchaseRecords()`\n\n**方法签名：**  \n```csharp\nprivate void LoadPurchaseRecords()\n```\n\n**功能描述：**  \n加载并解析用户的购买记录数据，更新UI显示。  \n- 调用 `CSVParser.ParseCSV` 方法解析CSV文件。  \n- 将解析结果传递给 `MainUIController` 以更新UI。\n\n**算法说明：**  \n假设 `CSVParser.ParseCSV` 方法返回一个包含用户名、用户头像和购买记录批次的数据结构。数据被传递给 `MainUIController` 以更新购买记录页面的UI。\n\n**调用关系：**  \n- 被 `ShowPurchaseRecordPanel()` 方法调用。\n\n---\n\n#### `private void ReturnToHomePage()`\n\n**方法签名：**  \n```csharp\nprivate void ReturnToHomePage()\n```\n\n**功能描述：**  \n加载首页场景。  \n- 使用 `SceneManager.LoadScene` 方法加载指定场景。\n\n**算法说明：**  \n直接调用Unity的场景管理功能，实现场景跳转。\n\n**调用关系：**  \n- 被 `returnToHomePageButton` 按钮的点击事件调用。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class SceneController {\n        +void Start()\n        +void LoadUserInfo()\n        +void ShowSearchPanel()\n        +void ShowPurchaseRecordPanel()\n        +void LoadPurchaseRecords()\n        +void ReturnToHomePage()\n        +GameObject searchPanel\n        +GameObject purchaseRecordPanel\n        +Image userAvatar\n        +TMP_Text userName\n        +Button searchPageButton\n        +Button",
    "chunk_order_index": 1,
    "full_doc_id": "doc-7caa28cf649b766b85bafc6f42c90d2b"
  },
  "chunk-fe7b12e070cb0f178168c9ca1a6fd0bd": {
    "tokens": 206,
    "content": "4. 架构关系图\n\n```mermaid\nclassDiagram\n\n    class SceneController {\n        +void Start()\n        +void LoadUserInfo()\n        +void ShowSearchPanel()\n        +void ShowPurchaseRecordPanel()\n        +void LoadPurchaseRecords()\n        +void ReturnToHomePage()\n        +GameObject searchPanel\n        +GameObject purchaseRecordPanel\n        +Image userAvatar\n        +TMP_Text userName\n        +Button searchPageButton\n        +Button returnToHomePageButton\n        +Button enterPurchaseRecordButton\n        +string currentUserFilePath\n    }\n\n    class MonoBehaviour {\n        // 基类，包含生命周期方法\n    }\n\n    class MainUIController {\n        +void SetupPurchaseRecords(string, string, object, string)\n    }\n\n    class CSVParser {\n        +static (string, string, object) ParseCSV(string)\n    }\n\n    SceneController --> MonoBehaviour\n    SceneController --> MainUIController\n    SceneController --> CSVParser\n```",
    "chunk_order_index": 2,
    "full_doc_id": "doc-7caa28cf649b766b85bafc6f42c90d2b"
  },
  "chunk-e993b4a691ddc1a2373894d7c46dd526": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class UserAvatarSelector : MonoBehaviour\n{\n    public Button openAvatarSelectionButton; // 用于打开选择页面的按钮\n    public GameObject avatarSelectionPanel;  // 选择页面的面板\n    public Button[] avatarButtons;           // 选择页面上的头像按钮\n    public Image selectedAvatarDisplay;      // 用于显示选择的头像\n\n    private void Start()\n    {\n        // 隐藏选择页面\n        avatarSelectionPanel.SetActive(false);\n\n        // 添加按钮点击事件\n        openAvatarSelectionButton.onClick.AddListener(OpenAvatarSelection);\n\n        // 为每个头像按钮添加点击事件\n        foreach (Button button in avatarButtons)\n        {\n            button.onClick.AddListener(() => SelectAvatar(button));\n        }\n    }\n\n    private void OpenAvatarSelection()\n    {\n        // 显示选择页面\n        avatarSelectionPanel.SetActive(true);\n    }\n\n    private void SelectAvatar(Button clickedButton)\n    {\n        // 获取选择的头像（假设头像是按钮的子对象的Image组件）\n        Image avatarImage = clickedButton.GetComponentInChildren<Image>();\n\n        // 更新显示的头像\n        selectedAvatarDisplay.sprite = avatarImage.sprite;\n\n        // 隐藏选择页面\n        avatarSelectionPanel.SetActive(false);\n    }\n}\n#endif\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 功能定位\n`UserAvatarSelector` 是一个用于用户选择头像的脚本组件，主要用于在Unity游戏或应用中实现用户头像选择功能。该组件通过UI按钮和面板实现头像选择界面的显示与操作。\n\n#### 系统角色\n该组件在系统中扮演用户交互界面管理者的角色，负责处理用户选择头像的操作逻辑。其重要性体现在为用户提供个性化的头像选择体验，增强用户界面的交互性。\n\n#### 主要特性与技术实现\n- **头像选择界面管理**：通过按钮和面板实现头像选择界面的显示与隐藏。\n- **事件驱动机制**：使用Unity的`Button.onClick`事件监听器实现用户点击操作的响应。\n- **UI组件交互**：通过访问Unity的UI组件（如`Button`、`Image`、`GameObject`）实现界面元素的交互逻辑。\n\n### 2. 核心类解析\n\n#### 类名称：`UserAvatarSelector`\n\n- **职责说明**\n  - 管理头像选择界面的显示与隐藏。\n  - 处理用户点击头像按钮的操作，更新选定的头像并显示。\n\n- **关键方法清单**\n  - `private void Start()`\n  - `private void OpenAvatarSelection()`\n  - `private void SelectAvatar(Button clickedButton)`\n\n- **继承关系**\n  ```\n  UserAvatarSelector -> MonoBehaviour\n  ```\n\n- **依赖模块**\n  - `UnityEngine.UI`（包含`Button`、`GameObject`、`Image`、`Sprite`类）\n\n### 3. 关键方法详解\n\n#### 方法：`private void Start()`\n\n- **方法签名**\n  ```csharp\n  private void Start()\n  ```\n\n- **功能描述**\n  - 在游戏或应用启动时执行初始化操作：\n    - 隐藏头像选择面板。\n    - 为打开头像选择界面的按钮添加点击事件监听器。\n    - 为每个头像按钮添加点击事件监听器。\n\n- **调用关系**\n  - 由Unity引擎在场景加载时自动调用。\n  - 调用`OpenAvatarSelection`方法。\n  - 调用`SelectAvatar`方法（通过循环为每个头像按钮添加事件监听器）。\n\n#### 方法：`private void OpenAvatarSelection()`\n\n- **方法签名**\n  ```csharp\n  private void OpenAvatarSelection()\n  ```\n\n- **功能描述**\n  - 显示头像选择面板，允许用户选择头像。\n\n- **调用关系**\n  - 被`Start`方法通过`openAvatarSelectionButton.onClick.AddListener(OpenAvatarSelection)`调用。\n  - 在用户点击`openAvatarSelectionButton`按钮时执行。\n\n#### 方法：`private void SelectAvatar(Button clickedButton)`\n\n- **方法签名**\n  ```csharp\n  private void SelectAvatar(Button clickedButton)\n  ```\n\n- **功能描述**\n  - 处理用户点击头像按钮的操作：\n    - 获取被点击按钮的子对象中的`Image`组件。\n    - 更新选定的头像并显示在`selectedAvatarDisplay`上。\n    - 隐藏头像选择面板。\n\n- **算法说明**\n  - 通过`GetComponentInChildren<Image>()`方法获取按钮的子对象中的`Image`组件。\n  - 更新`selectedAvatarDisplay`的`sprite`属性以显示选中的头像。\n\n- **调用关系**\n  - 被`Start`方法通过`button.onClick.AddListener(() => SelectAvatar(button))`调用。\n  - 在用户点击任意头像按钮时执行。\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class UserAvatarSelector {\n        +void Start()\n        +void OpenAvatarSelection()\n        +void SelectAvatar(Button)\n    }\n    class MonoBehaviour\n    class Button\n    class GameObject\n    class Image\n    class Sprite\n\n    UserAvatarSelector --> MonoBehaviour : extends\n    UserAvatarSelector --> Button : uses\n    UserAvatarSelector --> GameObject : uses\n    UserAvatarSelector --> Image : uses\n    UserAvatarSelector --> Sprite : uses\n```\n\n### 总结\n\n`UserAvatarSelector`是一个功能",
    "chunk_order_index": 0,
    "full_doc_id": "doc-aa54abfd2e1ecec82b58f7f0ecdd58f8"
  },
  "chunk-29878fbdaded8ed73a8aeab23cac15b6": {
    "tokens": 143,
    "content": "()\n        +void OpenAvatarSelection()\n        +void SelectAvatar(Button)\n    }\n    class MonoBehaviour\n    class Button\n    class GameObject\n    class Image\n    class Sprite\n\n    UserAvatarSelector --> MonoBehaviour : extends\n    UserAvatarSelector --> Button : uses\n    UserAvatarSelector --> GameObject : uses\n    UserAvatarSelector --> Image : uses\n    UserAvatarSelector --> Sprite : uses\n```\n\n### 总结\n\n`UserAvatarSelector`是一个功能完善的用户头像选择器，通过事件驱动机制和Unity的UI组件实现了头像选择界面的管理。其设计简洁明了，适用于需要个性化头像选择的Unity项目。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-aa54abfd2e1ecec82b58f7f0ecdd58f8"
  },
  "chunk-1e473f34f1f7f94d5a6ba06b0f3117c3": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEngine;\nusing UnityEngine.UI;\nusing TMPro;\nusing System.IO;\nusing System.Text;\nusing UnityEngine.SceneManagement; // 引入SceneManager类\nusing UnityEditor;\n\n/// <summary>\n/// 用户信息记录器，用于处理用户注册、文件选择和场景切换等功能\n/// </summary>\npublic class UserInfoRecorder : MonoBehaviour\n{\n    public TMP_InputField usernameInputField; // 用户名输入框 (TextMeshPro)\n    public Image avatarImage; // 头像图片\n    public Button createButton; // 创建按钮\n    public Button selectFileButton; // 选择文件按钮\n    public Button openSceneButton; // 打开道具场景按钮\n    public Button openCharacterEditorButton; // 打开CharacterEditor场景按钮\n\n    public GameObject registrationPanel; // 注册页Panel\n    public GameObject selectionPanel; // 选择页Panel\n    public TMP_Text selectionUsernameText; // 选择页中的用户名文本\n    public Image selectionAvatarImage; // 选择页中的头像图片\n\n    public Button deletePrefsButton; // 删除PlayerPrefs按钮\n\n    void Start()\n    {\n        // 给创建按钮添加点击事件监听\n        createButton.onClick.AddListener(SaveUserInfo);\n        // 给选择文件按钮添加点击事件监听\n        selectFileButton.onClick.AddListener(OpenFileSelectionDialog);\n        // 给删除PlayerPrefs按钮添加点击事件监听\n        deletePrefsButton.onClick.AddListener(DeletePlayerPrefs);\n        // 给打开道具场景按钮添加点击事件监听\n        openSceneButton.onClick.AddListener(OpenScene);\n        // 给打开CharacterEditor场景按钮添加点击事件监听\n        openCharacterEditorButton.onClick.AddListener(OpenCharacterEditorScene);\n\n        // 检查PlayerPrefs是否有保存的用户信息\n        string userKey = PlayerPrefs.GetString(\"currentUserKey\", string.Empty);\n        if (!string.IsNullOrEmpty(userKey))\n        {\n            LoadUserInfo(userKey);\n            SwitchToSceneSelectionPanel();\n        }\n        else\n        {\n            // 如果PlayerPrefs为空，显示注册页面\n            registrationPanel.SetActive(true);\n            selectionPanel.SetActive(false);\n        }\n    }\n\n    void DeletePlayerPrefs()\n    {\n        PlayerPrefs.DeleteKey(\"currentUserKey\");\n        PlayerPrefs.Save();\n        Debug.Log(\"PlayerPrefs data deleted.\");\n\n        // 重新加载当前场景\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n    }\n\n    void SaveUserInfo()\n    {\n        string username = usernameInputField.text;\n        string avatarName = avatarImage.sprite.name + \".png\"; // 添加文件后缀名\n\n        // 生成唯一标识符 (用户名 + PurchaseRecordLibrary)\n        string userKey = username + \"PurchaseRecordLibrary\";\n\n        // 将用户名 + PurchaseRecordLibrary 保存到 PlayerPrefs 中\n        PlayerPrefs.SetString(\"currentUserKey\", userKey);\n        PlayerPrefs.Save();\n\n        // 创建CSV文件名\n        string fileName = userKey + \".csv\";\n        StringBuilder csvContent = new StringBuilder();\n        csvContent.AppendLine(\"用户,头像\");\n        csvContent.AppendLine($\"{username},{avatarName}\");\n\n        // 保存路径\n        string folderPath = Path.Combine(Application.dataPath, \"ZTResource/UserInfo\");\n        if (!Directory.Exists(folderPath))\n        {\n            Directory.CreateDirectory(folderPath);\n        }\n\n        string filePath = Path.Combine(folderPath, fileName);\n        File.WriteAllText(filePath, csvContent.ToString(), Encoding.UTF8);\n\n        Debug.Log(\"User information saved to: \" + filePath);\n\n        // 刷新项目窗口\n        AssetDatabase.Refresh();\n\n        // 切换到选择页Panel\n        LoadUserInfo(userKey);\n        SwitchToSceneSelectionPanel();\n    }\n\n    void OpenFileSelectionDialog()\n    {\n        string folderPath = Path.Combine(Application.dataPath, \"ZTResource/UserInfo\");\n        string filePath = EditorUtility.OpenFilePanel(\"Select User CSV\", folderPath, \"csv\");\n\n        if (!string.IsNullOrEmpty(filePath))\n        {\n            // 从文件名中提取用户名并保存到 PlayerPrefs\n            string fileName = Path.GetFileNameWithoutExtension(filePath);\n            PlayerPrefs.SetString(\"currentUserKey\", fileName);\n            PlayerPrefs.Save();\n\n            Debug.Log(\"User information loaded from: \" + filePath);\n\n            // 切换到选择页Panel\n            LoadUserInfo(fileName);\n            SwitchToSceneSelectionPanel();\n        }\n    }\n\n    void LoadUserInfo(string userKey)\n    {\n        string folderPath = Path.Combine(Application.dataPath, \"ZTResource/UserInfo\");\n        string fileName = userKey + \".csv\";\n        string filePath = Path.Combine(folderPath, fileName);\n\n        if (!File.Exists(filePath))\n        {\n            Debug.LogError(\"User CSV file not found: \" + filePath);\n            return;\n        }\n\n        string[] lines = File.ReadAllLines(filePath);\n        if (lines.Length > 1)\n        {\n            string[] data = lines[1].Split(',');\n            string username = data[0];\n            string avatarName = data[1];\n\n            selectionUsernameText.text = username;\n\n            // 加载头像图片\n            string avatarPath = Path.Combine(Application.dataPath, \"ZTResource/Resources/ZT_Sprites/ZT_User_Icon\", Path.GetFileNameWithoutExtension(avatarName) + \".png\");\n            if (File.Exists(avatarPath))\n            {\n                byte[] fileData = File.ReadAllBytes(avatarPath);\n                Texture2D texture = new Texture2D(2, 2);\n                texture.LoadImage(fileData);\n                Sprite avatarSprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2",
    "chunk_order_index": 0,
    "full_doc_id": "doc-ed2d2ebe601c01f90824184f8b72c7f2"
  },
  "chunk-8e000575469afcbababaee99d7dcbee2": {
    "tokens": 1200,
    "content": "/Resources/ZT_Sprites/ZT_User_Icon\", Path.GetFileNameWithoutExtension(avatarName) + \".png\");\n            if (File.Exists(avatarPath))\n            {\n                byte[] fileData = File.ReadAllBytes(avatarPath);\n                Texture2D texture = new Texture2D(2, 2);\n                texture.LoadImage(fileData);\n                Sprite avatarSprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), new Vector2(0.5f, 0.5f));\n                selectionAvatarImage.sprite = avatarSprite;\n            }\n            else\n            {\n                Debug.LogError(\"Avatar sprite not found at path: \" + avatarPath);\n            }\n        }\n        else\n        {\n            Debug.LogError(\"CSV file format is incorrect or empty.\");\n        }\n    }\n\n    void SwitchToSceneSelectionPanel()\n    {\n        // 隐藏注册页Panel，显示选择页Panel\n        registrationPanel.SetActive(false);\n        selectionPanel.SetActive(true);\n    }\n\n    void OpenScene()\n    {\n        SceneManager.LoadScene(\"Assets/ZTResource/ZTResource.unity\");\n    }\n\n    void OpenCharacterEditorScene()\n    {\n        SceneManager.LoadScene(\"CharacterEditor\");\n    }\n}\n#endif\n\n源代码内容解释如下：\n### 功能概览\n\n#### 总结\n`UserInfoRecorder` 是一个用于管理用户信息的脚本，主要功能包括用户注册、用户信息的保存与加载、场景切换以及界面管理。它在 Unity 项目中扮演用户数据管理的核心角色，支持用户创建账户、选择头像、加载用户数据以及在不同场景之间切换。\n\n#### 角色与重要性\n该脚本在用户管理模块中至关重要，负责用户数据的持久化存储（使用 `PlayerPrefs` 和 CSV 文件），并管理用户界面的显示与隐藏。通过该脚本，用户能够创建新账户、选择已有账户以及在不同场景之间导航。它还提供了删除用户数据的功能，增强了系统的灵活性和安全性。\n\n#### 主要特性与技术实现\n- **用户注册与保存**：通过 `SaveUserInfo` 方法，将用户名和头像信息保存到 CSV 文件，并记录当前用户标识到 `PlayerPrefs`。\n- **文件选择与加载**：利用 `OpenFileSelectionDialog` 方法，允许用户选择 CSV 文件并加载相应的用户数据。\n- **场景切换**：通过 `SceneManager` 实现不同场景之间的切换，包括道具场景和角色编辑器场景。\n- **界面管理**：动态显示和隐藏注册界面和选择界面，提升用户体验。\n- **用户数据删除**：通过 `DeletePlayerPrefs` 方法清除用户数据并重载场景，提供数据清除功能。\n\n### 核心类解析\n\n#### `UserInfoRecorder`\n- **职责说明**：该类负责用户信息的记录、加载、保存以及界面和场景的切换操作。它管理用户与应用程序之间的交互，确保用户数据的正确存储和加载。\n- **关键方法清单**：\n  - `void Start()`\n  - `void DeletePlayerPrefs()`\n  - `void SaveUserInfo()`\n  - `void OpenFileSelectionDialog()`\n  - `void LoadUserInfo(string userKey)`\n  - `void SwitchToSceneSelectionPanel()`\n  - `void OpenScene()`\n  - `void OpenCharacterEditorScene()`\n- **继承关系**：`UserInfoRecorder -> MonoBehaviour`\n- **依赖模块**：\n  - `UnityEngine.SceneManagement.SceneManager`\n  - `UnityEngine.PlayerPrefs`\n  - ` UnityEditor.EditorUtility`\n  - ` UnityEditor.AssetDatabase`\n  - `System.IO.File`、`System.IO.Directory`\n  - `UnityEngine.UI.Image`、`UnityEngine.UI.Button`、` UnityEngine.UI.TMP_InputField`、`UnityEngine.UI.TMP_Text`\n\n### 关键方法详解\n\n#### `void Start()`\n- **方法签名**：`void Start()`\n- **功能描述**：初始化按钮点击事件监听，检查 `PlayerPrefs` 中是否存在用户数据。如果存在，则加载用户数据并显示选择界面；否则，显示注册界面。\n- **算法说明**：使用 Unity 的 `MonoBehaviour` 生命周期函数，在脚本初始化时完成按钮事件绑定和用户数据检查。\n- **调用关系**：在脚本初始化时自动调用，调用 `SaveUserInfo`、`OpenFileSelectionDialog`、`DeletePlayerPrefs` 等方法。\n\n#### `void SaveUserInfo()`\n- **方法签名**：`void SaveUserInfo()`\n- **功能描述**：从输入框获取用户名和头像信息，生成唯一用户标识符，保存 CSV 文件并更新 `PlayerPrefs`。\n- **算法说明**：\n  1. 从输入框获取用户名和头像信息。\n  2. 生成唯一用户标识符 `userKey`。\n  3. 将 `userKey` 保存到 `PlayerPrefs`。\n  4. 创建 CSV 文件并写入用户数据。\n  5. 更新 UI 界面，显示选择界面。\n- **调用关系**：由 `createButton` 的点击事件触发，调用 `File.WriteAllText` 和 ` SceneManager.LoadScene`。\n\n#### `void OpenFileSelectionDialog()`\n- **方法签名**：`void OpenFileSelectionDialog()`\n- **功能描述**：打开文件选择对话框，允许用户选择 CSV 文件，加载用户数据并显示选择界面。\n- **算法说明**",
    "chunk_order_index": 1,
    "full_doc_id": "doc-ed2d2ebe601c01f90824184f8b72c7f2"
  },
  "chunk-f8d0bc27f3d4ba56ed35c49fa46f598a": {
    "tokens": 970,
    "content": "更新 UI 界面，显示选择界面。\n- **调用关系**：由 `createButton` 的点击事件触发，调用 `File.WriteAllText` 和 ` SceneManager.LoadScene`。\n\n#### `void OpenFileSelectionDialog()`\n- **方法签名**：`void OpenFileSelectionDialog()`\n- **功能描述**：打开文件选择对话框，允许用户选择 CSV 文件，加载用户数据并显示选择界面。\n- **算法说明**：\n  1. 打开文件选择对话框，获取用户选择的 CSV 文件路径。\n  2. 从文件名中提取用户名，并保存到 `PlayerPrefs`。\n  3. 加载用户数据并更新 UI 界面。\n- **调用关系**：由 `selectFileButton` 的点击事件触发，调用 `EditorUtility.OpenFilePanel` 和 `LoadUserInfo`。\n\n#### `void LoadUserInfo(string userKey)`\n- **方法签名**：`void LoadUserInfo(string userKey)`\n- **功能描述**：根据用户标识符加载 CSV 文件中的用户数据，更新 UI 界面。\n- **算法说明**：\n  1. 检查 CSV 文件是否存在，读取用户数据。\n  2. 更新用户名和头像信息。\n  3. 加载头像图片并显示。\n- **调用关系**：由 `SaveUserInfo` 和 `OpenFileSelectionDialog` 方法调用，调用 `File.ReadAllLines` 和 ` Texture2D.LoadImage`。\n\n#### `void SwitchToSceneSelectionPanel()`\n- **方法签名**：`void SwitchToSceneSelectionPanel()`\n- **功能描述**：隐藏注册界面，显示选择界面。\n- **算法说明**：通过设置游戏对象的 `active` 属性来控制界面的显示与隐藏。\n- **调用关系**：由 `SaveUserInfo`、`OpenFileSelectionDialog` 和 `DeletePlayerPrefs` 方法调用。\n\n#### `void OpenScene()`\n- **方法签名**：`void OpenScene()`\n- **功能描述**：加载道具场景。\n- **算法说明**：使用 `SceneManager.LoadScene` 加载指定场景。\n- **调用关系**：由 `openSceneButton` 的点击事件触发。\n\n#### `void OpenCharacterEditorScene()`\n- **方法签名**：`void OpenCharacterEditorScene()`\n- **功能描述**：加载角色编辑器场景。\n- **算法说明**：使用 `SceneManager.LoadScene` 加载指定场景。\n- **调用关系**：由 `openCharacterEditorButton` 的点击事件触发。\n\n#### `void DeletePlayerPrefs()`\n- **方法签名**：`void DeletePlayerPrefs()`\n- **功能描述**：删除 `PlayerPrefs` 中的用户数据，并重载当前场景。\n- **算法说明**：清除 `PlayerPrefs` 中的用户标识符，保存更改并重载场景。\n- **调用关系**：由 `deletePrefsButton` 的点击事件触发，调用 `SceneManager.LoadScene`。\n\n### 架构关系图\n\n```mermaid\nclassDiagram\n    class UserInfoRecorder {\n        +void Start()\n        +void DeletePlayerPrefs()\n        +void SaveUserInfo()\n        +void OpenFileSelectionDialog()\n        +void LoadUserInfo(string userKey)\n        +void SwitchToSceneSelectionPanel()\n        +void OpenScene()\n        +void OpenCharacterEditorScene()\n    }\n    class MonoBehaviour {\n    }\n    class SceneManager {\n    }\n    class PlayerPrefs {\n    }\n    class EditorUtility {\n    }\n    class AssetDatabase {\n    }\n    class File {\n    }\n    class Directory {\n    }\n    class TMP_InputField {\n    }\n    class Image {\n    }\n    class Button {\n    }\n    class TMP_Text {\n    }\n    class GameObject {\n    }\n    class Sprite {\n    }\n    class Texture2D {\n    }\n    \n    UserInfoRecorder --> MonoBehaviour : extends\n    UserInfoRecorder --> SceneManager : uses\n    UserInfoRecorder --> PlayerPrefs : uses\n    UserInfoRecorder --> EditorUtility : uses\n    UserInfoRecorder --> AssetDatabase : uses\n    UserInfoRecorder --> File : uses\n    UserInfoRecorder --> Directory : uses\n    UserInfoRecorder --> TMP_InputField : uses\n    UserInfoRecorder --> Image : uses\n    UserInfoRecorder --> Button : uses\n    UserInfoRecorder --> TMP_Text : uses\n    UserInfoRecorder --> GameObject : uses\n    UserInfoRecorder --> Sprite : uses\n    UserInfoRecorder --> Texture2D : uses\n```",
    "chunk_order_index": 2,
    "full_doc_id": "doc-ed2d2ebe601c01f90824184f8b72c7f2"
  },
  "chunk-1f554b65ed1f8364693f99473cb00dc8": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class ZTDragAndDrop : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IPointerDownHandler, IPointerUpHandler\n{\n    private Transform originalParent;\n    private Canvas canvas;\n    private CanvasGroup canvasGroup;\n    private bool isDragging = false;\n    private float holdTime = 0.2f;  // 按住0.2秒\n    private Coroutine holdCoroutine;\n    private HistoryCardUI historyCardUI;\n    private BatchUI originalBatchUI;\n    private BatchUI targetBatchUI;\n\n    void Start()\n    {\n        // 获取Canvas组件\n        canvas = GetComponentInParent<Canvas>();\n\n        // 确保对象上有CanvasGroup组件\n        canvasGroup = GetComponent<CanvasGroup>();\n        if (canvasGroup == null)\n        {\n            canvasGroup = gameObject.AddComponent<CanvasGroup>();\n        }\n\n        // 获取HistoryCardUI组件\n        historyCardUI = GetComponent<HistoryCardUI>();\n        // 获取原始批次的BatchUI组件\n        originalBatchUI = GetComponentInParent<BatchUI>();\n    }\n\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        holdCoroutine = StartCoroutine(StartHoldTimer());\n    }\n\n    public void OnPointerUp(PointerEventData eventData)\n    {\n        if (holdCoroutine != null)\n        {\n            StopCoroutine(holdCoroutine);\n            holdCoroutine = null;\n        }\n    }\n\n    private IEnumerator StartHoldTimer()\n    {\n        yield return new WaitForSeconds(holdTime);\n        isDragging = true;\n        originalParent = transform.parent;\n        transform.SetParent(canvas.transform, true);\n        canvasGroup.blocksRaycasts = false;\n    }\n\n    public void OnBeginDrag(PointerEventData eventData)\n    {\n        // 仅当isDragging为true时才开始拖动\n        if (!isDragging)\n        {\n            eventData.pointerDrag = null;\n            return;\n        }\n    }\n\n    public void OnDrag(PointerEventData eventData)\n    {\n        if (!isDragging)\n            return;\n\n        Vector2 localPoint;\n        RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas.transform as RectTransform, eventData.position, eventData.pressEventCamera, out localPoint);\n        transform.localPosition = localPoint;\n    }\n\n    public void OnEndDrag(PointerEventData eventData)\n    {\n        if (!isDragging)\n            return;\n\n        isDragging = false;\n        canvasGroup.blocksRaycasts = true;\n\n        GameObject dropZone = GetDropZoneUnderPointer(eventData);\n\n        if (dropZone != null && dropZone.CompareTag(\"DropZone\"))\n        {\n            targetBatchUI = dropZone.GetComponentInParent<BatchUI>();\n            if (targetBatchUI != null && historyCardUI != null)\n            {\n                string resourceId = historyCardUI.idText.text;\n                string targetBatchTime = targetBatchUI.batchTimeText.text;\n\n                string csvFilePath = historyCardUI.csvFilePath;\n\n                // 直接移动资源到目标批次\n                CSVParser.MoveResourceToBatch(csvFilePath, resourceId, targetBatchTime);\n\n                // 将资源卡UI移动到新的批次中\n                transform.SetParent(dropZone.transform, false);\n            }\n        }\n        else\n        {\n            transform.SetParent(originalParent, false);\n        }\n    }\n\n    private GameObject GetDropZoneUnderPointer(PointerEventData eventData)\n    {\n        List<RaycastResult> raycastResults = new List<RaycastResult>();\n        EventSystem.current.RaycastAll(eventData, raycastResults);\n\n        foreach (RaycastResult result in raycastResults)\n        {\n            if (result.gameObject.CompareTag(\"DropZone\"))\n            {\n                return result.gameObject;\n            }\n        }\n\n        return null;\n    }\n}\n\n源代码内容解释如下：\n```markdown\n# ZTDragAndDrop 代码分析\n\n## 1. 功能概览\n\n### 功能定位\nZTDragAndDrop 类实现了拖放功能，允许用户通过鼠标或触控设备拖动 UI 元素，并将其放置在目标区域。该类主要负责处理拖放事件、状态管理以及与 CSV 数据的交互。\n\n### 在系统中的角色和重要性\n该类是用户交互的核心组件，直接影响用户体验，确保用户能够通过拖放操作调整资源批次。其正确实现对于系统的功能完整性和可用性至关重要。\n\n### 主要特性和技术实现方案\n- **拖放事件处理**：实现 IBeginDragHandler、IDragHandler、IEndDragHandler 等接口，处理拖放过程中的各个阶段。\n- **延迟启动**：通过协程实现拖放操作的延迟启动，防止误触。\n- **状态管理**：维护拖放状态，包括原始父对象、当前画布和拖放标志。\n- **CSV 数据交互**：通过 CSVParser 移动资源到目标批次。\n- **视觉反馈**：调整 CanvasGroup 的 blocksRaycasts 属性，控制拖放过程中元素的交互状态。\n\n## 2. 核心类解析\n\n### ZTDragAndDrop\n\n#### 职责说明\n该类负责处理拖放事件，管理拖放状态，并与 CSV 数据进行交互，实现资源的重新分配。\n\n#### 关键方法清单\n- `public void OnPointerDown(PointerEventData eventData)`\n- `public void OnPointerUp(PointerEventData eventData)`\n- `private IEnumerator StartHoldTimer()`\n- `public void OnBeginDrag(PointerEventData eventData)`\n- `public void On",
    "chunk_order_index": 0,
    "full_doc_id": "doc-b5d863d3eeff71e33cec930521b10b3b"
  },
  "chunk-d3bb26ae2cac16dcd6d503fae2830cb4": {
    "tokens": 1144,
    "content": "TDragAndDrop\n\n#### 职责说明\n该类负责处理拖放事件，管理拖放状态，并与 CSV 数据进行交互，实现资源的重新分配。\n\n#### 关键方法清单\n- `public void OnPointerDown(PointerEventData eventData)`\n- `public void OnPointerUp(PointerEventData eventData)`\n- `private IEnumerator StartHoldTimer()`\n- `public void OnBeginDrag(PointerEventData eventData)`\n- `public void OnDrag(PointerEventData eventData)`\n- `public void OnEndDrag(PointerEventData eventData)`\n- `private GameObject GetDropZoneUnderPointer(PointerEventData eventData)`\n\n#### 继承关系\n```mermaid\ngraph TD\n    ZTDragAndDrop --> MonoBehaviour\n```\n\n#### 依赖模块\n- `UnityEngine.UI`（Canvas、CanvasGroup）\n- `UnityEngine.EventSystems`（PointerEventData、EventSystem）\n- `System.Collections`（IEnumerator、 WaitForSeconds）\n- `System.Collections.Generic`（List）\n- 项目内类：HistoryCardUI、BatchUI、CSVParser\n\n## 3. 关键方法详解\n\n### `public void OnPointerDown(PointerEventData eventData)`\n#### 方法签名\n```csharp\npublic void OnPointerDown(PointerEventData eventData)\n```\n#### 功能描述\n当用户按下鼠标按钮或触控设备时调用，启动一个协程来计时拖放操作的延迟启动。\n\n#### 调用关系\n- 被 Unity 事件系统调用，频率取决于用户的输入操作。\n\n### `public void OnPointerUp(PointerEventData eventData)`\n#### 方法签名\n```csharp\npublic void OnPointerUp(PointerEventData eventData)\n```\n#### 功能描述\n当用户释放鼠标按钮或触控设备时调用，停止拖放计时器。\n\n#### 调用关系\n- 被 Unity 事件系统调用，频率取决于用户的输入操作。\n\n### `private IEnumerator StartHoldTimer()`\n#### 方法签名\n```csharp\nprivate IEnumerator StartHoldTimer()\n```\n#### 功能描述\n启动一个协程，等待 `holdTime` 时间后，将 `isDragging` 标志设为 true，并调整拖放对象的父对象和画布组属性。\n\n#### 算法说明\n使用 `WaitForSeconds` 协程实现延迟计时。\n\n#### 调用关系\n- 被 `OnPointerDown` 方法调用，频率取决于用户的输入操作。\n\n### `public void OnBeginDrag(PointerEventData eventData)`\n#### 方法签名\n```csharp\npublic void OnBeginDrag(PointerEventData eventData)\n```\n#### 功能描述\n检查拖放状态，如果 `isDragging` 为 true，则允许拖动操作。\n\n#### 调用关系\n- 被 Unity 事件系统调用，频率取决于用户的拖放操作。\n\n### `public void OnDrag(PointerEventData eventData)`\n#### 方法签名\n```csharp\npublic void OnDrag(PointerEventData eventData)\n```\n#### 功能描述\n根据鼠标或触控设备的位置，更新拖放对象的局部位置。\n\n#### 算法说明\n使用 `RectTransformUtility.ScreenPointToLocalPointInRectangle` 方法将屏幕坐标转换为局部坐标。\n\n#### 调用关系\n- 被 Unity 事件系统调用，频率取决于用户的拖动操作。\n\n### `public void OnEndDrag(PointerEventData eventData)`\n#### 方法签名\n```csharp\npublic void OnEndDrag(PointerEventData eventData)\n```\n#### 功能描述\n结束拖放操作，检查鼠标或触控设备是否位于目标区域（DropZone），如果是，则将资源移动到目标批次，否则将其放回原位置。\n\n#### 调用关系\n- 被 Unity 事件系统调用，频率取决于用户的拖放操作。\n\n### `private GameObject GetDropZoneUnderPointer(PointerEventData eventData)`\n#### 方法签名\n```csharp\nprivate GameObject GetDropZoneUnderPointer(PointerEventData eventData)\n```\n#### 功能描述\n通过射线检测，判断鼠标或触控设备是否位于目标区域（DropZone）上，返回对应的物体。\n\n#### 算法说明\n使用 `EventSystem.current.RaycastAll` 方法获取所有命中结果，遍历检查是否为 DropZone。\n\n#### 调用关系\n- 被 `OnEndDrag` 方法调用，频率取决于用户的拖放操作。\n\n## 4. 架构关系图\n\n```mermaid\ngraph TD\n    ZTDragAndDrop --> Canvas\n    ZTDragAndDrop --> CanvasGroup\n    ZTDragAndDrop --> HistoryCardUI\n    ZTDragAndDrop --> BatchUI\n    ZTDragAndDrop --> CSVParser\n```\n\n### 说明\n- **继承层次结构**：ZTDragAndDrop 继承自 MonoBehaviour。\n- **组合/聚合关系**：ZTDragAndDrop 组合 Canvas、CanvasGroup、HistoryCardUI、BatchUI 组件。\n- **重要依赖关系**：依赖 CSVParser 类进行数据操作。\n- **接口实现情况**：实现 IBeginDragHandler、IDragHandler、IEndDragHandler、IPointerDownHandler、IPointerUpHandler 接口。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-b5d863d3eeff71e33cec930521b10b3b"
  },
  "chunk-7e1c743a9f31da989edbccf74f6362d6": {
    "tokens": 44,
    "content": "：依赖 CSVParser 类进行数据操作。\n- **接口实现情况**：实现 IBeginDragHandler、IDragHandler、IEndDragHandler、IPointerDownHandler、IPointerUpHandler 接口。",
    "chunk_order_index": 2,
    "full_doc_id": "doc-b5d863d3eeff71e33cec930521b10b3b"
  },
  "chunk-3ac1de7fd63ca0e7eb27999f8797fcd6": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class InputFieldCustomCaret : MonoBehaviour\n{\n    public TMP_InputField tmpInputField; // 关联到TMP_InputField组件\n    public RectTransform customCaretImage; // 关联到自定义的光标Image的RectTransform\n    public float yOffset = 0f; // Y轴偏移值\n    public float blinkRate = 0.5f; // 闪烁频率（秒）\n\n    private float blinkTimer;\n    private bool isCaretVisible;\n\n    private void Start()\n    {\n        // 禁用TMP_InputField自带的光标\n        tmpInputField.caretBlinkRate = 0f;\n        tmpInputField.caretWidth = 0;\n\n        // 初始化自定义光标的闪烁状态\n        isCaretVisible = true;\n        blinkTimer = 0f;\n    }\n\n    private void Update()\n    {\n        if (tmpInputField.isFocused)\n        {\n            // 显示并更新光标位置\n            customCaretImage.gameObject.SetActive(true);\n\n            // 获取光标的位置\n            int caretPosition = tmpInputField.stringPosition;\n            Vector2 caretLocalPosition = GetCaretPosition(caretPosition);\n\n            // 应用Y轴偏移\n            caretLocalPosition.y += yOffset;\n\n            // 更新光标位置\n            customCaretImage.anchoredPosition = caretLocalPosition;\n\n            // 处理光标闪烁\n            HandleBlinking();\n        }\n        else\n        {\n            // 隐藏光标\n            customCaretImage.gameObject.SetActive(false);\n        }\n    }\n\n    private Vector2 GetCaretPosition(int caretPosition)\n    {\n        // 获取字符的信息\n        TMP_Text textComponent = tmpInputField.textComponent;\n        TMP_CharacterInfo charInfo = textComponent.textInfo.characterInfo[caretPosition];\n\n        // 计算光标位置（基于字符的底部）\n        float cursorPosX = charInfo.origin;\n        float cursorPosY = charInfo.descender;\n\n        return new Vector2(cursorPosX, cursorPosY);\n    }\n\n    private void HandleBlinking()\n    {\n        blinkTimer += Time.deltaTime;\n\n        if (blinkTimer >= blinkRate)\n        {\n            isCaretVisible = !isCaretVisible;\n            customCaretImage.gameObject.SetActive(isCaretVisible);\n            blinkTimer = 0f;\n        }\n    }\n}\n源代码内容解释如下：\n## 功能概览\n\n### 功能定位\n该代码文件实现了对Unity中TextMeshPro（TMP）输入字段的自定义光标功能。它允许用户自定义光标的外观、位置和闪烁频率，从而提供更灵活的文本输入体验。\n\n### 系统角色\n在Unity项目中，该类作为输入字段的增强组件，弥补了TextMeshPro内置光标功能的不足，提供了更高的自定义能力。\n\n### 主要特性与技术实现\n- **自定义光标外观**：通过关联RectTransform组件，实现自定义光标形状和大小。\n- **光标位置动态更新**：根据输入字段内容变化，实时调整光标位置。\n- **闪烁频率控制**：可配置的闪烁间隔时间，提供良好的视觉反馈。\n- **技术实现**：基于Unity的 MonoBehaviour生命周期，结合TextMeshPro文本渲染机制，通过RectTransform实现光标位置计算和显示逻辑。\n\n## 核心类解析\n\n### `InputFieldCustomCaret`\n\n#### 职责说明\n该类负责管理自定义光标的行为，包括光标的显示、位置更新和闪烁效果。\n\n#### 关键方法清单\n- `private void Start()`\n- `private void Update()`\n- `private Vector2 GetCaretPosition(int caretPosition)`\n- `private void HandleBlinking()`\n\n#### 继承关系\n```\nInputFieldCustomCaret -> MonoBehaviour\n```\n\n#### 依赖模块\n- `TMP_InputField`\n- `RectTransform`\n\n## 关键方法详解\n\n### `private void Start()`\n\n#### 方法签名\n```csharp\nprivate void Start()\n```\n\n#### 功能描述\n初始化自定义光标的显示状态和闪烁参数。禁用TextMeshPro的内置光标，并设置自定义光标的初始可见状态和闪烁计时器。\n\n#### 算法说明\n- 禁用内置光标：通过设置`tmpInputField.caretBlinkRate`为0禁用TextMeshPro的光标闪烁，`tmpInputField.caretWidth`设置为0隐藏光标。\n- 初始化闪烁状态：将`isCaretVisible`设为`true`，`blinkTimer`初始化为0。\n\n#### 调用关系\n- 被MonoBehaviour的生命周期机制调用，频率为一次（游戏开始时）。\n\n### `private void Update()`\n\n#### 方法签名\n```csharp\nprivate void Update()\n```\n\n#### 功能描述\n每帧更新光标的位置和显示状态。当输入字段获得焦点时，显示并更新光标位置；否则隐藏光标。\n\n#### 算法说明\n- 焦点检测：检查`tmpInputField.isFocused`判断输入字段是否处于焦点状态。\n- 光标位置更新：调用`GetCaretPosition`获取光标位置，并应用Y轴偏移。\n- 闪烁处理：调用`HandleBlinking`控制光标的闪烁效果。\n\n#### 调用关系\n- 被MonoBehaviour的生命周期机制每帧调用。\n\n### `private Vector2 GetCaretPosition(int",
    "chunk_order_index": 0,
    "full_doc_id": "doc-60ce604ad6ead5fd4f3fb1a506cf7cdc"
  },
  "chunk-3fb4fff038324ea6627801ce7bd3cfa9": {
    "tokens": 546,
    "content": "算法说明\n- 焦点检测：检查`tmpInputField.isFocused`判断输入字段是否处于焦点状态。\n- 光标位置更新：调用`GetCaretPosition`获取光标位置，并应用Y轴偏移。\n- 闪烁处理：调用`HandleBlinking`控制光标的闪烁效果。\n\n#### 调用关系\n- 被MonoBehaviour的生命周期机制每帧调用。\n\n### `private Vector2 GetCaretPosition(int caretPosition)`\n\n#### 方法签名\n```csharp\nprivate Vector2 GetCaretPosition(int caretPosition)\n```\n\n#### 功能描述\n计算光标在输入字段中的位置，基于当前光标所在字符的位置信息。\n\n#### 算法说明\n- 字符信息获取：通过`textComponent.textInfo.characterInfo`数组获取当前光标位置的字符信息。\n- 位置计算：使用字符的`origin`作为X坐标，`descender`作为Y坐标，并返回该位置。\n\n#### 调用关系\n- 被`Update`方法在焦点状态下调用，频率取决于输入字段的焦点状态和更新频率。\n\n### `private void HandleBlinking()`\n\n#### 方法签名\n```csharp\nprivate void HandleBlinking()\n```\n\n#### 功能描述\n控制光标的闪烁效果，基于配置的闪烁频率。\n\n#### 算法说明\n- 时间计时：每帧增加`blinkTimer`值，当达到`blinkRate`时，切换光标的可见状态，并重置计时器。\n\n#### 调用关系\n- 被`Update`方法在焦点状态下调用，频率取决于输入字段的焦点状态和更新频率。\n\n## 架构关系图\n\n```mermaid\nclassDiagram\n\n    class InputFieldCustomCaret {\n        +TMP_InputField tmpInputField\n        +RectTransform customCaretImage\n        +float yOffset\n        +float blinkRate\n        +float blinkTimer\n        +bool isCaretVisible\n        << MonoBehaviour>>\n    }\n\n    class TMP_InputField {\n        -- textComponent: TMP_Text\n        -- textInfo: TMP_TextInfo\n        -- stringPosition: int\n        -- isFocused: bool\n    }\n\n    class RectTransform {\n        -- anchoredPosition: Vector2\n    }\n\n    InputFieldCustomCaret --> TMP_InputField : 关联\n    InputFieldCustomCaret --> RectTransform : 关联\n    TMP_InputField --> TMP_Text : 组成\n    TMP_InputField --> TMP_TextInfo : 组成\n```",
    "chunk_order_index": 1,
    "full_doc_id": "doc-60ce604ad6ead5fd4f3fb1a506cf7cdc"
  },
  "chunk-a296ae563126d9a11b54378e6f483796": {
    "tokens": 1088,
    "content": "文件源代码内容如下：\n﻿using UnityEngine;\nusing UnityEngine.UI;\n\npublic class ZTGridScaler : MonoBehaviour\n{\n    public GridLayoutGroup gridLayoutGroup;  // 指向Grid Layout Group的引用\n    public Scrollbar scrollbar;              // 指向Scrollbar的引用\n    public float minWidth = 200f;            // 宽度的最小值\n    public float maxWidth = 500f;            // 宽度的最大值\n    public float minHeight = 200f;           // 高度的最小值\n    public float maxHeight = 500f;           // 高度的最大值\n\n    void Update()\n    {\n        if (gridLayoutGroup != null && scrollbar != null)\n        {\n            // 根据Scrollbar的值插值计算当前宽度和高度\n            float currentWidth = Mathf.Lerp(minWidth, maxWidth, scrollbar.value);\n            float currentHeight = Mathf.Lerp(minHeight, maxHeight, scrollbar.value);\n            // 设置GridLayout的Cell Size\n            gridLayoutGroup.cellSize = new Vector2(currentWidth, currentHeight);\n        }\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n- **功能定位**：  \n  该代码是一个Unity脚本，用于动态调整GridLayoutGroup的单元格大小（Cell Size），使其根据Scrollbar的值在指定的最小值和最大值之间线性插值变化。  \n  其主要目的是通过滚动条实现对布局的动态缩放，提升用户界面的交互性和响应式设计能力。\n\n- **系统角色与重要性**：  \n  作为Unity UI系统的一部分，该脚本在需要动态调整布局的场景中发挥重要作用，尤其是在需要根据用户输入（如滚动条）调整布局大小的场景中。  \n  它帮助开发者实现更加灵活和动态的界面设计，提升用户体验。\n\n- **主要特性与技术实现**：  \n  - 使用` Mathf.Lerp `函数实现线性插值，确保布局大小变化平滑  \n  - 支持自定义的最小值和最大值范围  \n  - 依赖Unity UI组件（GridLayoutGroup 和 Scrollbar）  \n\n---\n\n### 2. 核心类解析\n\n**类名称：** `ZTGridScaler`  \n**继承关系：**  \n```\nZTGridScaler -> MonoBehaviour\n```\n\n**职责说明：**  \n该类通过监听Scrollbar的值变化，动态调整GridLayoutGroup的单元格大小，实现布局的动态缩放功能。  \n它是MonoBehaviour的子类，继承了Unity脚本组件的基本功能。\n\n**关键方法清单：**  \n- ` void Update() `：每帧执行，根据Scrollbar的值更新GridLayoutGroup的单元格大小。\n\n**依赖模块：**  \n- `UnityEngine.UI.GridLayoutGroup`  \n- `UnityEngine.UI.Scrollbar`  \n\n---\n\n### 3. 关键方法详解\n\n#### 方法名称：`Update()`\n\n**方法签名：**  \n```csharp\nvoid Update()\n```\n\n**功能描述：**  \n该方法每帧执行一次，检查`gridLayoutGroup`和`scrollbar`是否为空。  \n如果不为空，则根据`scrollbar.value`的值，使用`Mathf.Lerp`函数计算当前宽度和高度，并将其设置到`gridLayoutGroup.cellSize`中。  \n具体逻辑如下：  \n1. 从`scrollbar.value`获取当前滚动条的位置（范围：0到1）  \n2. 使用`Mathf.Lerp`计算当前宽度：`currentWidth = Mathf.Lerp(minWidth, maxWidth, scrollbar.value)`  \n3. 使用`Mathf.Lerp`计算当前高度：`currentHeight = Mathf.Lerp(minHeight, maxHeight, scrollbar.value)`  \n4. 将计算得到的宽度和高度设置到`gridLayoutGroup.cellSize`  \n\n**算法说明：**  \n`Mathf.Lerp`函数用于实现线性插值，公式为：  \n```\ncurrent = (1 - value) * minValue + value * maxValue\n```  \n该算法根据滚动条的值在`minWidth`和`maxWidth`之间线性变化，确保布局大小的变化平滑过渡。\n\n**调用关系：**  \n该方法由Unity引擎自动调用，频率为每帧一次。没有其他外部方法直接调用该方法。\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class ZTGridScaler {\n        +void Update()\n    }\n    ZTGridScaler <|-- MonoBehaviour\n    ZTGridScaler *-- GridLayoutGroup : public gridLayoutGroup\n    ZTGridScaler *-- Scrollbar : public scrollbar\n```\n\n---\n\n### 总结\n\n`ZTGridScaler`类通过监听Scrollbar的值变化，动态调整GridLayoutGroup的单元格大小，实现了布局的动态缩放功能。  \n该脚本在Unity UI系统中扮演重要角色，帮助开发者实现灵活且交互友好的用户界面设计。",
    "chunk_order_index": 0,
    "full_doc_id": "doc-a296ae563126d9a11b54378e6f483796"
  },
  "chunk-2dc5d9c5477a136bc7822ee5da4517bd": {
    "tokens": 881,
    "content": "文件源代码内容如下：\nusing UnityEngine;\nusing UnityEngine.UI;\n\npublic class DynamicPanelResizer : MonoBehaviour\n{\n    public RectTransform mainPanel; // 主Panel\n    public RectTransform tagPanel; // Panel_标签\n    public RectTransform searchResultsPanel; // Panel_搜索结果\n\n    private float lastTagPanelHeight = -1f; // 存储上一次Panel_标签的高度\n\n    void Update()\n    {\n        // 检查Panel_标签的高度是否发生了变化\n        if (tagPanel.rect.height != lastTagPanelHeight)\n        {\n            lastTagPanelHeight = tagPanel.rect.height; // 更新存储的高度\n            AdjustSearchResultsPanel(); // 调整Panel_搜索结果的大小\n        }\n    }\n\n    void AdjustSearchResultsPanel()\n    {\n        // 计算Panel_搜索结果的新高度\n        float newHeight = mainPanel.rect.height - tagPanel.rect.height;\n\n        // 设置Panel_搜索结果的高度\n        searchResultsPanel.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, newHeight);\n    }\n}\n源代码内容解释如下：\n### 1. 功能概览\n\n**功能定位**  \n该代码文件实现了动态调整面板大小的功能，用于在Unity游戏引擎中自适应布局。  \n**系统角色**  \n作为UI布局管理的一部分，该类通过监听标签面板的高度变化，动态调整搜索结果面板的大小，确保整体UI布局的协调性和美观性。  \n**主要特性与技术实现**  \n- 高度自适应：根据标签面板的高度变化调整搜索结果面板的高度  \n- 使用Unity的RectTransform进行布局控制  \n- 采用Update方法进行持续检测  \n\n---\n\n### 2. 核心类解析\n\n#### `DynamicPanelResizer`\n\n**职责说明**  \n该类用于动态调整UI面板的大小，确保主面板、标签面板和搜索结果面板之间的布局协调。  \n**关键方法清单**  \n- `void Update()`：持续检测标签面板的高度变化  \n- `void AdjustSearchResultsPanel()`：调整搜索结果面板的大小  \n**继承关系**  \n```\nDynamicPanelResizer -> MonoBehaviour\n```\n**依赖模块**  \n- `UnityEngine.RectTransform`  \n- `UnityEngine.UI`  \n\n---\n\n### 3. 关键方法详解\n\n#### `void Update()`\n\n**方法签名**  \n```csharp\nvoid Update()\n```\n\n**功能描述**  \n该方法在每帧更新时检查标签面板的高度变化。如果高度发生变化，则更新存储的高度值，并调用`AdjustSearchResultsPanel()`方法调整搜索结果面板的大小。  \n\n**算法说明**  \n- 每帧检测标签面板的高度  \n- 通过比较当前高度和存储的高度判断是否需要调整  \n- 如果需要调整，则调用调整方法  \n\n**调用关系**  \n- 被Unity引擎每帧调用  \n\n---\n\n#### `void AdjustSearchResultsPanel()`\n\n**方法签名**  \n```csharp\nvoid AdjustSearchResultsPanel()\n```\n\n**功能描述**  \n该方法计算并设置搜索结果面板的新高度。新高度为主面板高度减去标签面板高度。  \n\n**算法说明**  \n- 计算新高度：`mainPanel.rect.height - tagPanel.rect.height`  \n- 使用`SetSizeWithCurrentAnchors`方法设置搜索结果面板的新高度  \n\n**调用关系**  \n- 被`Update()`方法调用  \n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n    class DynamicPanelResizer {\n        +public RectTransform mainPanel\n        +public RectTransform tagPanel\n        +public RectTransform searchResultsPanel\n        +private float lastTagPanelHeight\n        +void Update()\n        +void AdjustSearchResultsPanel()\n    }\n    class MonoBehaviour\n    DynamicPanelResizer --> MonoBehaviour\n```  \n\n**说明**  \n- `DynamicPanelResizer`继承自`MonoBehaviour`，实现了Unity脚本的行为  \n- 依赖于`RectTransform`用于布局控制",
    "chunk_order_index": 0,
    "full_doc_id": "doc-2dc5d9c5477a136bc7822ee5da4517bd"
  },
  "chunk-ea2d64637711e743a5d605ca732073d4": {
    "tokens": 1200,
    "content": "文件源代码内容如下：\n#if UNITY_EDITOR\nusing UnityEngine;\nusing UnityEngine.EventSystems;\nusing UnityEngine.UI;\n\npublic class SelectionBox : MonoBehaviour, IPointerDownHandler, IPointerUpHandler, IDragHandler\n{\n    public RectTransform selectionBox;\n    public RectTransform content;\n\n    private Vector2 startPoint;\n\n    void Start()\n    {\n        selectionBox.gameObject.SetActive(false);\n    }\n\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        startPoint = eventData.position;\n        selectionBox.gameObject.SetActive(true);\n        UpdateSelectionBox(eventData.position);\n    }\n\n    public void OnDrag(PointerEventData eventData)\n    {\n        UpdateSelectionBox(eventData.position);\n    }\n\n    public void OnPointerUp(PointerEventData eventData)\n    {\n        selectionBox.gameObject.SetActive(false);\n        SelectInstances();\n    }\n\n    private void UpdateSelectionBox(Vector2 currentPoint)\n    {\n        Vector2 size = currentPoint - startPoint;\n        selectionBox.anchoredPosition = startPoint;\n        selectionBox.sizeDelta = new Vector2(Mathf.Abs(size.x), Mathf.Abs(size.y));\n\n        if (size.x < 0)\n            selectionBox.anchoredPosition += new Vector2(size.x, 0);\n        if (size.y < 0)\n            selectionBox.anchoredPosition += new Vector2(0, size.y);\n    }\n\n    private void SelectInstances()\n    {\n        Rect selectionRect = new Rect(selectionBox.anchoredPosition, selectionBox.sizeDelta);\n\n        foreach (Transform child in content)\n        {\n            RectTransform childRect = child.GetComponent<RectTransform>();\n            if (RectTransformUtility.RectangleContainsScreenPoint(selectionBox, childRect.position))\n            {\n                Debug.Log(\"Selected: \" + child.name);\n                // 对选中的实例进行操作，比如高亮显示或添加到选中列表中\n            }\n        }\n    }\n}\n#endif\n源代码内容解释如下：\n### 1. 功能概览\n\n#### 代码功能定位\n该代码实现了一个用于Unity编辑器的选框工具（Selection Box），允许用户通过鼠标拖动在场景视图中选择多个对象。该工具的核心功能包括：\n- **选框绘制**：在鼠标拖动时实时更新选框的大小和位置\n- **对象选择**：检测并记录选框覆盖范围内的所有UI元素\n- **事件处理**：通过Unity的Event Systems接口处理鼠标指针事件\n\n#### 在系统中的角色\n该脚本作为Unity编辑器扩展的一部分，为开发者提供了一种直观的多对象选择工具。它在需要频繁操作多个UI元素的场景中（如关卡编辑器或布局设计器）特别有用。\n\n#### 主要特性与技术实现\n- **事件驱动**：通过实现`IPointerDownHandler`、`IPointerUpHandler`和`IDragHandler`接口，处理鼠标操作事件\n- **实时更新**：在拖动过程中动态调整选框的大小和位置\n- **碰撞检测**：使用`RectTransformUtility.RectangleContainsScreenPoint`方法检测对象是否在选框内\n- **依赖注入**：通过公共变量注入`RectTransform`组件，便于在Inspector面板中配置\n\n---\n\n### 2. 核心类解析\n\n#### `SelectionBox`类\n\n- **职责说明**：\n  - 管理选框的显示与隐藏\n  - 处理鼠标事件以更新选框位置和大小\n  - 检测并记录选框内的对象\n\n- **关键方法清单**：\n  - `public void OnPointerDown(PointerEventData eventData)`：处理鼠标按下事件\n  - `public void OnDrag(PointerEventData eventData)`：处理鼠标拖动事件\n  - `public void OnPointerUp(PointerEventData eventData)`：处理鼠标释放事件\n  - `private void UpdateSelectionBox(Vector2 currentPoint)`：更新选框的位置和大小\n  - `private void SelectInstances()`：检测并记录选框内的对象\n\n- **继承关系**：\n  ```mermaid\n  classDiagram\n    class MonoBehaviour\n    class SelectionBox {\n      <<Extend>>\n    }\n    SelectionBox --> MonoBehaviour\n  ```\n\n- **依赖模块**：\n  - `UnityEngine.EventSystems`：用于处理鼠标事件\n  - `UnityEngine.UI`：用于`RectTransform`和`RectTransformUtility`类\n  - `UnityEngine`：基础Unity功能\n\n---\n\n### 3. 关键方法详解\n\n#### `OnPointerDown(PointerEventData eventData)`\n- **方法签名**：`public void OnPointerDown(PointerEventData eventData)`\n- **功能描述**：\n  - 记录鼠标按下的起始位置\n  - 激活选框（`SetActive(true)`）\n  - 调用`UpdateSelectionBox`方法以更新选框初始位置\n- **调用关系**：\n  - 由Unity的事件系统在鼠标按下时调用\n  - 调用频率：仅在鼠标按下时调用一次\n\n#### `OnDrag(PointerEventData eventData)`\n- **方法签名**：`public void OnDrag(PointerEventData eventData)`\n- **功能描述**：\n  - 拖动过程中不断更新选框的位置和大小\n  - 调用`UpdateSelectionBox`方法以实时调整选框\n- **调用关系**：\n  - 由Unity的事件系统在鼠标拖动时调用\n  - 调用频率：每",
    "chunk_order_index": 0,
    "full_doc_id": "doc-93385bed62254ca46f3d9ef5cdd9e37b"
  },
  "chunk-290735ada8efadba59921fc9109a2f05": {
    "tokens": 778,
    "content": "时调用一次\n\n#### `OnDrag(PointerEventData eventData)`\n- **方法签名**：`public void OnDrag(PointerEventData eventData)`\n- **功能描述**：\n  - 拖动过程中不断更新选框的位置和大小\n  - 调用`UpdateSelectionBox`方法以实时调整选框\n- **调用关系**：\n  - 由Unity的事件系统在鼠标拖动时调用\n  - 调用频率：每帧拖动时调用\n\n#### `OnPointerUp(PointerEventData eventData)`\n- **方法签名**：`public void OnPointerUp(PointerEventData eventData)`\n- **功能描述**：\n  - 鼠标释放时隐藏选框\n  - 调用`SelectInstances`方法检测并记录选中的对象\n- **调用关系**：\n  - 由Unity的事件系统在鼠标释放时调用\n  - 调用频率：仅在鼠标释放时调用一次\n\n#### `UpdateSelectionBox(Vector2 currentPoint)`\n- **方法签名**：`private void UpdateSelectionBox(Vector2 currentPoint)`\n- **功能描述**：\n  - 计算选框的大小和位置\n  - 根据鼠标拖动的距离调整选框的`anchoredPosition`和`sizeDelta`\n  - 处理负方向拖动的情况以确保选框正确显示\n- **算法说明**：\n  - 计算当前点与起始点的差值作为选框的大小\n  - 根据差值的正负调整选框的位置\n- **调用关系**：\n  - 由`OnPointerDown`和`OnDrag`方法调用\n  - 调用频率：鼠标拖动时每帧调用\n\n#### `SelectInstances()`\n- **方法签名**：`private void SelectInstances()`\n- **功能描述**：\n  - 创建一个与选框位置和大小匹配的`Rect`区域\n  - 遍历`content`容器的所有子节点\n  - 检测子节点的`RectTransform`是否在选框内\n  - 记录选中的对象（当前仅输出日志）\n- **算法说明**：\n  - 使用`RectTransformUtility.RectangleContainsScreenPoint`方法检测碰撞\n  - 遍历所有子节点，逐个检查是否在选框内\n- **调用关系**：\n  - 由`OnPointerUp`方法调用\n  - 调用频率：仅在鼠标释放时调用一次\n\n---\n\n### 4. 架构关系图\n\n```mermaid\nclassDiagram\n  class MonoBehaviour\n  class SelectionBox {\n    +void OnPointerDown(PointerEventData eventData)\n    +void OnDrag(PointerEventData eventData)\n    +void OnPointerUp(PointerEventData eventData)\n    +void UpdateSelectionBox(Vector2 currentPoint)\n    +void SelectInstances()\n  }\n  class RectTransform\n  class PointerEventData\n  class Transform\n  class RectTransformUtility\n\n  SelectionBox --> MonoBehaviour : Inherits\n  SelectionBox --> RectTransform : Uses\n  SelectionBox --> PointerEventData : Uses\n  SelectionBox --> Transform : Uses\n  SelectionBox --> RectTransformUtility : Uses\n```\n\n---\n\n### 总结\n\n该代码实现了一个功能完善的选框工具，通过事件驱动的方式处理鼠标操作，实时更新选框并检测选中的对象。它在Unity编辑器中提供了直观的多对象选择功能，适用于需要频繁操作UI元素的场景。代码结构清晰，依赖明确，具有较高的可维护性和扩展性。",
    "chunk_order_index": 1,
    "full_doc_id": "doc-93385bed62254ca46f3d9ef5cdd9e37b"
  }
}